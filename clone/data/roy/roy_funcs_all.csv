id,code
0,"boolean isBinaryFile ( File f ) throws FileNotFoundException , IOException { FileInputStream in = new FileInputStream ( f ) ; int size = in . available ( ) ; if ( size > 1024 ) size = 1024 ; byte [ ] data = new byte [ size ] ; in . read ( data ) ; in . close ( ) ; int ascii = 0 ; int other = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { byte b = data [ i ] ; if ( b < 0x09 ) return true ; if ( b == 0x09 || b == 0x0A || b == 0x0C || b == 0x0D ) ascii ++ ; else if ( b >= 0x20 && b <= 0x7E ) ascii ++ ; else other ++ ; } if ( other == 0 ) return false ; return 100 * other / ( ascii + other ) > 95 ; }"
1,"boolean isBinaryFile ( File f ) throws IOException { String type = Files . probeContentType ( f . toPath ( ) ) ; if ( type == null ) { return true ; } else if ( type . startsWith ( ""text"" ) ) { return false ; } else { return true ; } }"
2,Comparable [ ] findCommonElements ( ) { Set < Comparable > collectionSet1 = new HashSet < > ( Arrays . asList ( collection1 ) ) ; Set < Comparable > collectionSet2 = new HashSet < > ( Arrays . asList ( collection2 ) ) ; for ( Comparable x : collectionSet1 ) { if ( ! collectionSet2 . add ( x ) ) { commonStuff . add ( x ) ; } } return commonStuff . toArray ( ) ; }
3,"Comparable [ ] findCommonElements ( Comparable [ ] [ ] collections ) { Comparable [ ] arr1 = collections [ 0 ] ; Comparable [ ] arr2 = collections [ 1 ] ; Comparable [ ] arr3 = collections [ 2 ] ; if ( arr1 . length < arr2 . length && arr1 . length < arr3 . length || arr2 . length <= arr3 . length ) { hashArray = arr1 ; queryArray = ArrayUtils . addAll ( arr2 , arr3 ) ; } else if ( arr2 . length < arr1 . length && arr2 . length < arr3 . length || arr1 . length <= arr3 . length ) { hashArray = arr2 ; queryArray = ArrayUtils . addAll ( arr1 , arr3 ) ; } else if ( arr3 . length < arr1 . length && arr3 . length < arr2 . length || arr1 . length <= arr2 . length ) { hashArray = arr3 ; queryArray = ArrayUtils . addAll ( arr1 , arr2 ) ; } HashSet < Comparable > intersectionSet = new HashSet < > ( ) ; HashSet < Comparable > arrayToHash = new HashSet < > ( ) ; for ( Comparable element : hashArray ) { arrayToHash . add ( element ) ; } for ( Comparable element : queryArray ) { if ( element != null ) { comparisons ++ ; } if ( arrayToHash . contains ( element ) ) { intersectionSet . add ( element ) ; } } return intersectionSet . toArray ( new Comparable [ 0 ] ) ; }"
4,"void start ( Stage stage ) { final HTMLEditor htmlEditor = new HTMLEditor ( ) ; stage . setScene ( new Scene ( htmlEditor ) ) ; stage . show ( ) ; hideImageNodesMatching ( htmlEditor , Pattern . compile ( "".*(Cut|Copy|Paste).*"" ) , 0 ) ; Node seperator = htmlEditor . lookup ( "".separator"" ) ; seperator . setVisible ( false ) ; seperator . setManaged ( false ) ; }"
5,"void start ( Stage primaryStage ) { final HTMLEditor htmlEditor = new HTMLEditor ( ) ; primaryStage . setScene ( new Scene ( htmlEditor ) ) ; primaryStage . show ( ) ; for ( Node toolBar = htmlEditor . lookup ( "".tool-bar"" ) ; toolBar != null ; toolBar = htmlEditor . lookup ( "".tool-bar"" ) ) { ( ( Pane ) toolBar . getParent ( ) ) . getChildren ( ) . remove ( toolBar ) ; } }"
6,"void main ( String [ ] args ) { String stmt = "" INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,'bb),(b',ccc),(aaa,bbb,ccc); "" ; System . out . printf ( ""%s\n"" , stmt ) ; stmt = stmt . split ( ""(?i)\\s+values\\s*\\(|\\);"" ) [ 1 ] ; System . out . printf ( ""values list: %s\n"" , stmt ) ; Matcher m = Pattern . compile ( ""('\\w*)(\\)\\,\\()+(\\w*')"" ) . matcher ( stmt ) ; while ( m . find ( ) ) { stmt = stmt . substring ( 0 , m . start ( 2 ) ) + ""###"" + stmt . substring ( m . end ( 2 ) , stmt . length ( ) ) ; System . out . printf ( ""values list with pattern subst inside char literal: %s\n"" , stmt ) ; } String [ ] multiValues = stmt . split ( ""\\)\\,\\("" ) ; for ( int i = 0 ; i < multiValues . length ; i ++ ) { multiValues [ i ] = multiValues [ i ] . replaceAll ( ""###"" , ""),("" ) ; } System . out . println ( Arrays . toString ( multiValues ) ) ; }"
7,"void main ( String [ ] args ) { Test t = new Test ( ) ; String [ ] allQueryStrings = new String [ ] { ""INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz);"" , ""INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,bbb,ccc);"" , ""INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,'bb(,)b',ccc);"" , ""INSERT INTO `TABLENAME` VALUES(xxx,yyy,zzz),(aaa,'bb),(b',ccc);"" } ; for ( String queryString : allQueryStrings ) { System . out . println ( queryString ) ; for ( String values : t . extractValues ( queryString ) ) { System . out . println ( values ) ; } } }"
8,"void main ( String [ ] args ) { String string = ""check duplicate charcters in string"" ; string = string . toLowerCase ( ) ; char [ ] charAr = string . toCharArray ( ) ; Arrays . sort ( charAr ) ; for ( int i = 1 ; i < charAr . length ; ) { int count = recursiveMethod ( charAr , i , 1 ) ; if ( count > 1 ) { System . out . println ( ""'"" + charAr [ i ] + ""' comes "" + count + "" times"" ) ; i = i + count ; } else i ++ ; } }"
9,"void main ( String [ ] args ) { String test = ""The quick brown fox jumped over the lazy dog."" ; int countA = 0 , countO = 0 , countSpace = 0 , countDot = 0 ; for ( int i = 0 ; i < test . length ( ) ; i ++ ) { switch ( test . charAt ( i ) ) { case 'a' : case 'A' : countA ++ ; break ; case 'o' : case 'O' : countO ++ ; break ; case ' ' : countSpace ++ ; break ; case '.' : countDot ++ ; break ; } } System . out . printf ( ""%s%d%n%s%d%n%s%d%n%s%d"" , ""A: "" , countA , ""O: "" , countO , ""Space: "" , countSpace , ""Dot: "" , countDot ) ; }"
10,IntList get ( int i ) { IntList current = this ; for ( int k = 0 ; k < i - 1 ; k ++ ) { if ( current . next != null ) { current = current . next ; } } return current ; }
11,"IntList get ( int i ) { if ( i < 0 ) { throw new IndexOutOfBoundsException ( ""Index is negative!"" ) ; } if ( i == 0 ) { return this ; } else if ( next != null ) { return next . get ( i - 1 ) ; } throw new IndexOutOfBoundsException ( ""Index exceeds bounds"" ) ; }"
12,"int solution ( int N ) { String binary = Integer . toString ( N , 2 ) ; int largestGap = 0 ; for ( int i = 1 , gap = 0 ; i < binary . length ( ) ; i ++ ) { while ( i < binary . length ( ) && binary . charAt ( i ) == '0' ) { i ++ ; gap ++ ; } if ( gap > largestGap && i < binary . length ( ) ) { largestGap = gap ; } gap = 0 ; } return largestGap ; }"
13,"int solution ( int N ) { int gap = 0 ; String binaryStr = Integer . toBinaryString ( N ) ; String [ ] zeroArrays = binaryStr . split ( ""1"" ) ; System . out . println ( Arrays . toString ( zeroArrays ) ) ; for ( String zeroArray : zeroArrays ) { gap = zeroArray . length ( ) > gap ? zeroArray . length ( ) : gap ; } return gap ; }"
14,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
15,"void run ( ) { int i = 3 ; while ( i < 50 ) { while ( s . getState ( ) != 2 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 2 ) System . out . println ( ""t3 "" + i ) ; i = i + 3 ; s . setState ( 3 ) ; s . notifyAll ( ) ; } } }"
16,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
17,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
18,"String getProtocol ( final String source ) { assert source != null ; String protocol = null ; try { final URI uri = new URI ( source ) ; if ( uri . isAbsolute ( ) ) { protocol = uri . getScheme ( ) ; } else { final URL url = new URL ( source ) ; protocol = url . getProtocol ( ) ; } } catch ( final Exception e ) { if ( source . startsWith ( ""//"" ) ) { throw new IllegalArgumentException ( ""Relative context: "" + source ) ; } else { final File file = new File ( source ) ; protocol = getProtocol ( file ) ; } } return protocol ; }"
19,"String getProtocol ( final File file ) { String result ; try { result = file . toURI ( ) . toURL ( ) . getProtocol ( ) ; } catch ( Exception e ) { result = ""unknown"" ; } return result ; }"
20,"boolean isPermutation ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } int [ ] charCount = new int [ 256 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { charCount [ s1 . charAt ( i ) ] ++ ; charCount [ s2 . charAt ( i ) ] -- ; } for ( int i = 0 ; i < charCount . length ; i ++ ) { if ( charCount [ i ] != 0 ) { return false ; } } return true ; }"
21,"boolean isPermutation ( String a , String b ) { char [ ] aArray = a . toCharArray ( ) ; char [ ] bArray = b . toCharArray ( ) ; if ( a . length ( ) != b . length ( ) ) { return false ; } int found = 0 ; for ( int i = 0 ; i < aArray . length ; i ++ ) { char eachA = aArray [ i ] ; for ( int k = 0 ; k < bArray . length ; k ++ ) { if ( eachA == bArray [ k ] ) { found ++ ; bArray [ k ] = 'ï¿¿' ; break ; } } } return found == a . length ( ) ; }"
22,"boolean longerTF ( boolean [ ] guess ) { int consecutiveVariableTrue = 0 , maxConsecutiveVariableTrue = 0 ; int consecutiveVariableFalse = 0 , maxConsecutiveVariableFalse = 0 ; for ( int x = 0 ; x < guess . length ; x ++ ) { if ( guess [ x ] == true ) { consecutiveVariableTrue ++ ; if ( maxConsecutiveVariableTrue < consecutiveVariableTrue ) maxConsecutiveVariableTrue = consecutiveVariableTrue ; } else { consecutiveVariableTrue = 0 ; } } for ( int x = 0 ; x < guess . length ; x ++ ) { if ( guess [ x ] == false ) { consecutiveVariableFalse ++ ; if ( maxConsecutiveVariableFalse < consecutiveVariableFalse ) maxConsecutiveVariableFalse = consecutiveVariableFalse ; } else { consecutiveVariableFalse = 0 ; } } if ( maxConsecutiveVariableTrue >= maxConsecutiveVariableFalse ) { return true ; } return false ; }"
23,boolean longerTF ( boolean [ ] guess ) { int variableTrue = 0 ; int variableFalse = 0 ; for ( int x = 0 ; x < guess . length ; x ++ ) { if ( guess [ x ] ) { variableTrue ++ ; } else { variableFalse ++ ; } } return variableTrue >= variableFalse ; }
24,"File createTempDir ( ) throws IOException { final File sysTempDir = new File ( System . getProperty ( ""java.io.tmpdir"" ) ) ; File newTempDir ; final int maxAttempts = 9 ; int attemptCount = 0 ; do { attemptCount ++ ; if ( attemptCount > maxAttempts ) { throw new IOException ( ""The highly improbable has occurred! Failed to "" + ""create a unique temporary directory after "" + maxAttempts + "" attempts."" ) ; } String dirName = UUID . randomUUID ( ) . toString ( ) ; newTempDir = new File ( sysTempDir , dirName ) ; } while ( newTempDir . exists ( ) ) ; if ( newTempDir . mkdirs ( ) ) { return newTempDir ; } else { throw new IOException ( ""Failed to create temp dir named "" + newTempDir . getAbsolutePath ( ) ) ; } }"
25,"File createTempDir ( ) { final String baseTempPath = System . getProperty ( ""java.io.tmpdir"" ) ; Random rand = new Random ( ) ; int randomInt = 1 + rand . nextInt ( ) ; File tempDir = new File ( baseTempPath + File . separator + ""tempDir"" + randomInt ) ; if ( tempDir . exists ( ) == false ) { tempDir . mkdir ( ) ; } tempDir . deleteOnExit ( ) ; return tempDir ; }"
26,"void actionPerformed ( ActionEvent arg0 ) { int result = JOptionPane . OK_OPTION ; if ( dirty ) { result = JOptionPane . showConfirmDialog ( gui , ""Erase the current painting?"" ) ; } if ( result == JOptionPane . OK_OPTION ) { clear ( canvasImage ) ; } }"
27,"void actionPerformed ( ActionEvent e ) { int x = ( int ) ( Math . random ( ) * getWidth ( ) ) ; int y = ( int ) ( Math . random ( ) * getHeight ( ) ) ; int width = ( int ) ( Math . random ( ) * ( getWidth ( ) / 4 ) ) ; int height = ( int ) ( Math . random ( ) * ( getHeight ( ) / 4 ) ) ; if ( x + width > getWidth ( ) ) { x = getWidth ( ) - width ; } if ( y + height > getHeight ( ) ) { y = getHeight ( ) - height ; } Color color = new Color ( ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) ) ; lstShapes . add ( new MyRectangle ( x , y , width , height , color ) ) ; repaint ( ) ; }"
28,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
29,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
30,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
31,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tac"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
32,"void manage ( ) { double speed = getSpeedfromVehicle ( ) ; if ( ( speed >= 0 && speed <= 10 ) && state != SpeedState . LOW ) { state = SpeedState . LOW ; System . out . println ( ""Low Speed mode"" ) ; } else if ( ( speed > 10 && speed < 60 ) && state != SpeedState . MEDIUM ) { state = SpeedState . MEDIUM ; System . out . println ( ""Medium Speed Mode"" ) ; } else if ( ( speed >= 60 ) && state != SpeedState . HIGH ) { state = SpeedState . HIGH ; System . out . println ( ""High Speed Mode"" ) ; } }"
33,Speedo manage ( int speed ) { if ( speed < getLowRange ( ) ) { onLowTransition ( ) ; return getLowState ( ) ; } else if ( speed > getHighRange ( ) ) { onHighTransition ( ) ; return getHighState ( ) ; } else { return this ; } }
34,"void main ( String [ ] args ) { InputStream inStream = null ; OutputStream outStream = null ; try { File afile = new File ( ""C:\\folderA\\Afile.txt"" ) ; File bfile = new File ( ""C:\\folderB\\Afile.txt"" ) ; inStream = new FileInputStream ( afile ) ; outStream = new FileOutputStream ( bfile ) ; byte [ ] buffer = new byte [ 1024 ] ; int length ; while ( ( length = inStream . read ( buffer ) ) > 0 ) { outStream . write ( buffer , 0 , length ) ; } inStream . close ( ) ; outStream . close ( ) ; afile . delete ( ) ; System . out . println ( ""File is copied successful!"" ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
35,"void main ( String [ ] args ) throws IOException { Path source = Paths . get ( ""/path/to/source/dir"" ) ; Path destination = Paths . get ( ""/path/to/dest/dir"" ) ; List < Path > sources = Files . walk ( source ) . collect ( toList ( ) ) ; List < Path > destinations = sources . stream ( ) . map ( source :: relativize ) . map ( destination :: resolve ) . collect ( toList ( ) ) ; for ( int i = 0 ; i < sources . size ( ) ; i ++ ) { Files . copy ( sources . get ( i ) , destinations . get ( i ) ) ; } }"
36,"int [ ] randNums ( int total , int minVal , int numRands ) { if ( minVal * numRands > total ) { throw new IllegalArgumentException ( ) ; } int [ ] results = randNums ( total - minVal * numRands , numRands ) ; for ( int i = 0 ; i < numRands ; ++ i ) { results [ i ] += minVal ; } return results ; }"
37,"int [ ] randNums ( int total , int n ) { final int [ ] results = new int [ n ] ; if ( total == 0 ) { Arrays . fill ( results , 0 ) ; return results ; } final BigInteger [ ] rs = new BigInteger [ n ] ; final BigInteger totalPlus1 = BigInteger . valueOf ( total + 1L ) ; while ( true ) { for ( int i = 0 ; i < n ; ++ i ) { rs [ i ] = new BigInteger ( 256 , rand ) ; } BigInteger sum = BigInteger . ZERO ; for ( BigInteger r : rs ) { sum = sum . add ( r ) ; } if ( sum . compareTo ( BigInteger . ZERO ) == 0 ) { continue ; } for ( int i = 0 ; i < n ; ++ i ) { results [ i ] = sum . mod ( rs [ i ] ) . mod ( totalPlus1 ) . intValue ( ) ; } return results ; } }"
38,"void main ( String [ ] args ) { double rate = 0 ; CurrencyConverter w = new CurrencyConverter ( ) ; w . print ( ) ; System . out . print ( ""Choose the input currency: "" ) ; Scanner sc = new Scanner ( System . in ) ; int choice = sc . nextInt ( ) ; Currency from = Currency . values ( ) [ choice ] ; System . out . print ( ""Choose the output currency: "" ) ; int output = sc . nextInt ( ) ; Currency to = Currency . values ( ) [ output ] ; System . out . printf ( ""Now enter the input in "" + from . description + "": "" ) ; double input = sc . nextDouble ( ) ; if ( from == to ) { System . out . println ( ""Troller ._. pabobo"" ) ; } rate = to . conversion / from . conversion ; System . out . print ( ""The Conversion of "" + from . description + "" to "" + to . description + "" = "" + rate ) ; }"
39,"void main ( String [ ] args ) { double rate = 0 ; CurrencyConverter w = new CurrencyConverter ( ) ; w . print ( ) ; System . out . print ( ""Choose the input currency: "" ) ; Scanner sc = new Scanner ( System . in ) ; int choice = sc . nextInt ( ) ; if ( choice < 1 || choice > 12 ) { System . out . println ( ""404 not found XD"" ) ; sc . close ( ) ; return ; } System . out . print ( ""Choose the output currency: "" ) ; int output = sc . nextInt ( ) ; Currency first = Currency . values ( ) [ choice - 1 ] ; Currency second = Currency . values ( ) [ output - 1 ] ; System . out . printf ( ""Now enter the input in "" + first . getFullName ( ) + "": "" ) ; double input = sc . nextDouble ( ) ; if ( choice == output ) System . out . println ( ""Troller ._. pabobo"" ) ; rate = ( input * first . getRate ( ) ) / second . getRate ( ) ; System . out . print ( ""The conversion of "" + first . toString ( ) + "" to "" + second . toString ( ) + "" = "" + rate ) ; sc . close ( ) ; }"
40,void type ( char c ) { keyPress ( VK_ALT ) ; keyPress ( VK_NUMPAD0 ) ; keyRelease ( VK_NUMPAD0 ) ; String altCode = Integer . toString ( c ) ; for ( int i = 0 ; i < altCode . length ( ) ; i ++ ) { c = ( char ) ( altCode . charAt ( i ) + '0' ) ; keyPress ( c ) ; keyRelease ( c ) ; } keyRelease ( VK_ALT ) ; }
41,void type ( char character ) { handleSpecialCharacter ( character ) ; if ( Character . isLowerCase ( character ) ) { typeCharacter ( Character . toUpperCase ( character ) ) ; } if ( Character . isUpperCase ( character ) ) { typeShiftCharacter ( character ) ; } if ( Character . isDigit ( character ) ) { typeCharacter ( character ) ; } }
42,"void run ( ) { IntStream . range ( 0 , 500 ) . forEach ( value -> { final Map < String , Integer > map = pseudoQueryDatabase ( ) ; final int index = new Random ( ) . nextInt ( MAP_SIZE ) ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( index ) ) { holdersCache . add ( new EntryHolder ( entry ) ) ; break ; } } try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } ) ; }"
43,void run ( ) { Object o = object ; for ( ; ; ) { try { sleep ( Long . MAX_VALUE ) ; } catch ( InterruptedException e ) { } } }
44,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
45,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
46,"void main ( String ... args ) throws IOException { int [ ] nums = new int [ 10 * 1000 * 1000 ] ; { long start = System . nanoTime ( ) ; product2 ( nums ) ; long time = System . nanoTime ( ) - start ; System . out . printf ( ""Took %.3f seconds to take the product of %,d ints using an int[].%n"" , time / 1e9 , nums . length ) ; } { long start = System . nanoTime ( ) ; product ( nums ) ; long time = System . nanoTime ( ) - start ; System . out . printf ( ""Took %.3f seconds to take the product of %,d ints using reflections.%n"" , time / 1e9 , nums . length ) ; } }"
47,"void main ( String arg [ ] ) { Integer [ ] v1 = { 1 , - 10 , 3 , 9 , 7 , 99 , - 25 } ; Integer [ ] v2 = { 1 , - 10 , 3 , 9 , 7 , 99 , - 25 } ; double p_int = ArrayMath . ScalarProduct ( v1 , v2 ) ; Double [ ] v1_d = { 1.1 , - 10.5 , 3.7 , 9.98 , 7.4 , 9.9 , - 2.5 } ; Double [ ] v2_d = { 1.1 , - 10.5 , 3.7 , 9.98 , 7.4 , 9.9 , - 2.5 } ; Double p_double = ArrayMath . ScalarProduct ( v1_d , v2_d ) ; System . out . println ( ""p_intï¼"" + p_int ) ; System . out . println ( ""p_doubleï¼"" + p_double ) ; }"
48,"void main ( String [ ] args ) { Scanner keyboard = new Scanner ( System . in ) ; System . out . print ( ""Number of days in the period: "" ) ; numberofDays = keyboard . nextInt ( ) ; System . out . print ( ""Share points on the first day: "" ) ; sharePoints = keyboard . nextInt ( ) ; while ( numberofDays < 10 || numberofDays > 20 ) { System . out . println ( ""The number of days doesnât meet the required criteria, enter it again"" ) ; System . out . print ( ""Number of days in the period: "" ) ; numberofDays = keyboard . nextInt ( ) ; } DisplayStock ( ) ; }"
49,"void main ( String [ ] args ) { int numberofDays ; int sharePoints ; Scanner keyboard = new Scanner ( System . in ) ; System . out . print ( ""Number of days in the period: "" ) ; numberofDays = keyboard . nextInt ( ) ; System . out . print ( ""Share points on the first day: "" ) ; sharePoints = keyboard . nextInt ( ) ; numberofDays = validator ( numberofDays , keyboard ) ; outPutTablePrinter ( numberofDays , sharePoints ) ; }"
50,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; String inString ; int decimal ; System . out . println ( ""Enter a binary number: "" ) ; inString = input . nextLine ( ) ; while ( inString != ""-1"" ) { int i ; int binaryLength ; binaryLength = inString . length ( ) ; for ( i = 0 , decimal = 0 ; i < binaryLength ; i ++ ) { decimal = decimal * 2 + ( Character . getNumericValue ( inString . charAt ( i ) ) - 0 ) ; System . out . print ( decimal ) ; } System . out . println ( ""Enter a binary number: "" ) ; inString = input . nextLine ( ) ; } System . out . println ( ""All set !"" ) ; }"
51,"void main ( String [ ] args ) { final Scanner input = new Scanner ( System . in ) ; String inString ; while ( true ) { System . out . println ( ""Enter a binary number: "" ) ; inString = input . nextLine ( ) ; if ( inString . equals ( ""-1"" ) ) break ; System . out . println ( Integer . parseInt ( inString , 2 ) ) ; } System . out . println ( ""All set !"" ) ; }"
52,"int search ( int [ ] A , int K ) { int l = - 1 ; int u = A . length ; int m ; while ( l + 1 < u ) { m = l + ( u - l ) / 2 ; if ( A [ m ] < K ) { l = m ; } else { u = m ; } } if ( ( u == A . length ) || ( A [ u ] != K ) ) return - 1 ; return u ; }"
53,"int search ( int [ ] A , int K ) { int l = 0 ; int u = A . length - 1 ; int m ; while ( l <= u ) { m = ( u - l ) / 2 + l ; if ( A [ m ] < K ) l = m + 1 ; else if ( A [ m ] == K ) return m ; else u = m - 1 ; } return - 1 ; }"
54,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] arr = new int [ S . length ( ) ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : arr [ i ] = 1 ; break ; case 'C' : arr [ i ] = 2 ; break ; case 'G' : arr [ i ] = 3 ; break ; case 'T' : arr [ i ] = 4 ; break ; default : break ; } } segmentNode root = buildTree ( arr , 0 , S . length ( ) - 1 ) ; int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { result [ i ] = getMin ( root , P [ i ] , Q [ i ] ) ; } return result ; }"
55,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int N = S . length ( ) ; int M = P . length ; int [ ] result = new int [ M ] ; lastOccurrencesMap = new int [ 3 ] [ N ] ; int lastA = - 1 ; int lastC = - 1 ; int lastG = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { char c = S . charAt ( i ) ; if ( c == 'A' ) { lastA = i ; } else if ( c == 'C' ) { lastC = i ; } else if ( c == 'G' ) { lastG = i ; } lastOccurrencesMap [ 0 ] [ i ] = lastA ; lastOccurrencesMap [ 1 ] [ i ] = lastC ; lastOccurrencesMap [ 2 ] [ i ] = lastG ; } for ( int i = 0 ; i < M ; i ++ ) { int startIndex = P [ i ] ; int endIndex = Q [ i ] ; int minimum = 4 ; for ( int n = 0 ; n < 3 ; n ++ ) { int lastOccurence = getLastNucleotideOccurrence ( startIndex , endIndex , n ) ; if ( lastOccurence != 0 ) { minimum = n + 1 ; break ; } } result [ i ] = minimum ; } return result ; }"
56,"void actionPerformed ( ActionEvent arg0 ) { if ( ! dirty ) { JFileChooser ch = getFileChooser ( ) ; int result = ch . showOpenDialog ( gui ) ; if ( result == JFileChooser . APPROVE_OPTION ) { try { BufferedImage bi = ImageIO . read ( ch . getSelectedFile ( ) ) ; setImage ( bi ) ; } catch ( IOException e ) { showError ( e ) ; e . printStackTrace ( ) ; } } } else { JOptionPane . showMessageDialog ( gui , ""TODO - prompt save image.."" ) ; } }"
57,"void actionPerformed ( ActionEvent e ) { int x = ( int ) ( Math . random ( ) * getWidth ( ) ) ; int y = ( int ) ( Math . random ( ) * getHeight ( ) ) ; int width = ( int ) ( Math . random ( ) * ( getWidth ( ) / 4 ) ) ; int height = ( int ) ( Math . random ( ) * ( getHeight ( ) / 4 ) ) ; if ( x + width > getWidth ( ) ) { x = getWidth ( ) - width ; } if ( y + height > getHeight ( ) ) { y = getHeight ( ) - height ; } Color color = new Color ( ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) ) ; lstShapes . add ( new MyRectangle ( x , y , width , height , color ) ) ; repaint ( ) ; }"
58,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
59,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
60,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
61,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , HSSFCell cellOld , XSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( XSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
62,boolean isBalanced ( String expression ) { if ( ( expression . length ( ) % 2 ) == 1 ) return false ; else { Stack < Character > s = new Stack < > ( ) ; for ( char bracket : expression . toCharArray ( ) ) switch ( bracket ) { case '{' : s . push ( '}' ) ; break ; case '(' : s . push ( ')' ) ; break ; case '[' : s . push ( ']' ) ; break ; default : if ( s . isEmpty ( ) || bracket != s . peek ( ) ) { return false ; } s . pop ( ) ; } return s . isEmpty ( ) ; } }
63,"boolean isBalanced ( String strExpression ) { Map < Character , Character > bracketPair = new HashMap < Character , Character > ( ) ; bracketPair . put ( '(' , ')' ) ; bracketPair . put ( '[' , ']' ) ; bracketPair . put ( '{' , '}' ) ; Stack < Character > stk = new Stack < Character > ( ) ; for ( int i = 0 ; i < strExpression . length ( ) ; i ++ ) { if ( bracketPair . containsKey ( strExpression . charAt ( i ) ) ) stk . push ( strExpression . charAt ( i ) ) ; else if ( bracketPair . containsValue ( strExpression . charAt ( i ) ) ) if ( stk . isEmpty ( ) || bracketPair . get ( stk . pop ( ) ) != strExpression . charAt ( i ) ) return false ; } if ( stk . isEmpty ( ) ) return true ; else return false ; }"
64,"void main ( String [ ] args ) { String s = ""AVBVDABCHJHDFABCJKHKHF"" , ned = ""ABC"" ; int nedIndex = - 1 , count = 0 , totalNed = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i > ned . length ( ) - 1 ) nedIndex ++ ; else nedIndex = i ; if ( s . charAt ( i ) == ned . charAt ( nedIndex ) ) count ++ ; else { nedIndex = 0 ; count = 0 ; if ( s . charAt ( i ) == ned . charAt ( nedIndex ) ) count ++ ; else nedIndex = - 1 ; } if ( count == ned . length ( ) ) { nedIndex = - 1 ; count = 0 ; totalNed ++ ; System . out . println ( totalNed + "" needle found at index="" + ( i - ( ned . length ( ) - 1 ) ) ) ; } } System . out . print ( ""Total Ned="" + totalNed ) ; }"
65,"void main ( String [ ] args ) { String needle = ""ABC"" ; String haystack = ""ABCDSGDABCSAGAABCCCCAAABAABC"" ; int numberOfOccurences = 0 ; int index = haystack . indexOf ( needle ) ; while ( index != - 1 ) { numberOfOccurences ++ ; haystack = haystack . substring ( index + needle . length ( ) ) ; index = haystack . indexOf ( needle ) ; } System . out . println ( """" + numberOfOccurences ) ; }"
66,"void main ( String [ ] args ) throws Exception { NestedMap < String , Integer > test = new NestedMap < > ( ) ; test . put ( ""a"" ) . put ( ""b"" ) . put ( ""c"" , 12 ) ; Map . Entry < String , Integer > foo = test . put ( ""a"" ) . put ( ""b"" ) . put ( ""d"" , 12 ) ; test . put ( ""b"" , 14 ) ; ObjectMapper mapper = new ObjectMapper ( ) ; System . out . println ( mapper . writeValueAsString ( test ) ) ; foo . setValue ( 99 ) ; System . out . println ( mapper . writeValueAsString ( test ) ) ; System . out . println ( test . get ( ""a"" ) . get ( ""b"" ) . getValue ( ""d"" ) ) ; }"
67,void main ( String [ ] args ) { BinaryTreeWithoutRecursion < Integer > ls = new BinaryTreeWithoutRecursion < > ( ) ; ls . insert ( 1 ) ; ls . insert ( 2 ) ; ls . insert ( 3 ) ; ls . insert ( 4 ) ; ls . insert ( 5 ) ; ls . insert ( 6 ) ; ls . insert ( 7 ) ; ls . inOrderPrint ( ) ; }
68,"void main ( String [ ] args ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; DocumentBuilder builder ; Document doc = null ; try { builder = factory . newDocumentBuilder ( ) ; doc = builder . parse ( ""employees.xml"" ) ; XPathFactory xpathFactory = XPathFactory . newInstance ( ) ; XPath xpath = xpathFactory . newXPath ( ) ; String name = getEmployeeNameById ( doc , xpath , 4 ) ; System . out . println ( ""Employee Name with ID 4: "" + name ) ; List < String > names = getEmployeeNameWithAge ( doc , xpath , 30 ) ; System . out . println ( ""Employees with 'age>30' are:"" + Arrays . toString ( names . toArray ( ) ) ) ; List < String > femaleEmps = getFemaleEmployeesName ( doc , xpath ) ; System . out . println ( ""Female Employees names are:"" + Arrays . toString ( femaleEmps . toArray ( ) ) ) ; } catch ( ParserConfigurationException | SAXException | IOException e ) { e . printStackTrace ( ) ; } }"
69,"void main ( String s [ ] ) throws VTDException , java . io . UnsupportedEncodingException , java . io . IOException { VTDGen vg = new VTDGen ( ) ; if ( ! vg . parseFile ( ""input.xml"" , false ) ) return ; VTDNav vn = vg . getNav ( ) ; AutoPilot ap = new AutoPilot ( vn ) ; XMLModifier xm = new XMLModifier ( vn ) ; ap . selectXPath ( ""/*/place[@id=\""p14\"" and   @initialMarking=\""2\""]/@initialMarking"" ) ; int i = 0 ; while ( ( i = ap . evalXPath ( ) ) != - 1 ) { xm . updateToken ( i + 1 , ""499"" ) ; } xm . output ( ""new.xml"" ) ; }"
70,"V put ( K key , V value ) { readWriteLock . writeLock ( ) . lock ( ) ; V old ; try { old = super . put ( key , value ) ; } finally { readWriteLock . writeLock ( ) . unlock ( ) ; } return old ; }"
71,"void put ( Key key , Value val ) { if ( map . containsKey ( key ) ) { put ( key , val ) ; return ; } while ( currentSize >= maxSize ) { freeSpace ( ) ; } synchronized ( this ) { queue . add ( key ) ; map . put ( key , val ) ; currentSize ++ ; } }"
72,"void main ( String [ ] args ) { SendMyFiles sendMyFiles = new SendMyFiles ( ) ; if ( args . length < 1 ) { System . err . println ( ""Usage: java "" + sendMyFiles . getClass ( ) . getName ( ) + "" Properties_file File_To_FTP "" ) ; System . exit ( 1 ) ; } String propertiesFile = args [ 0 ] . trim ( ) ; String fileToFTP = args [ 1 ] . trim ( ) ; sendMyFiles . startFTP ( propertiesFile , fileToFTP ) ; }"
73,"void main ( String [ ] args ) throws IOException { final SSHClient ssh = new SSHClient ( ) ; ssh . loadKnownHosts ( ) ; ssh . connect ( ""localhost"" ) ; try { ssh . authPublickey ( System . getProperty ( ""user.name"" ) ) ; final String src = System . getProperty ( ""user.home"" ) + File . separator + ""test_file"" ; final SFTPClient sftp = ssh . newSFTPClient ( ) ; try { sftp . put ( new FileSystemFile ( src ) , ""/tmp"" ) ; } finally { sftp . close ( ) ; } } finally { ssh . disconnect ( ) ; } }"
74,"int solution ( int A [ ] , int N ) { int i , leftSum , rightSum , last_minimum , current_min ; leftSum = A [ 0 ] ; rightSum = 0 ; i = 1 ; while ( i < N ) { rightSum += A [ i ] ; i ++ ; } last_minimum = abs ( leftSum - rightSum ) ; if ( last_minimum == 0 ) return last_minimum ; i = 2 ; while ( i < N ) { leftSum += A [ i - 1 ] ; rightSum -= A [ i - 1 ] ; current_min = abs ( leftSum - rightSum ) ; if ( current_min == 0 ) return current_min ; if ( last_minimum > current_min ) last_minimum = current_min ; i ++ ; } return last_minimum ; }"
75,int solution ( int [ ] A ) { if ( A . length == 2 ) return Math . abs ( A [ 0 ] - A [ 1 ] ) ; int [ ] s1 = new int [ A . length - 1 ] ; s1 [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < A . length - 1 ; i ++ ) { s1 [ i ] = s1 [ i - 1 ] + A [ i ] ; } int [ ] s2 = new int [ A . length - 1 ] ; s2 [ A . length - 2 ] = A [ A . length - 1 ] ; for ( int i = A . length - 3 ; i >= 0 ; i -- ) { s2 [ i ] = s2 [ i + 1 ] + A [ i + 1 ] ; } int finalSum = Integer . MAX_VALUE ; for ( int j = 0 ; j < s1 . length ; j ++ ) { int sum = Math . abs ( s1 [ j ] - s2 [ j ] ) ; if ( sum < finalSum ) finalSum = sum ; } return finalSum ; }
76,"String capitalize ( String str ) { if ( TextUtils . isEmpty ( str ) ) { return str ; } char [ ] arr = str . toCharArray ( ) ; boolean capitalizeNext = true ; String phrase = """" ; for ( char c : arr ) { if ( capitalizeNext && Character . isLetter ( c ) ) { phrase += Character . toUpperCase ( c ) ; capitalizeNext = false ; continue ; } else if ( Character . isWhitespace ( c ) ) { capitalizeNext = true ; } phrase += c ; } return phrase ; }"
77,"String capitalize ( String s ) { if ( s == null || s . length ( ) == 0 ) { return """" ; } char first = s . charAt ( 0 ) ; if ( Character . isUpperCase ( first ) ) { return s ; } else { return Character . toUpperCase ( first ) + s . substring ( 1 ) ; } }"
78,"void start ( Stage stage ) throws Exception { StackPane notedPane = new StackPane ( ) ; notedPane . setPrefSize ( 20 , 20 ) ; notedPane . setMaxSize ( Region . USE_PREF_SIZE , Region . USE_PREF_SIZE ) ; notedPane . setStyle ( ""-fx-background-color: purple;"" ) ; StackPane rootPane = new StackPane ( notedPane ) ; rootPane . setPrefSize ( 400 , 400 ) ; StackPane . setAlignment ( notedPane , Pos . BOTTOM_CENTER ) ; stage . setScene ( new Scene ( rootPane ) ) ; stage . show ( ) ; StackPane stickyNotesPane = new StackPane ( ) ; stickyNotesPane . setPrefSize ( 200 , 200 ) ; stickyNotesPane . setStyle ( ""-fx-background-color: yellow;"" ) ; Popup popup = new Popup ( ) ; popup . getContent ( ) . add ( stickyNotesPane ) ; notedPane . hoverProperty ( ) . addListener ( ( obs , oldVal , newValue ) -> { if ( newValue ) { Bounds bnds = notedPane . localToScreen ( notedPane . getLayoutBounds ( ) ) ; double x = bnds . getMinX ( ) - ( stickyNotesPane . getWidth ( ) / 2 ) + ( notedPane . getWidth ( ) / 2 ) ; double y = bnds . getMinY ( ) - stickyNotesPane . getHeight ( ) ; popup . show ( notedPane , x , y ) ; } else { popup . hide ( ) ; } } ) ; }"
79,"void start ( Stage stage ) throws Exception { StackPane notedPane = new StackPane ( ) ; notedPane . setPrefSize ( 20 , 20 ) ; notedPane . setMaxSize ( Region . USE_PREF_SIZE , Region . USE_PREF_SIZE ) ; notedPane . setStyle ( ""-fx-background-color: purple;"" ) ; StackPane rootPane = new StackPane ( notedPane ) ; rootPane . setPrefSize ( 400 , 400 ) ; StackPane . setAlignment ( notedPane , Pos . BOTTOM_CENTER ) ; stage . setScene ( new Scene ( rootPane ) ) ; stage . show ( ) ; Stage stickyNotesStage = new Stage ( ) ; stickyNotesStage . initOwner ( stage ) ; stickyNotesStage . initStyle ( StageStyle . UNDECORATED ) ; StackPane stickyNotesPane = new StackPane ( ) ; stickyNotesPane . setPrefSize ( 200 , 200 ) ; stickyNotesPane . setStyle ( ""-fx-background-color: yellow;"" ) ; stickyNotesStage . setScene ( new Scene ( stickyNotesPane ) ) ; notedPane . hoverProperty ( ) . addListener ( ( ChangeListener < Boolean > ) ( observable , oldValue , newValue ) -> { if ( newValue ) { stickyNotesStage . show ( ) ; } else { stickyNotesStage . hide ( ) ; } } ) ; }"
80,"void put ( K key , V val ) { while ( currentSize >= maxSize ) { freeSpace ( ) ; } if ( map . containsKey ( key ) ) { get ( key ) ; return ; } ListNode < K > ln = queue . add ( key ) ; ValueHolder < K , V > rv = new ValueHolder < K , V > ( val , ln ) ; map . put ( key , rv ) ; currentSize ++ ; }"
81,"void put ( Key key , Value val ) { if ( map . containsKey ( key ) ) { put ( key , val ) ; return ; } while ( currentSize >= maxSize ) { freeSpace ( ) ; } synchronized ( this ) { queue . add ( key ) ; map . put ( key , val ) ; currentSize ++ ; } }"
82,"void main ( String [ ] args ) { File fileName = new File ( ""hello.txt"" ) ; try { Scanner scan = new Scanner ( fileName ) ; while ( scan . hasNextLine ( ) ) { String line = scan . nextLine ( ) ; System . out . println ( line ) ; int indexHello = line . lastIndexOf ( ""hello"" , 0 ) ; int indexBye = line . indexOf ( ""bye"" . indexHello ) ; String newString = line . substring ( indexHello , indexBye ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }"
83,"void main ( String [ ] args ) { File fileName = new File ( ""hello.txt"" ) ; try { String startToken = ""Hello"" ; String endToken = ""Bye"" ; boolean output = false ; Scanner scan = new Scanner ( fileName ) ; while ( scan . hasNextLine ( ) ) { String line = scan . nextLine ( ) ; if ( ! output && line . indexOf ( startToken ) > - 1 ) { output = true ; line = line . substring ( line . indexOf ( startToken ) + startToken . length ( ) ) ; } else if ( output && line . indexOf ( endToken ) > - 1 ) { output = false ; System . out . println ( line . substring ( 0 , line . indexOf ( endToken ) ) ) ; } if ( output ) { System . out . println ( line ) ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }"
84,"void run ( ) { JFrame frame = new JFrame ( ""Menu test"" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setSize ( new Dimension ( 600 , 400 ) ) ; JMenuBar menuBar = new JMenuBar ( ) ; JMenu menu = new JMenu ( ""Test"" ) ; JPopupMenu popupMenu = menu . getPopupMenu ( ) ; popupMenu . setLayout ( new GridLayout ( 5 , 5 ) ) ; for ( int r = 0 ; r < 5 ; r ++ ) { for ( int c = 0 ; c < 5 ; c ++ ) { popupMenu . add ( new JMenuItem ( ""("" + ( r + 1 ) + "", "" + ( c + 1 ) + "")"" ) ) ; } } menuBar . add ( menu ) ; frame . setJMenuBar ( menuBar ) ; frame . setVisible ( true ) ; }"
85,"void run ( ) { JMenuBar menuBar = new JMenuBar ( ) ; JMenu menu = new JMenu ( ""A regular menu"" ) ; menu . add ( new JMenuItem ( ""Menu item"" ) ) ; JMenu gridMenu = new JMenu ( ""Menu with grid"" ) ; gridMenu . getPopupMenu ( ) . setLayout ( new GridLayout ( 2 , 2 ) ) ; gridMenu . add ( ""Top left"" ) ; gridMenu . add ( ""Top right"" ) ; gridMenu . add ( ""Bottom left"" ) ; gridMenu . add ( ""Bottom right"" ) ; menu . add ( gridMenu ) ; menuBar . add ( menu ) ; JFrame frame = new JFrame ( ""Menus"" ) ; frame . setJMenuBar ( menuBar ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . pack ( ) ; frame . setVisible ( true ) ; }"
86,"void main ( String args [ ] ) throws IOException { JavaPingExampleProgram ping = new JavaPingExampleProgram ( ) ; List < String > commands = new ArrayList < String > ( ) ; commands . add ( ""ping"" ) ; commands . add ( ""-c"" ) ; commands . add ( ""5"" ) ; commands . add ( ""74.125.236.73"" ) ; ping . doCommand ( commands ) ; }"
87,"void main ( String [ ] args ) { try { InetAddress address = InetAddress . getByName ( ""192.168.1.103"" ) ; boolean reachable = address . isReachable ( 10000 ) ; System . out . println ( ""Is host reachable? "" + reachable ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
88,"void listFilesForFolder ( final File folder ) { for ( final File fileEntry : folder . listFiles ( ) ) { if ( fileEntry . isDirectory ( ) ) { listFilesForFolder ( fileEntry ) ; } else { if ( fileEntry . isFile ( ) ) { temp = fileEntry . getName ( ) ; if ( ( temp . substring ( temp . lastIndexOf ( '.' ) + 1 , temp . length ( ) ) . toLowerCase ( ) ) . equals ( ""txt"" ) ) System . out . println ( ""File= "" + folder . getAbsolutePath ( ) + ""\\"" + fileEntry . getName ( ) ) ; } } } }"
89,void listFilesForFolder ( final File folder ) { for ( final File fileEntry : folder . listFiles ( ) ) { if ( fileEntry . isDirectory ( ) ) { listFilesForFolder ( fileEntry ) ; } else { System . out . println ( fileEntry . getName ( ) ) ; } } }
90,"int countLines ( String filename ) throws IOException { LineNumberReader reader = new LineNumberReader ( new FileReader ( filename ) ) ; int cnt = 0 ; String lineRead = """" ; while ( ( lineRead = reader . readLine ( ) ) != null ) { } cnt = reader . getLineNumber ( ) ; reader . close ( ) ; return cnt ; }"
91,"long countLines ( InputStream is ) throws IOException { try ( LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( is ) ) ) { char [ ] buf = new char [ 8192 ] ; int n , previousN = - 1 ; while ( ( n = lnr . read ( buf ) ) != - 1 ) { previousN = n ; } int ln = lnr . getLineNumber ( ) ; if ( previousN == - 1 ) { return 0 ; } else { char lastChar = buf [ previousN - 1 ] ; if ( lastChar == '\n' || lastChar == '\r' ) { return ln ; } } return ln + 1 ; } }"
92,"void actionPerformed ( ActionEvent e ) { try { OutputStream os = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; XMLEncoder xe = new XMLEncoder ( os ) ; xe . setPersistenceDelegate ( DefaultTableModel . class , new DefaultTableModelPersistenceDelegate ( ) ) ; xe . writeObject ( model ) ; xe . close ( ) ; Reader r = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , ""UTF-8"" ) ) ; textArea . read ( r , null ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }"
93,void actionPerformed ( ActionEvent e ) { try { InputStream is = new BufferedInputStream ( new FileInputStream ( file ) ) ; XMLDecoder xd = new XMLDecoder ( is ) ; model = ( DefaultTableModel ) xd . readObject ( ) ; table . setModel ( model ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
94,"void main ( String args [ ] ) throws IOException { BufferedReader dataIn = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String strSize , strGrades ; int laki = 100 ; int totalGrades = 0 ; float gradeAverage = 0 ; float [ ] grades = new float [ laki ] ; System . out . print ( ""How many grades will you enter?"" ) ; strSize = dataIn . readLine ( ) ; laki = Integer . parseInt ( strSize ) ; grades = new float [ laki ] ; for ( int i = 0 ; i < laki ; i ++ ) { System . out . print ( ""Please enter grade # "" + ( i + 1 ) + "": "" ) ; strGrades = dataIn . readLine ( ) ; grades [ i ] = Float . parseFloat ( strGrades ) ; totalGrades += grades [ i ] ; } gradeAverage = totalGrades / laki ; System . out . println ( ""Your grades average is "" + gradeAverage ) ; }"
95,"void main ( String args [ ] ) throws IOException { BufferedReader dataIn = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int totalGrades = 0 ; float gradeAverage = 0 ; System . out . print ( ""How many grades will you enter?"" ) ; int laki = Integer . parseInt ( dataIn . readLine ( ) ) ; float [ ] grades = new float [ laki ] ; int count = 0 ; while ( laki > 0 ) { System . out . print ( ""Please enter grade # "" + ( count + 1 ) + "": "" ) ; grades [ count ] = Float . parseFloat ( dataIn . readLine ( ) ) ; totalGrades += grades [ count ] ; laki -- ; count ++ ; } gradeAverage = ( float ) totalGrades / count ; System . out . println ( ""Your grades average is "" + gradeAverage ) ; }"
96,"void createAndShowGUI ( ) { final JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setLayout ( new FlowLayout ( ) ) ; JButton readerStopButton_ = new JButton ( ) ; readerStopButton_ . setFocusPainted ( false ) ; readerStopButton_ . setBackground ( UIManager . getDefaults ( ) . getColor ( ""Button.light"" ) ) ; readerStopButton_ . setFont ( new Font ( ""Geneva"" , 0 , 12 ) ) ; readerStopButton_ . setText ( ""<html><center>READER<br>STOP</center></html>\n"" ) ; readerStopButton_ . setHorizontalTextPosition ( SwingConstants . CENTER ) ; frame . add ( readerStopButton_ ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; }"
97,"void createAndShowGUI ( ) { final JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setLayout ( new FlowLayout ( ) ) ; JPanel operationButtons_ = new JPanel ( ) ; JButton readerStopButton_ = new JButton ( ) ; readerStopButton_ . setBackground ( javax . swing . UIManager . getDefaults ( ) . getColor ( ""Button.light"" ) ) ; readerStopButton_ . setFont ( new java . awt . Font ( ""Geneva"" , 0 , 12 ) ) ; readerStopButton_ . setText ( ""<html><center>READER<br>STOP</center></html>\n"" ) ; readerStopButton_ . setToolTipText ( ""<html><b>Stop</b> button is currently inactive.  "" ) ; readerStopButton_ . setMargin ( new Insets ( 0 , - 30 , 0 , - 30 ) ) ; readerStopButton_ . setPreferredSize ( new Dimension ( 66 , 40 ) ) ; operationButtons_ . add ( readerStopButton_ ) ; readerStopButton_ = new JButton ( ) ; readerStopButton_ . setBackground ( javax . swing . UIManager . getDefaults ( ) . getColor ( ""Button.light"" ) ) ; readerStopButton_ . setFont ( new java . awt . Font ( ""Geneva"" , 0 , 12 ) ) ; readerStopButton_ . setText ( ""<html><center>READER<br>STOP</center></html>\n"" ) ; readerStopButton_ . setToolTipText ( ""<html><b>Stop</b> button is currently inactive.  "" ) ; System . out . println ( readerStopButton_ . getPreferredSize ( ) ) ; readerStopButton_ . setPreferredSize ( new Dimension ( 66 , 40 ) ) ; operationButtons_ . add ( readerStopButton_ ) ; operationButtons_ . add ( new JButton ( ""yCoder.com"" ) ) ; frame . add ( operationButtons_ ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; }"
98,"String center ( String text , int len ) { if ( len <= text . length ( ) ) return text . substring ( 0 , len ) ; int before = ( len - text . length ( ) ) / 2 ; if ( before == 0 ) return String . format ( ""%-"" + len + ""s"" , text ) ; int rest = len - before ; return String . format ( ""%"" + before + ""s%-"" + rest + ""s"" , """" , text ) ; }"
99,"String center ( String s , int size , char pad ) { if ( s == null || size <= s . length ( ) ) return s ; StringBuilder sb = new StringBuilder ( size ) ; for ( int i = 0 ; i < ( size - s . length ( ) ) / 2 ; i ++ ) { sb . append ( pad ) ; } sb . append ( s ) ; while ( sb . length ( ) < size ) { sb . append ( pad ) ; } return sb . toString ( ) ; }"
100,"int [ ] solution ( String S , int [ ] P , int [ ] K ) { char [ ] sc = S . toCharArray ( ) ; int [ ] A = new int [ sc . length ] ; int [ ] G = new int [ sc . length ] ; int [ ] C = new int [ sc . length ] ; int prevA = - 1 , prevG = - 1 , prevC = - 1 ; for ( int i = 0 ; i < sc . length ; i ++ ) { if ( sc [ i ] == 'A' ) prevA = i ; else if ( sc [ i ] == 'G' ) prevG = i ; else if ( sc [ i ] == 'C' ) prevC = i ; A [ i ] = prevA ; G [ i ] = prevG ; C [ i ] = prevC ; } int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { if ( A [ K [ i ] ] >= P [ i ] && A [ K [ i ] ] <= K [ i ] ) { result [ i ] = 1 ; } else if ( C [ K [ i ] ] >= P [ i ] && C [ K [ i ] ] <= K [ i ] ) { result [ i ] = 2 ; } else if ( G [ K [ i ] ] >= P [ i ] && G [ K [ i ] ] <= K [ i ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } return result ; }"
101,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] answer = new int [ P . length ] ; char [ ] chars = S . toCharArray ( ) ; int [ ] [ ] cumulativeAnswers = new int [ 4 ] [ chars . length + 1 ] ; for ( int iii = 0 ; iii < chars . length ; iii ++ ) { if ( iii > 0 ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { cumulativeAnswers [ zzz ] [ iii + 1 ] = cumulativeAnswers [ zzz ] [ iii ] ; } } switch ( chars [ iii ] ) { case 'A' : cumulativeAnswers [ 0 ] [ iii + 1 ] ++ ; break ; case 'C' : cumulativeAnswers [ 1 ] [ iii + 1 ] ++ ; break ; case 'G' : cumulativeAnswers [ 2 ] [ iii + 1 ] ++ ; break ; case 'T' : cumulativeAnswers [ 3 ] [ iii + 1 ] ++ ; break ; } } for ( int iii = 0 ; iii < P . length ; iii ++ ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { if ( ( cumulativeAnswers [ zzz ] [ Q [ iii ] + 1 ] - cumulativeAnswers [ zzz ] [ P [ iii ] ] ) > 0 ) { answer [ iii ] = zzz + 1 ; break ; } } } return answer ; }"
102,"void main ( String [ ] args ) { int number ; Scanner in = new Scanner ( System . in ) ; System . out . println ( ""Enter a positive integer"" ) ; number = in . nextInt ( ) ; if ( number < 0 ) { System . out . println ( ""Error: Not a positive integer"" ) ; } else { System . out . print ( ""Convert to binary is:"" ) ; printBinaryform ( number ) ; } }"
103,"void main ( String h [ ] ) { Scanner sc = new Scanner ( System . in ) ; int decimal = sc . nextInt ( ) ; String binary = """" ; if ( decimal <= 0 ) { System . out . println ( ""Please Enter more than 0"" ) ; } else { while ( decimal > 0 ) { binary = ( decimal % 2 ) + binary ; decimal = decimal / 2 ; } System . out . println ( ""binary is:"" + binary ) ; } }"
104,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
105,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
106,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
107,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
108,"String toHexString ( byte [ ] bytes ) { char [ ] hexArray = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] hexChars = new char [ 10000000 ] ; int c = 0 ; int v ; for ( j = 0 ; j < bytes . length ; j ++ ) { v = bytes [ j ] & 0xFF ; hexChars [ c ] = hexArray [ v / 16 ] ; c ++ ; hexChars [ c ] = hexArray [ v % 16 ] ; c ++ ; } return new String ( hexChars , 0 , c ) ; }"
109,String toHexString ( byte [ ] bytes ) { StringBuilder hexString = new StringBuilder ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { String hex = Integer . toHexString ( 0xFF & bytes [ i ] ) ; if ( hex . length ( ) == 1 ) { hexString . append ( '0' ) ; } hexString . append ( hex ) ; } return hexString . toString ( ) ; }
110,"double [ ] [ ] amountOTP ( double [ ] [ ] a , int x ) { if ( x > a . length ) return a ; for ( double [ ] arr : a ) if ( arr . length < x ) return a ; double [ ] [ ] newArray = new double [ x ] [ x ] ; for ( int i = 0 ; i < x ; i ++ ) for ( int j = 0 ; j < x ; j ++ ) newArray [ i ] [ j ] = a [ i ] [ j ] ; return newArray ; }"
111,"double [ ] [ ] amountOTP ( double [ ] [ ] a , int x ) { double [ ] [ ] b = new double [ x ] [ x ] ; x = Math . min ( x , a . length ) ; for ( int i = 0 ; i < x ; i ++ ) for ( int j = 0 ; j < x ; j ++ ) b [ i ] [ j ] = a [ i ] [ j ] ; return b ; }"
112,"int maxBlock ( String str ) { Pattern pattern = Pattern . compile ( ""(.)(\\1)*"" ) ; Matcher matcher = pattern . matcher ( str ) ; int max = 0 ; while ( matcher . find ( ) ) { max = Math . max ( max , matcher . group ( ) . length ( ) ) ; } return max ; }"
113,"int maxBlock ( String str ) { int maxCounter = 1 ; int counter = 1 ; if ( str . length ( ) == 0 ) { return 0 ; } for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( i ) ) { counter ++ ; } else { if ( counter > maxCounter ) { maxCounter = counter ; } counter = 1 ; } } return Math . max ( maxCounter , counter ) ; }"
114,"void main ( String [ ] args ) { List < Point > points = new ArrayList < Point > ( ) ; points . add ( createPoint ( ""A"" , 1 , 0 ) ) ; points . add ( createPoint ( ""B"" , 1 , 1 ) ) ; points . add ( createPoint ( ""C"" , 1 , 2 ) ) ; points . add ( createPoint ( ""D"" , 2 , 2 ) ) ; points . add ( createPoint ( ""E"" , 3 , 1 ) ) ; points . add ( createPoint ( ""F"" , 4 , 1 ) ) ; points . add ( createPoint ( ""G"" , 5 , 1 ) ) ; points . add ( createPoint ( ""H"" , 5 , 2 ) ) ; List < Integer > indices = computeTurningPointIndices ( points ) ; System . out . println ( ""Turning points are at "" + indices ) ; List < Point > turningPoints = indices . stream ( ) . map ( i -> points . get ( i ) ) . collect ( Collectors . toList ( ) ) ; System . out . println ( ""They are "" + turningPoints ) ; System . out . println ( ""Collinear:"" ) ; indices . add ( 0 , 0 ) ; indices . add ( points . size ( ) - 1 ) ; for ( int i = 0 ; i < indices . size ( ) - 1 ; i ++ ) { int i0 = indices . get ( i ) ; int i1 = indices . get ( i + 1 ) ; List < Point > collinear = points . subList ( i0 , i1 + 1 ) ; System . out . println ( ""    "" + collinear ) ; } }"
115,"void main ( String [ ] args ) { ArrayList < Point > positions = new ArrayList < Point > ( ) ; positions . add ( new Point ( 1 , 0 ) ) ; positions . add ( new Point ( 1 , 1 ) ) ; positions . add ( new Point ( 1 , 2 ) ) ; positions . add ( new Point ( 2 , 2 ) ) ; positions . add ( new Point ( 3 , 1 ) ) ; positions . add ( new Point ( 4 , 1 ) ) ; positions . add ( new Point ( 5 , 1 ) ) ; positions . add ( new Point ( 5 , 2 ) ) ; ArrayList < Point > turns = new ArrayList < Point > ( ) ; for ( int i = 0 ; i < positions . size ( ) ; i ++ ) { turns . add ( null ) ; } int counter = 0 ; if ( positions . size ( ) > 2 ) { Point base = positions . get ( 0 ) ; Point next = positions . get ( 1 ) ; int x = ( next . x - base . x ) ; double slope = 1.0 * ( next . y - base . y ) / ( next . x - base . x ) ; for ( int i = 2 ; i < positions . size ( ) ; i ++ ) { Point newpoint = positions . get ( i ) ; double newslope = 1.0 * ( newpoint . y - next . y ) / ( newpoint . x - next . x ) ; if ( newslope != slope ) { counter ++ ; turns . set ( i - 1 , positions . get ( i - 1 ) ) ; slope = newslope ; } next = newpoint ; } } System . out . println ( ""Collinear points:"" ) ; for ( int i = 0 ; i < positions . size ( ) ; i ++ ) { System . out . print ( ""("" + positions . get ( i ) . x + "", "" + positions . get ( i ) . y + "") "" ) ; if ( turns . get ( i ) != null ) { System . out . println ( ) ; System . out . print ( ""("" + positions . get ( i ) . x + "", "" + positions . get ( i ) . y + "") "" ) ; } } System . out . println ( ) ; System . out . println ( ) ; if ( counter > 0 ) { System . out . println ( ""Turns at these points: "" ) ; for ( Point p : turns ) { if ( p != null ) System . out . print ( ""("" + p . x + "", "" + p . y + "") "" ) ; } } else { System . out . println ( ""There are no turns!"" ) ; } }"
116,"void main ( String [ ] args ) { boolean t = true ; first : { second : { third : { System . out . println ( ""Before the break"" ) ; if ( t ) { break second ; } System . out . println ( ""Not executed"" ) ; } System . out . println ( ""Not executed - end of second block"" ) ; } System . out . println ( ""End of third block"" ) ; } }"
117,"void main ( String [ ] args ) { int temp = 0 ; out : for ( int i = 0 ; i < 3 ; ++ i ) { System . out . println ( ""I am here"" ) ; for ( int j = 0 ; j < 20 ; ++ j ) { if ( temp == 0 ) { System . out . println ( ""j: "" + j ) ; if ( j == 1 ) { temp = j ; continue out ; } } } } System . out . println ( ""temp = "" + temp ) ; }"
118,"int solution ( int N ) { int tempGap = 0 , gap = 0 ; String binaryString = Integer . toBinaryString ( N ) ; int i = 0 ; while ( i < binaryString . length ( ) ) { if ( binaryString . charAt ( i ) == '1' ) { ++ i ; tempGap = 0 ; while ( i < binaryString . length ( ) && binaryString . charAt ( i ) != '1' ) { ++ i ; tempGap ++ ; } if ( i >= binaryString . length ( ) ) { tempGap = 0 ; } } else { ++ i ; } if ( tempGap > gap ) { gap = tempGap ; } } return gap ; }"
119,"int solution ( Integer number ) { String binary = Integer . toBinaryString ( number ) ; String [ ] gaps = binary . split ( ""1"" ) ; String biggestGap = """" ; for ( int i = 0 ; i < ( binary . endsWith ( ""1"" ) ? gaps . length : gaps . length - 1 ) ; i ++ ) { if ( gaps [ i ] . contains ( ""0"" ) && gaps [ i ] . length ( ) > biggestGap . length ( ) ) biggestGap = gaps [ i ] ; } return biggestGap . length ( ) ; }"
120,"void copyFolder ( File src , File dest ) throws IOException { try ( Stream < Path > stream = Files . walk ( src . toPath ( ) ) ) { stream . forEachOrdered ( sourcePath -> { try { Files . copy ( sourcePath , src . toPath ( ) . resolve ( dest . toPath ( ) . relativize ( sourcePath ) ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ; } }"
121,"void copyFolder ( Path src , Path dest ) { try { Files . walk ( src ) . forEach ( s -> { try { Path d = dest . resolve ( src . relativize ( s ) ) ; if ( Files . isDirectory ( s ) ) { if ( ! Files . exists ( d ) ) Files . createDirectory ( d ) ; return ; } Files . copy ( s , d ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }"
122,"void main ( String [ ] args ) throws Exception { Console console = System . console ( ) ; if ( console == null ) { System . out . println ( ""Unable to fetch console"" ) ; return ; } String line = console . readLine ( ) ; console . printf ( ""I saw this line: %s"" , line ) ; }"
123,"void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Please enter user name : "" ) ; String username = null ; try { username = reader . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( ""You entered : "" + username ) ; Scanner in = new Scanner ( System . in ) ; System . out . print ( ""Please enter user name : "" ) ; username = in . nextLine ( ) ; System . out . println ( ""You entered : "" + username ) ; Console console = System . console ( ) ; username = console . readLine ( ""Please enter user name : "" ) ; System . out . println ( ""You entered : "" + username ) ; }"
124,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
125,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
126,"String capitalizer ( final String texto ) { String [ ] palavras = texto . split ( "" "" ) ; StringBuilder sb = new StringBuilder ( ) ; List < String > excessoes = new ArrayList < String > ( Arrays . asList ( ""de"" , ""da"" , ""das"" , ""do"" , ""dos"" , ""na"" , ""nas"" , ""no"" , ""nos"" , ""a"" , ""e"" , ""o"" , ""em"" , ""com"" ) ) ; for ( String palavra : palavras ) { if ( excessoes . contains ( palavra . toLowerCase ( ) ) ) sb . append ( palavra . toLowerCase ( ) ) . append ( "" "" ) ; else sb . append ( Character . toUpperCase ( palavra . charAt ( 0 ) ) ) . append ( palavra . substring ( 1 ) . toLowerCase ( ) ) . append ( "" "" ) ; } return sb . toString ( ) . trim ( ) ; }"
127,"String capitalizer ( String word ) { String [ ] words = word . split ( "" "" ) ; StringBuilder sb = new StringBuilder ( ) ; if ( words [ 0 ] . length ( ) > 0 ) { sb . append ( Character . toUpperCase ( words [ 0 ] . charAt ( 0 ) ) + words [ 0 ] . subSequence ( 1 , words [ 0 ] . length ( ) ) . toString ( ) . toLowerCase ( ) ) ; for ( int i = 1 ; i < words . length ; i ++ ) { sb . append ( "" "" ) ; sb . append ( Character . toUpperCase ( words [ i ] . charAt ( 0 ) ) + words [ i ] . subSequence ( 1 , words [ i ] . length ( ) ) . toString ( ) . toLowerCase ( ) ) ; } } return sb . toString ( ) ; }"
128,void type ( char character ) { handleSpecialCharacter ( character ) ; if ( Character . isLowerCase ( character ) ) { typeCharacter ( Character . toUpperCase ( character ) ) ; } if ( Character . isUpperCase ( character ) ) { typeShiftCharacter ( character ) ; } if ( Character . isDigit ( character ) ) { typeCharacter ( character ) ; } }
129,void type ( String text ) { char c ; for ( int ii = 0 ; ii < text . length ( ) ; ii ++ ) { c = text . charAt ( ii ) ; if ( c <= 31 || c == 129 ) { pressControlKey ( c ) ; } else { typeAsciiCode ( c ) ; } } }
130,"void sort ( int [ ] input ) { for ( int i = 0 ; i < input . length - 1 ; i ++ ) { int k = i + 1 ; int nxtVal = input [ k ] ; while ( input [ k - 1 ] > nxtVal ) { input [ k ] = input [ k - 1 ] ; k -- ; if ( k == 0 ) break ; } input [ k ] = nxtVal ; } System . out . println ( ""Medium sorting is done and the result is :"" ) ; for ( int i : input ) { System . out . print ( i + "","" ) ; } }"
131,"void sort ( int [ ] input , int startIndx , int endIndx ) { int endIndexOrig = endIndx ; int startIndexOrig = startIndx ; if ( startIndx >= endIndx ) return ; int pavitVal = input [ endIndx ] ; while ( startIndx <= endIndx ) { while ( input [ startIndx ] < pavitVal ) startIndx ++ ; while ( input [ endIndx ] > pavitVal ) endIndx -- ; if ( startIndx <= endIndx ) { int tmp = input [ startIndx ] ; input [ startIndx ] = input [ endIndx ] ; input [ endIndx ] = tmp ; startIndx ++ ; endIndx -- ; } } sort ( input , startIndexOrig , endIndx ) ; sort ( input , startIndx , endIndexOrig ) ; }"
132,"void main ( String [ ] args ) { String str = ""123"" ; byte barr [ ] = str . getBytes ( ) ; System . out . println ( Arrays . toString ( barr ) ) ; int result = 0 ; for ( int i = 0 ; i < barr . length ; i ++ ) { int ii = barr [ i ] ; char a = ( char ) ii ; int no = Character . getNumericValue ( a ) ; result = result * 10 + no ; System . out . println ( result ) ; } System . out . println ( ""result:"" + result ) ; }"
133,"void main ( String args [ ] ) { String inputString ; Scanner s = new Scanner ( System . in ) ; inputString = s . nextLine ( ) ; if ( ! inputString . matches ( ""([+-]?([0-9]*[.])?[0-9]+)"" ) ) { System . out . println ( ""Not a Number"" ) ; } else { Double result2 = getNumber ( inputString ) ; System . out . println ( ""result = "" + result2 ) ; } }"
134,"void main ( String [ ] args ) throws InterruptedException { MyThread mt = new MyThread ( ) ; mt . hello = hello ; mt . world = world ; mt . start ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { hello . acquire ( ) ; System . out . println ( ""Hello"" ) ; world . release ( ) ; } }"
135,"void main ( String [ ] args ) { int sayThisManyTimes = 5 ; AtomicBoolean saidHello = new AtomicBoolean ( false ) ; MyThread mt = new MyThread ( sayThisManyTimes , saidHello ) ; mt . start ( ) ; for ( int i = 0 ; i < sayThisManyTimes ; i ++ ) { while ( saidHello . get ( ) ) { } System . out . println ( ""Hello "" ) ; saidHello . set ( true ) ; } }"
136,"String match ( @ PathVariable String matchId , @ RequestBody String body , HttpServletRequest request , HttpServletResponse response ) { String json = matchService . getMatchJson ( matchId ) ; if ( json == null ) { response . setStatus ( HttpServletResponse . SC_BAD_REQUEST ) ; } return json ; }"
137,"ResponseEntity < ? > match ( @ PathVariable String matchId , @ RequestBody String body , HttpServletRequest request , HttpServletResponse response ) { Product p ; try { p = service . getProduct ( request . getProductId ( ) ) ; } catch ( Exception ex ) { return new ResponseEntity < String > ( HttpStatus . BAD_REQUEST ) ; } return new ResponseEntity ( p , HttpStatus . OK ) ; }"
138,int read ( ) throws IOException { if ( currentPos < currentLineEnd ) { in . seek ( currentPos ++ ) ; int readByte = in . readByte ( ) ; return readByte ; } else if ( currentPos > lastPosInFile && currentLineStart < currentLineEnd ) { findPrevLine ( ) ; if ( lastChar != '\n' && lastChar != '\r' ) { return '\n' ; } else { return read ( ) ; } } else if ( currentPos < 0 ) { return - 1 ; } else { findPrevLine ( ) ; return read ( ) ; } }
139,int read ( ) throws IOException { if ( currentFilePos <= 0 && currentBufferPos < 0 && currentLineReadPos < 0 ) { return - 1 ; } if ( ! lineBuffered ) { fillLineBuffer ( ) ; } if ( lineBuffered ) { if ( currentLineReadPos == 0 ) { lineBuffered = false ; } return currentLine [ currentLineReadPos -- ] ; } return 0 ; }
140,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; System . out . print ( ""Enter a String : "" ) ; String str = scan . nextLine ( ) ; ArrayList < String > repetition = new ArrayList < String > ( ) ; ArrayList < String > digrams = new ArrayList < String > ( ) ; String digram ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) { digram = str . substring ( i , i + 2 ) ; if ( repetition . contains ( digram ) || digram . contains ( "" "" ) || digram . length ( ) < 2 ) continue ; int occurances = ( str . length ( ) - str . replace ( digram , """" ) . length ( ) ) / 2 ; occurances += ( str . replaceFirst ( "".*?("" + digram . charAt ( 0 ) + ""+).*"" , ""$1"" ) . length ( ) - 1 ) / 2 ; digrams . add ( digram + "":"" + occurances ) ; repetition . add ( digram ) ; } Collections . sort ( digrams , ( s1 , s2 ) -> s1 . substring ( 3 , 4 ) . compareTo ( s2 . substring ( 3 , 4 ) ) ) ; System . out . println ( digrams ) ; }"
141,"void main ( String args [ ] ) { int ci , i , j , k , l = 0 ; String str , str1 , result , subString ; char c1 , c2 , ch ; Scanner scan = new Scanner ( System . in ) ; System . out . print ( ""Enter a String : "" ) ; str = scan . nextLine ( ) ; i = str . length ( ) ; for ( c1 = 'A' ; c1 <= 'z' ; c1 ++ ) { for ( c2 = 'A' ; c2 <= 'z' ; c2 ++ ) { result = new String ( new char [ ] { c1 , c2 } ) ; k = 0 ; for ( j = 0 ; j < i - 1 ; j ++ ) { subString = str . substring ( j , j + 2 ) ; if ( result . equals ( subString ) ) { k ++ ; } } if ( k > 0 ) { System . out . println ( """" + result + "": "" + k ) ; } } } }"
142,TerminalGui [ ] getTerminalGuis ( ) { Component [ ] comps = this . getComponents ( ) ; int j = 0 ; for ( int i = 0 ; i < comps . length ; i ++ ) { if ( comps [ i ] instanceof TerminalGui ) { j ++ ; } } TerminalGui [ ] terminalGuis = new TerminalGui [ j ] ; int k = 0 ; for ( Component c : comps ) { if ( c instanceof TerminalGui ) { terminalGuis [ k ] = c ; k ++ ; } } return terminalGuis ; }
143,TerminalGui [ ] getTerminalGuis ( ) { Components comps [ ] = getComponents ( ) ; List < TerminalGui > list = new ArrayList < TerminalGui > ( ) ; if ( comps == null ) return null ; for ( Component c : comps ) { if ( c instanceof TerminalGui ) { list . add ( c ) ; } } return list . toArray ( new TerminalGui [ list . size ( ) ] ) ; }
144,"ListNode reverse ( ListNode toBeNextNode , ListNode currentNode ) { ListNode currentHead = currentNode ; if ( ( currentNode == null || currentNode . next == null ) && toBeNextNode == null ) return currentHead ; if ( currentNode . next != null ) currentHead = reverse ( currentNode , currentNode . next ) ; currentNode . next = toBeNextNode ; return currentHead ; }"
145,"Node reverse ( Node n , Node p ) { if ( n == null ) return null ; if ( n . next == null ) { n . next = p ; return n ; } Node r = reverse ( n . next , n ) ; n . next = p ; return r ; }"
146,"boolean isAnagram ( String leftString , String rightString ) { if ( leftString == null || rightString == null ) { return false ; } else if ( leftString . length ( ) != rightString . length ( ) ) { return false ; } char letters [ ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' } ; Map < Character , Integer > occurrencesMap = new HashMap < > ( ) ; for ( char l : letters ) { occurrencesMap . put ( l , 0 ) ; } for ( int i = 0 ; i < leftString . length ( ) ; i ++ ) { char charFromLeft = leftString . charAt ( i ) ; Integer nrOfCharsInLeft = occurrencesMap . get ( charFromLeft ) ; occurrencesMap . put ( charFromLeft , ++ nrOfCharsInLeft ) ; char charFromRight = rightString . charAt ( i ) ; Integer nrOfCharsInRight = occurrencesMap . get ( charFromRight ) ; occurrencesMap . put ( charFromRight , -- nrOfCharsInRight ) ; } for ( Integer occurrencesNr : occurrencesMap . values ( ) ) { if ( occurrencesNr != 0 ) { return false ; } } return true ; }"
147,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int [ ] seen = new int [ 256 ] ; Arrays . fill ( seen , 0 ) ; s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { seen [ s1 . charAt ( i ) ] = seen [ s1 . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( seen [ s2 . charAt ( i ) ] == 0 ) return false ; seen [ s2 . charAt ( i ) ] = seen [ s2 . charAt ( i ) ] - 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( seen [ i ] != 0 ) return false ; } return true ; }"
148,"boolean importData ( TransferHandler . TransferSupport info ) { if ( ! canImport ( info ) ) { return false ; } TransferHandler . DropLocation tdl = info . getDropLocation ( ) ; if ( ! ( tdl instanceof JTable . DropLocation ) ) { return false ; } JTable . DropLocation dl = ( JTable . DropLocation ) tdl ; JTable target = ( JTable ) info . getComponent ( ) ; DefaultTableModel model = ( DefaultTableModel ) target . getModel ( ) ; int index = dl . getRow ( ) ; int max = model . getRowCount ( ) ; if ( index < 0 || index > max ) { index = max ; } addIndex = index ; target . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; try { Object [ ] values = ( Object [ ] ) info . getTransferable ( ) . getTransferData ( localObjectFlavor ) ; addCount = values . length ; for ( int i = 0 ; i < values . length ; i ++ ) { int idx = index ++ ; model . insertRow ( idx , ( Vector ) values [ i ] ) ; target . getSelectionModel ( ) . addSelectionInterval ( idx , idx ) ; } return true ; } catch ( UnsupportedFlavorException | IOException ex ) { ex . printStackTrace ( ) ; } return false ; }"
149,"boolean importData ( JComponent c , Transferable t ) { if ( canImport ( c , t . getTransferDataFlavors ( ) ) ) { try { String str = ( String ) t . getTransferData ( DataFlavor . stringFlavor ) ; importString ( c , str ) ; return true ; } catch ( UnsupportedFlavorException ufe ) { } catch ( IOException ioe ) { } } return false ; }"
150,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
151,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
152,"void main ( String [ ] args ) throws java . lang . Exception { List < Data > data = new ArrayList < Data > ( ) ; data . add ( new Data ( ""Title1"" , ""Link1"" , 8 ) ) ; data . add ( new Data ( ""Title2"" , ""Link2"" , 1 ) ) ; data . add ( new Data ( ""Title3"" , ""Link3"" , 3 ) ) ; for ( Data d : data ) { System . out . print ( d . getNumber ( ) + "" "" ) ; } System . out . println ( ) ; Collections . sort ( data ) ; for ( Data d : data ) { System . out . print ( d . getNumber ( ) + "" "" ) ; } }"
153,"void main ( String [ ] args ) { ArrayList < HashMap < String , String > > yourArrayList = new ArrayList < HashMap < String , String > > ( ) ; HashMap < String , String > myHashMap = new HashMap < String , String > ( ) ; myHashMap . put ( ""title"" , ""first Title"" ) ; myHashMap . put ( ""date"" , ""This is 1st date"" ) ; myHashMap . put ( ""number"" , ""5"" ) ; yourArrayList . add ( 0 , myHashMap ) ; myHashMap = new HashMap < String , String > ( ) ; myHashMap . put ( ""title"" , ""Second Title"" ) ; myHashMap . put ( ""date"" , ""This is 2nd date"" ) ; myHashMap . put ( ""number"" , ""2"" ) ; yourArrayList . add ( 1 , myHashMap ) ; myHashMap = new HashMap < String , String > ( ) ; myHashMap . put ( ""title"" , ""Third Title"" ) ; myHashMap . put ( ""date"" , ""This is 3rd date"" ) ; myHashMap . put ( ""number"" , ""7"" ) ; yourArrayList . add ( 2 , myHashMap ) ; myHashMap = new HashMap < String , String > ( ) ; myHashMap . put ( ""title"" , ""Fourth Title"" ) ; myHashMap . put ( ""date"" , ""This is 4th date"" ) ; myHashMap . put ( ""number"" , ""0"" ) ; yourArrayList . add ( 3 , myHashMap ) ; System . out . println ( ""================="" ) ; System . out . println ( ""BEFORE SORTING"" ) ; System . out . println ( ""================="" ) ; for ( int i = 0 ; i < yourArrayList . size ( ) ; i ++ ) { System . out . println ( yourArrayList . get ( i ) ) ; } HashMap < String , String > temporary ; for ( int c = 0 ; c < ( yourArrayList . size ( ) - 1 ) ; c ++ ) { for ( int d = 0 ; d < ( yourArrayList . size ( ) - c - 1 ) ; d ++ ) { if ( Integer . parseInt ( yourArrayList . get ( d ) . get ( ""number"" ) ) > Integer . parseInt ( yourArrayList . get ( d + 1 ) . get ( ""number"" ) ) ) { temporary = yourArrayList . get ( d ) ; yourArrayList . set ( d , yourArrayList . get ( d + 1 ) ) ; yourArrayList . set ( d + 1 , temporary ) ; } } } System . out . println ( ""================="" ) ; System . out . println ( ""AFTER SORTING"" ) ; System . out . println ( ""================="" ) ; for ( int i = 0 ; i < yourArrayList . size ( ) ; i ++ ) { System . out . println ( yourArrayList . get ( i ) ) ; } }"
154,"void authenticate ( String apiKeyAndSessionKey , String host , String applicationSecret ) throws IOException , XMPPException { if ( apiKeyAndSessionKey == null || applicationSecret == null ) { throw new IllegalArgumentException ( ""Invalid parameters"" ) ; } String [ ] keyArray = apiKeyAndSessionKey . split ( ""\\|"" , 2 ) ; if ( keyArray . length < 2 ) { throw new IllegalArgumentException ( ""API key or session key is not present"" ) ; } this . apiKey = keyArray [ 0 ] ; this . applicationSecret = applicationSecret ; this . sessionKey = keyArray [ 1 ] ; this . authenticationId = sessionKey ; this . password = applicationSecret ; this . hostname = host ; String [ ] mechanisms = { ""DIGEST-MD5"" } ; Map < String , String > props = new HashMap < String , String > ( ) ; this . sc = Sasl . createSaslClient ( mechanisms , null , ""xmpp"" , host , props , this ) ; authenticate ( ) ; }"
155,"void authenticate ( String username , String host , String password ) throws IOException , XMPPException { authenticationId = username ; this . password = password ; hostname = host ; String mechanisms [ ] = { getName ( ) } ; java . util . Map props = new HashMap ( ) ; sc = Sasl . createSaslClient ( mechanisms , null , ""xmpp"" , host , props , this ) ; super . authenticate ( ) ; }"
156,"void main ( String args [ ] ) { int a ; float b ; String s ; Scanner in = new Scanner ( System . in ) ; System . out . println ( ""Enter a string"" ) ; s = in . nextLine ( ) ; System . out . println ( ""You entered string "" + s ) ; System . out . println ( ""Enter an integer"" ) ; a = in . nextInt ( ) ; System . out . println ( ""You entered integer "" + a ) ; System . out . println ( ""Enter a float"" ) ; b = in . nextFloat ( ) ; System . out . println ( ""You entered float "" + b ) ; }"
157,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; final int valid = 6 ; Scanner one = new Scanner ( System . in ) ; System . out . println ( ""Enter your username: "" ) ; String s = one . nextLine ( ) ; if ( s . length ( ) < valid ) { System . out . println ( ""Enter a valid username"" ) ; System . out . println ( ""User name must contain "" + valid + "" characters"" ) ; System . out . println ( ""Enter again: "" ) ; s = one . nextLine ( ) ; } System . out . println ( ""Username accepted: "" + s ) ; Scanner two = new Scanner ( System . in ) ; System . out . println ( ""Enter your age: "" ) ; int a = two . nextInt ( ) ; System . out . println ( ""Age accepted: "" + a ) ; Scanner three = new Scanner ( System . in ) ; System . out . println ( ""Enter your sex: "" ) ; String sex = three . nextLine ( ) ; System . out . println ( ""Sex accepted: "" + sex ) ; }"
158,"String merge ( String ... s ) { int maxLen = 0 ; for ( String str : s ) { maxLen = Math . max ( maxLen , str . length ( ) ) ; } StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < maxLen ; ++ i ) { for ( String str : s ) { if ( str . length ( ) > i ) { b . append ( str . charAt ( i ) ) ; } } } return b . toString ( ) ; }"
159,String merge ( String ... strings ) { int maxLength = 0 ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : strings ) if ( s . length ( ) > maxLength ) maxLength = s . length ( ) ; for ( int i = 0 ; i < maxLength ; i ++ ) for ( String s : strings ) if ( s . length ( ) > i ) sb . append ( s . charAt ( i ) ) ; return sb . toString ( ) ; }
160,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String formatedSource = source . subSequence ( start , end ) . toString ( ) ; String destPrefix = dest . subSequence ( 0 , dstart ) . toString ( ) ; String destSuffix = dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; String result = destPrefix + formatedSource + destSuffix ; result = result . replace ( "","" , ""."" ) ; Matcher matcher = mPattern . matcher ( result ) ; if ( matcher . matches ( ) ) { return null ; } return """" ; }"
161,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { CharSequence out = super . filter ( source , start , end , dest , dstart , dend ) ; if ( out != null ) { source = out ; start = 0 ; end = out . length ( ) ; } int len = end - start ; if ( len == 0 ) { return source ; } int dlen = dest . length ( ) ; for ( int i = 0 ; i < dstart ; i ++ ) { if ( dest . charAt ( i ) == '.' ) { return ( dlen - ( i + 1 ) + len > digits ) ? """" : new SpannableStringBuilder ( source , start , end ) ; } } for ( int i = start ; i < end ; ++ i ) { if ( source . charAt ( i ) == '.' ) { if ( ( dlen - dend ) + ( end - ( i + 1 ) ) > digits ) return """" ; else break ; } } return new SpannableStringBuilder ( source , start , end ) ; }"
162,"void close ( Connection connection , Statement statement , ResultSet rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception e ) { _logger . warning ( e . toString ( ) ) ; } } if ( statement != null ) { try { statement . close ( ) ; } catch ( Exception e ) { _logger . warning ( e . toString ( ) ) ; } } if ( connection != null ) { try { connection . close ( ) ; } catch ( Exception e ) { _logger . warning ( e . toString ( ) ) ; } } }"
163,void close ( Statement ... statements ) { for ( Statement stmt : statements ) { try { if ( stmt != null ) stmt . close ( ) ; } catch ( SQLException se ) { } } }
164,boolean twoDuplicates ( int [ ] values ) { boolean twoDuplicate = false ; int counter = 0 ; Arrays . sort ( values ) ; int old = values [ 0 ] ; boolean numberSeen = false ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] == old ) { if ( ! numberSeen ) { counter ++ ; numberSeen = true ; } } else { numberSeen = false ; old = values [ i ] ; } } if ( counter == 2 ) twoDuplicate = true ; return twoDuplicate ; }
165,boolean twoDuplicates ( int [ ] values ) { for ( int i = 0 ; i < values . length ; i ++ ) { int counter = 0 ; for ( int z = i + 1 ; z <= values . length - 1 ; z ++ ) { if ( values [ i ] == values [ z ] ) { counter ++ ; if ( counter == 2 ) return true ; } } } return false ; }
166,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
167,"void transform ( Integer hash , HSSFCellStyle styleOld , XSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( styleOld . getFont ( this . workbookOld ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
168,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
169,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , Integer hash , XSSFCellStyle styleOld , HSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( workbookOld , workbookNew , styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( workbookNew , ( XSSFFont ) styleOld . getFont ( ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
170,"void main ( String ... aArgs ) { log ( ""Generating random integers in the range 1..10."" ) ; int START = 1 ; int END = 10 ; Random random = new Random ( ) ; for ( int idx = 1 ; idx <= 10 ; ++ idx ) { showRandomInteger ( START , END , random ) ; } log ( ""Done."" ) ; }"
171,"void main ( String [ ] args ) { Random ran = new Random ( ) ; int min , max ; Scanner sc = new Scanner ( System . in ) ; System . out . println ( ""Enter min range:"" ) ; min = sc . nextInt ( ) ; System . out . println ( ""Enter max range:"" ) ; max = sc . nextInt ( ) ; int num = ran . nextInt ( min ) ; int num1 = ran . nextInt ( max ) ; System . out . println ( ""Random Number between given range is "" + num1 ) ; }"
172,"void sublayout ( int width , int height ) { if ( managerWidth == 0 ) { managerWidth = searchEdit . getPreferredWidth ( ) ; } if ( managerHeight == 0 ) { managerHeight = searchEdit . getPreferredHeight ( ) ; } super . sublayout ( managerWidth , managerHeight ) ; setExtent ( managerWidth , managerHeight ) ; }"
173,"void sublayout ( int maxWidth , int maxHeight ) { int currX = 0 ; int currY = 0 ; Field currField ; currField = this . getField ( 0 ) ; switch ( ScreenConfig . getInstance ( ) . getScreen ( ) ) { case ScreenConfig . SCREEN_320_240 : currX = 5 ; currY = 3 ; break ; case ScreenConfig . SCREEN_480_360 : case ScreenConfig . SCREEN_480_320 : currX = 5 ; currY = 1 ; break ; } this . setPositionChild ( currField , currX , currY ) ; this . layoutChild ( currField , currField . getPreferredWidth ( ) , currField . getPreferredHeight ( ) ) ; setExtent ( this . getPreferredWidth ( ) , this . getPreferredHeight ( ) ) ; }"
174,"void printTable ( String [ ] countries , int [ ] populations ) { int countryLength = 0 ; long populationLength = 0 ; for ( String country : countries ) { if ( country . length ( ) > countryLength ) countryLength = country . length ( ) ; } for ( int i : populations ) { if ( String . valueOf ( i ) . length ( ) > populationLength ) populationLength = String . valueOf ( i ) . length ( ) ; } for ( int i = 0 ; i < countries . length ; i ++ ) System . out . format ( ""%-"" + ( countryLength + 1 ) + ""s|%"" + ( populationLength + 1 ) + ""d\n"" , countries [ i ] , populations [ i ] ) ; }"
175,"void printTable ( String [ ] countries , int [ ] populations ) { int defaultLength = 10 ; int maxCountryLength = stream ( countries ) . mapToInt ( String :: length ) . max ( ) . orElse ( defaultLength ) ; int maxPopulationLength = stream ( populations ) . mapToObj ( Integer :: toString ) . mapToInt ( String :: length ) . max ( ) . orElse ( defaultLength ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . format ( ""%-"" + maxCountryLength + ""s | %"" + maxPopulationLength + ""d\n"" , countries [ i ] , populations [ i ] ) ; } }"
176,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
177,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
178,void main ( String [ ] args ) { Vector v1 = new Vector ( ) ; v1 . add ( new PrintOneToHundered ( ) ) ; Vector v2 = new Vector ( ) ; v2 . addAll ( v1 ) ; v2 . addAll ( v1 ) ; Vector v4 = new Vector ( ) ; v4 . addAll ( v2 ) ; v4 . addAll ( v2 ) ; Vector v8 = new Vector ( ) ; v8 . addAll ( v4 ) ; v8 . addAll ( v4 ) ; Vector v16 = new Vector ( ) ; v16 . addAll ( v8 ) ; v16 . addAll ( v8 ) ; Vector v32 = new Vector ( ) ; v32 . addAll ( v16 ) ; v32 . addAll ( v16 ) ; Vector v64 = new Vector ( ) ; v64 . addAll ( v32 ) ; v64 . addAll ( v32 ) ; Vector v100 = new Vector ( ) ; v100 . addAll ( v64 ) ; v100 . addAll ( v32 ) ; v100 . addAll ( v4 ) ; System . out . println ( v100 ) ; }
179,"void main ( String [ ] args ) { String set = new java . util . BitSet ( ) { { set ( 1 , 100 + 1 ) ; } } . toString ( ) ; System . out . append ( set , 1 , set . length ( ) - 1 ) ; }"
180,"Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { Component cellComponent = super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; if ( row == 0 ) { cellComponent . setBackground ( Color . YELLOW ) ; } else if ( row == 1 ) { cellComponent . setBackground ( Color . GRAY ) ; } else { cellComponent . setBackground ( Color . CYAN ) ; } return cellComponent ; }"
181,"Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int col ) { Component c = super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , col ) ; c . setBackground ( Color . WHITE ) ; c . setForeground ( Color . BLACK ) ; JLabel l = ( JLabel ) super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , col ) ; if ( separatedVariable . equals ( ""YOUR VALUE TO GREEN"" ) ) { l . setBackground ( Color . GREEN ) ; return l ; } else { if ( separatedValue . equals ( ""YOUR VALUE TO YELLOW"" ) ) { l . setBackground ( Color . YELLOW ) ; return l ; } else if ( separatedValue . equals ( ""YOUR VALUE TO RED"" ) ) { l . setBaground ( Color . RED ) ; return l ; } } return c ; }"
182,"String validName ( Scanner input , Scanner histogram ) { String user = """" ; String name = input . next ( ) ; String tmp = """" ; boolean test = false ; while ( histogram . hasNext ( ) ) { user = histogram . next ( ) ; tmp += user + "" "" ; if ( name . equalsIgnoreCase ( user ) ) { test = true ; break ; } else { test = false ; } } if ( ! test ) { System . out . println ( ""Name not found"" ) ; user = validName ( input , new Scanner ( tmp ) ) ; } return user ; }"
183,"String validName ( Scanner input , Scanner histogram ) { String user = """" ; String name = input . next ( ) ; if ( histogram . findInLine ( name ) != null ) { System . out . println ( ""This name exist"" ) ; } else { System . out . println ( ""Name not found"" ) ; user = validName ( input , histogram ) ; } return user ; }"
184,"void run ( ) { synchronized ( obj1 ) { latch . countDown ( ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( ) ; } synchronized ( obj2 ) { System . out . println ( ""Thread finished"" ) ; } } }"
185,"void run ( ) { String threadName = Thread . currentThread ( ) . getName ( ) ; try { first . lock ( ) ; latch . countDown ( ) ; System . out . println ( threadName + "": locked first lock"" ) ; latch . await ( ) ; System . out . println ( threadName + "": attempting to lock second lock"" ) ; second . lock ( ) ; System . out . println ( threadName + "": never reached"" ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } }"
186,"void test_02 ( ) throws FileNotFoundException { final File file = new File ( ""43620487.txt"" ) ; final Scanner scanner = new Scanner ( file ) ; int [ ] houseLocations = new int [ 73382 ] ; for ( int counter = 0 ; counter < 73382 ; counter ++ ) { houseLocations [ counter ] = scanner . nextInt ( ) ; } final int [ ] uniqueHouseLocationsSorted = uniqueHouseLocationsSorted ( houseLocations ) ; final Random random = new Random ( 0 ) ; long sum = 0 ; for ( int i = 0 ; i < 100 ; i ++ ) { final int transmitterRange = random . nextInt ( 70000 ) + 1 ; final int minNumOfTransmitters = minNumOfTransmitters ( uniqueHouseLocationsSorted , transmitterRange ) ; sum += minNumOfTransmitters ; } final long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 4000 ; i ++ ) { final int transmitterRange = random . nextInt ( 70000 ) + 1 ; final int minNumOfTransmitters = minNumOfTransmitters ( uniqueHouseLocationsSorted , transmitterRange ) ; sum += minNumOfTransmitters ; } final long end = System . currentTimeMillis ( ) ; System . out . println ( ""Took: "" + ( end - start ) + "" milliseconds. Sum = "" + sum ) ; }"
187,"void test_02 ( ) throws FileNotFoundException { final File file = new File ( ""input.txt"" ) ; final Scanner scanner = new Scanner ( file ) ; int [ ] houseLocations = new int [ 73382 ] ; for ( int counter = 0 ; counter < 73382 ; counter ++ ) { houseLocations [ counter ] = scanner . nextInt ( ) ; } scanner . close ( ) ; final int rounds = 400 ; final int [ ] uniqueHouseLocationsSorted = uniqueHouseLocationsSorted ( houseLocations ) ; final int transmitterRange = 73381 ; final long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < rounds ; i ++ ) { final int minNumOfTransmitters = minNumOfTransmitters ( uniqueHouseLocationsSorted , transmitterRange ) ; } final long end = System . currentTimeMillis ( ) ; System . out . println ( ""Took: "" + ( end - start ) + "" milliseconds.."" ) ; }"
188,"void main ( String [ ] args ) { int [ ] arr = new int [ 10 ] ; arr [ 0 ] = 2 ; for ( int i = 1 ; i < arr . length ; i ++ ) arr [ i ] = arr [ i - 1 ] + 2 ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + "" "" ) ; System . out . println ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ 9 - i ] + "" "" ) ; }"
189,"void main ( String [ ] args ) throws Exception { int [ ] values = new int [ 10 ] ; values [ 0 ] = 2 ; System . out . print ( values [ 0 ] ) ; for ( int i = 1 ; i < values . length ; i ++ ) { values [ i ] = values [ i - 1 ] + 2 ; System . out . print ( "" "" + values [ i ] ) ; } }"
190,"void main ( String ... args ) { log ( ""App started"" ) ; byte [ ] bytes = new byte [ 1024 * 1024 ] ; new Random ( ) . nextBytes ( bytes ) ; log ( ""Stream is ready\n"" ) ; try { test ( bytes ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
191,"void main ( String [ ] args ) { InputStream is = StringFromFileFast . class . getResourceAsStream ( ""file.txt"" ) ; InputStreamReader input = new InputStreamReader ( is ) ; final int CHARS_PER_PAGE = 5000 ; final char [ ] buffer = new char [ CHARS_PER_PAGE ] ; StringBuilder output = new StringBuilder ( CHARS_PER_PAGE ) ; try { for ( int read = input . read ( buffer , 0 , buffer . length ) ; read != - 1 ; read = input . read ( buffer , 0 , buffer . length ) ) { output . append ( buffer , 0 , read ) ; } } catch ( IOException ignore ) { } String text = output . toString ( ) ; System . out . println ( text ) ; }"
192,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
193,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
194,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Time (s)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; drawRotate ( gg , getWidth ( ) , ( getHeight ( ) + width ) / 2 , 270 , string ) ; }"
195,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
196,"String join ( String a , String b , String separator ) { if ( ! isEmpty ( a ) && ! isEmpty ( b ) ) { return a + separator + b ; } if ( ! isEmpty ( a ) ) { return a ; } if ( ! isEmpty ( b ) ) { return b ; } return """" ; }"
197,"String join ( String delimiter , String ... parts ) { StringBuilder builder = new StringBuilder ( ) ; for ( String part : parts ) { if ( ! isEmpty ( part ) ) { if ( builder . length ( ) > 0 ) { builder . append ( delimiter ) ; } builder . append ( part ) ; } } return builder . toString ( ) ; }"
198,"boolean handleMessage ( SOAPMessageContext context ) { Boolean isRequest = ( Boolean ) context . get ( MessageContext . MESSAGE_OUTBOUND_PROPERTY ) ; if ( isRequest ) { System . out . println ( ""is Request"" ) ; } else { System . out . println ( ""is Response"" ) ; } SOAPMessage message = context . getMessage ( ) ; try { SOAPEnvelope envelope = message . getSOAPPart ( ) . getEnvelope ( ) ; SOAPHeader header = envelope . getHeader ( ) ; message . writeTo ( System . out ) ; } catch ( SOAPException | IOException e ) { e . printStackTrace ( ) ; } return true ; }"
199,"boolean handleMessage ( SOAPMessageContext context ) { SOAPMessage msg = context . getMessage ( ) ; try { msg . writeTo ( System . out ) ; } catch ( Exception ex ) { Logger . getLogger ( LogMessageHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return true ; }"
200,"boolean hasLoop ( Node first ) { if ( first == null ) return false ; Node slow , fast ; slow = fast = first ; while ( true ) { slow = slow . next ; if ( fast . next == null ) fast = null ; else fast = fast . next . next ; if ( fast == null ) return false ; if ( slow == fast ) return true ; } }"
201,"boolean hasLoop ( Node root ) { if ( root == null ) return false ; Node slow = root , fast = root ; int taken = 0 , limit = 2 ; while ( fast . next != null ) { fast = fast . next ; taken ++ ; if ( slow == fast ) return true ; if ( taken == limit ) { taken = 0 ; limit <<= 1 ; slow = fast ; } } return false ; }"
202,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
203,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
204,"void main ( String args [ ] ) { inp = new Scanner ( System . in ) ; String str = inp . nextLine ( ) ; List < Character > arrlist = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arrlist . add ( str . charAt ( i ) ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int freq = Collections . frequency ( arrlist , str . charAt ( i ) ) ; System . out . println ( ""Frequency of "" + str . charAt ( i ) + ""  is:   "" + freq ) ; } }"
205,"void main ( String [ ] args ) { String string = ""aaabbbbbaccc"" ; int counter ; String result = """" ; int i = 0 ; while ( i < string . length ( ) ) { counter = 1 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { System . out . println ( ""string length ="" + string . length ( ) ) ; if ( string . charAt ( i ) == string . charAt ( j ) ) { counter ++ ; } } result = result + string . charAt ( i ) + counter ; string = string . replaceAll ( String . valueOf ( string . charAt ( i ) ) , """" ) ; } System . out . println ( ""result is = "" + result ) ; }"
206,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
207,"HSSFFont transform ( HSSFWorkbook workbookNew , XSSFFont fontOld ) { HSSFFont fontNew = workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }"
208,"long pow ( long a , int b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; if ( isEven ( b ) ) return pow ( a * a , b / 2 ) ; else return a * pow ( a * a , b / 2 ) ; }"
209,"int pow ( int x , int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return x ; if ( n < 0 ) { if ( x == 1 || ( x == 2 && n == - 1 ) ) return 1 ; else return 0 ; } if ( ( n & 1 ) == 0 ) { long num = pow ( x * x , n / 2 ) ; if ( num > Integer . MAX_VALUE ) return Integer . MAX_VALUE ; return ( int ) num ; } else { long num = x * pow ( x * x , n / 2 ) ; if ( num > Integer . MAX_VALUE ) return Integer . MAX_VALUE ; return ( int ) num ; } }"
210,"void main ( String ... aArgs ) { log ( ""Generating random integers in the range 1..10."" ) ; int START = 1 ; int END = 10 ; Random random = new Random ( ) ; for ( int idx = 1 ; idx <= 10 ; ++ idx ) { showRandomInteger ( START , END , random ) ; } log ( ""Done."" ) ; }"
211,"void main ( String [ ] args ) { int first , second ; Scanner myScanner = new Scanner ( System . in ) ; System . out . println ( ""Enter first integer: "" ) ; int numOne ; numOne = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numOne ) ; System . out . println ( ""Enter second integer: "" ) ; int numTwo ; numTwo = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numTwo ) ; Random generator = new Random ( ) ; int num = ( int ) ( Math . random ( ) * numTwo ) ; System . out . println ( ""Random number: "" + ( ( num > numOne ) ? num : numOne + num ) ) ; }"
212,"void main ( String ... args ) { long start = System . nanoTime ( ) ; int letters = 26 ; int count = 6 ; final int combinations = ( int ) Math . pow ( letters , count ) ; char [ ] chars = new char [ count ] ; Arrays . fill ( chars , 'a' ) ; final int last = count - 1 ; OUTER : while ( true ) { for ( chars [ last ] = 'a' ; chars [ last ] <= 'z' ; chars [ last ] += 2 ) { newComination ( chars ) ; chars [ last ] ++ ; newComination ( chars ) ; } UPDATED : { for ( int i = last - 1 ; i >= 0 ; i -- ) { if ( chars [ i ] ++ >= 'z' ) chars [ i ] = 'a' ; else break UPDATED ; } break OUTER ; } } long time = System . nanoTime ( ) - start ; System . out . printf ( ""Took %.3f seconds to generate %,d combinations%n"" , time / 1e9 , combinations ) ; }"
213,"void main ( String [ ] args ) { List < Character > characters = new ArrayList < Character > ( ) ; for ( char c = 'a' ; c <= 'z' ; c ++ ) { characters . add ( c ) ; } List < String > allStrings = new ArrayList < String > ( ) ; for ( Character c : characters ) { for ( Character d : characters ) { for ( Character e : characters ) { for ( Character f : characters ) { String s = """" + c + d + e + f ; allStrings . add ( s ) ; } } } } System . out . println ( allStrings . size ( ) ) ; }"
214,"void decimalToHex ( int decimal ) { int maxDigit = 1 ; while ( maxDigit * 16 <= decimal && maxDigit > 0 ) { maxDigit *= 16 ; } if ( maxDigit <= 0 ) { throw new IllegalArgumentException ( ""Can not convert "" + decimal ) ; } for ( int digit = maxDigit ; digit > 0 ; digit /= 16 ) { printHex ( ( decimal / digit ) % 16 ) ; } }"
215,"void decimalToHex ( int decimal ) { if ( decimal >= 256 ) { returnHex ( decimal / 256 ) ; decimal %= 256 ; } else { System . out . print ( ""0"" ) ; } if ( decimal >= 16 ) { returnHex ( decimal / 16 ) ; decimal %= 16 ; } else { System . out . print ( ""0"" ) ; } returnHex ( decimal ) ; decimal /= 16 ; }"
216,"void main ( String [ ] args ) { String name = ""AnuvratAnuvra"" ; char [ ] arr = name . toCharArray ( ) ; HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char val : arr ) { map . put ( val , map . containsKey ( val ) ? map . get ( val ) + 1 : 1 ) ; } for ( Entry < Character , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { Character key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; System . out . println ( key + "":"" + value ) ; } } }"
217,"void main ( String [ ] args ) { String test = ""The quick brown fox jumped over the lazy dog."" ; int countA = 0 , countO = 0 , countSpace = 0 , countDot = 0 ; for ( int i = 0 ; i < test . length ( ) ; i ++ ) { switch ( test . charAt ( i ) ) { case 'a' : case 'A' : countA ++ ; break ; case 'o' : case 'O' : countO ++ ; break ; case ' ' : countSpace ++ ; break ; case '.' : countDot ++ ; break ; } } System . out . printf ( ""%s%d%n%s%d%n%s%d%n%s%d"" , ""A: "" , countA , ""O: "" , countO , ""Space: "" , countSpace , ""Dot: "" , countDot ) ; }"
218,"void main ( String [ ] args ) { int n = 7 ; int mid = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < Math . abs ( mid - i ) + 1 ; j ++ ) { System . out . print ( ""*"" ) ; } System . out . println ( ) ; } }"
219,"void main ( String [ ] args ) { for ( int row = 1 ; row <= 7 ; row += 2 ) { for ( int space = 7 ; space >= row ; space -= 2 ) { System . out . print ( ""*"" ) ; } for ( int i = 1 ; i <= row ; i ++ ) { System . out . print ( "" "" ) ; } System . out . print ( ""\n"" ) ; } for ( int row = 5 ; row >= 1 ; row -= 2 ) { for ( int space = 7 ; space >= row ; space -= 2 ) { System . out . print ( ""*"" ) ; } for ( int i = 1 ; i <= row ; i ++ ) { System . out . print ( "" "" ) ; } System . out . print ( ""\n"" ) ; } }"
220,"void main ( String [ ] args ) { HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; System . out . println ( ""Enter an String:"" ) ; Scanner sc = new Scanner ( System . in ) ; String s1 = sc . nextLine ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! hm . containsKey ( s1 . charAt ( i ) ) ) { hm . put ( s1 . charAt ( i ) , ( Integer ) 1 ) ; } else { hm . put ( s1 . charAt ( i ) , hm . get ( s1 . charAt ( i ) ) + 1 ) ; } } System . out . println ( ""The Charecters are:"" + hm ) ; }"
221,"void main ( String ... a ) { System . out . print ( ""Enter the String"" ) ; Scanner sc = new Scanner ( System . in ) ; String st = sc . nextLine ( ) ; int [ ] ar = new int [ 256 ] ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { ar [ st . charAt ( i ) ] = ar [ st . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { char ch = ( char ) i ; if ( ar [ i ] > 0 ) { if ( ar [ i ] == 1 ) { System . out . print ( ch ) ; } else { System . out . print ( ch + """" + ar [ i ] ) ; } } } }"
222,void mirroeView ( ) { BSTNode node = mirroeView ( root ) ; preorder ( node ) ; System . out . println ( ) ; inorder ( node ) ; System . out . println ( ) ; postorder ( node ) ; System . out . println ( ) ; }
223,BSTNode mirroeView ( BSTNode node ) { if ( node == null || ( node . left == null && node . rigth == null ) ) return node ; BSTNode temp = node . left ; node . left = node . rigth ; node . rigth = temp ; mirroeView ( node . left ) ; mirroeView ( node . rigth ) ; return node ; }
224,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
225,"void transform ( ) { String call = ""transform "" ; System . out . println ( call + ""Workbook"" ) ; XSSFSheet sheetNew ; HSSFSheet sheetOld ; this . workbookNew . setForceFormulaRecalculation ( this . workbookOld . getForceFormulaRecalculation ( ) ) ; this . workbookNew . setMissingCellPolicy ( this . workbookOld . getMissingCellPolicy ( ) ) ; for ( int i = 0 ; i < this . workbookOld . getNumberOfSheets ( ) ; i ++ ) { sheetOld = this . workbookOld . getSheetAt ( i ) ; sheetNew = this . workbookNew . getSheet ( sheetOld . getSheetName ( ) ) ; System . out . println ( call + ""Sheet erstellt: "" + sheetOld . getSheetName ( ) ) ; sheetNew = this . workbookNew . createSheet ( sheetOld . getSheetName ( ) ) ; this . transform ( sheetOld , sheetNew ) ; } System . out . println ( call + ""Anzahl verwendeter Styles: "" + this . styleMap . size ( ) ) ; System . out . println ( call + ""abgeschlossen"" ) ; }"
226,"int pow ( int a , int p ) { int res = 1 ; int i1 = 31 - Integer . numberOfLeadingZeros ( p ) ; for ( int i = i1 ; i >= 0 ; -- i ) { res *= res ; if ( ( p & ( 1 << i ) ) > 0 ) res *= a ; } return res ; }"
227,"int pow ( int x , int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return x ; if ( n < 0 ) { if ( x == 1 || ( x == 2 && n == - 1 ) ) return 1 ; else return 0 ; } if ( ( n & 1 ) == 0 ) { long num = pow ( x * x , n / 2 ) ; if ( num > Integer . MAX_VALUE ) return Integer . MAX_VALUE ; return ( int ) num ; } else { long num = x * pow ( x * x , n / 2 ) ; if ( num > Integer . MAX_VALUE ) return Integer . MAX_VALUE ; return ( int ) num ; } }"
228,"void main ( String ... aArgs ) { log ( ""Generating random integers in the range 1..10."" ) ; int START = 1 ; int END = 10 ; Random random = new Random ( ) ; for ( int idx = 1 ; idx <= 10 ; ++ idx ) { showRandomInteger ( START , END , random ) ; } log ( ""Done."" ) ; }"
229,"void main ( String [ ] args ) { int a = 100 ; int b = 1000 ; int lowest = b ; int highest = a ; int count = 100000 ; Random random = new Random ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int nextNumber = ( int ) ( ( Math . abs ( random . nextDouble ( ) ) * ( b - a ) ) ) + a ; if ( nextNumber < a || nextNumber > b ) { System . err . println ( ""number not in range :"" + nextNumber ) ; } else { System . out . println ( nextNumber ) ; } if ( nextNumber < lowest ) { lowest = nextNumber ; } if ( nextNumber > highest ) { highest = nextNumber ; } } System . out . println ( ""Produced "" + count + "" numbers from "" + lowest + "" to "" + highest ) ; }"
230,int countLines ( String str ) { if ( str == null || str . length ( ) == 0 ) return 0 ; int lines = 1 ; int len = str . length ( ) ; for ( int pos = 0 ; pos < len ; pos ++ ) { char c = str . charAt ( pos ) ; if ( c == '\r' ) { lines ++ ; if ( pos + 1 < len && str . charAt ( pos + 1 ) == '\n' ) pos ++ ; } else if ( c == '\n' ) { lines ++ ; } } return lines ; }
231,"int countLines ( String str ) { if ( str == null || str . isEmpty ( ) ) { return 0 ; } int lines = 1 ; int pos = 0 ; while ( ( pos = str . indexOf ( ""\n"" , pos ) + 1 ) != 0 ) { lines ++ ; } return lines ; }"
232,"boolean hasLoop ( Node first ) { if ( first == null ) return false ; Node slow , fast ; slow = fast = first ; while ( true ) { slow = slow . next ; if ( fast . next != null ) fast = fast . next . next ; else return false ; if ( slow == null || fast == null ) return false ; if ( slow == fast ) return true ; } }"
233,"boolean hasLoop ( Node root ) { if ( root == null ) return false ; Node slow = root , fast = root ; int taken = 0 , limit = 2 ; while ( fast . next != null ) { fast = fast . next ; taken ++ ; if ( slow == fast ) return true ; if ( taken == limit ) { taken = 0 ; limit <<= 1 ; slow = fast ; } } return false ; }"
234,"void run ( ) { try { for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( Integer . valueOf ( 10 ) ) ) { try { writeLatch . countDown ( ) ; readLatch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
235,"void run ( ) { for ( int i = 0 ; ; i ++ ) { if ( i % 1000 == 0 ) { System . out . printf ( ""get: %d\n"" , i ) ; } Map < K , String > m2 = new HashMap < > ( map ) ; } }"
236,"long factorial ( int n ) { try { System . out . println ( ""factorial("" + n + "")"" ) ; if ( n == 1 ) { System . out . println ( ""return 1"" ) ; return 1 ; } return n * factorial ( n - 1 ) ; } finally { System . out . println ( ""return "" + n ) ; } }"
237,"long factorial ( int n , int depth ) { String spaces = repeat ( ' ' , depth ) ; System . out . print ( spaces ) ; System . out . println ( ""factorial("" + n + "")"" ) ; if ( n <= 1 ) { System . out . println ( spaces + "" return 1"" ) ; return 1 ; } long fac = factorial ( n - 1 , depth + 1 ) ; System . out . print ( spaces ) ; System . out . printf ( ""return %d * %d = %d%n"" , n , fac , n * fac ) ; return n * fac ; }"
238,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
239,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
240,"void main ( String [ ] args ) { String str = ""AAABBBBCC"" ; int length = str . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int count = 1 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == length - 1 ) { sb . append ( str . charAt ( i ) + """" + count ) ; break ; } if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { count ++ ; } else { sb . append ( str . charAt ( i ) + """" + count ) ; count = 1 ; } } System . out . println ( sb . toString ( ) ) ; }"
241,"void main ( String [ ] args ) { String output = """" ; Multiset < String > wordsMultiset = HashMultiset . create ( ) ; String [ ] words = ""AAABBBBCC"" . split ( """" ) ; wordsMultiset . addAll ( Arrays . asList ( words ) ) ; for ( Entry < String > string : wordsMultiset . entrySet ( ) ) { if ( ! string . getElement ( ) . isEmpty ( ) ) output += string . getCount ( ) + """" + string . getElement ( ) ; } System . out . println ( output ) ; }"
242,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Distance (m)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; gg . drawString ( string , ( getWidth ( ) - width ) / 2 , 11 ) ; }"
243,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
244,"void start ( Stage primaryStage ) { try { StackPane root = new StackPane ( ) ; Text text2 = new Text ( ""I will be aligned TOPLEFT"" ) ; Text text = new Text ( "" Level 2 \n\n"" + ""Press ENTER to start a new game"" ) ; text . setTextAlignment ( TextAlignment . CENTER ) ; root . getChildren ( ) . addAll ( text2 , text ) ; StackPane . setAlignment ( text2 , Pos . TOP_LEFT ) ; StackPane . setAlignment ( text , Pos . CENTER ) ; Scene scene = new Scene ( root , 400 , 400 ) ; primaryStage . setScene ( scene ) ; primaryStage . show ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
245,"void start ( Stage primaryStage ) { Text waitingForKey = new Text ( ""Level 2 \n\n"" + ""Press ENTER to start a new game"" ) ; waitingForKey . setTextAlignment ( TextAlignment . CENTER ) ; waitingForKey . setFont ( new Font ( 18 ) ) ; waitingForKey . setFill ( Color . ALICEBLUE ) ; StackPane root = new StackPane ( ) ; root . getChildren ( ) . add ( waitingForKey ) ; Scene scene = new Scene ( root , 320 , 240 , Color . BLACK ) ; primaryStage . setTitle ( ""Test"" ) ; primaryStage . setScene ( scene ) ; primaryStage . show ( ) ; }"
246,"void main ( String [ ] args ) { LocalDateTime from = LocalDateTime . parse ( ""2015-07-24T09:39:14.000Z"" , ISODateTimeFormat . dateTime ( ) ) ; LocalDateTime to = LocalDateTime . parse ( ""2015-07-24T09:45:44.000Z"" , ISODateTimeFormat . dateTime ( ) ) ; LocalTime fromTime = from . toLocalTime ( ) ; LocalTime toTime = to . toLocalTime ( ) ; System . out . println ( fromTime + "" - "" + toTime ) ; System . out . println ( fromTime + "" before "" + toTime + "" = "" + fromTime . isBefore ( toTime ) ) ; System . out . println ( fromTime + "" after "" + toTime + "" = "" + fromTime . isAfter ( toTime ) ) ; System . out . println ( fromTime + "" equals "" + toTime + "" = "" + fromTime . equals ( toTime ) ) ; System . out . println ( fromTime + "" compareTo "" + toTime + "" = "" + fromTime . compareTo ( toTime ) ) ; }"
247,"void main ( String [ ] args ) throws ParseException { String st1 = ""2015-07-24T09:39:14.000Z"" ; String st2 = ""2015-07-24T09:45:44.000Z"" ; String time1 = st1 . substring ( st1 . indexOf ( ""T"" ) + 1 , st1 . indexOf ( "".0"" ) ) ; String time2 = st2 . substring ( st2 . indexOf ( ""T"" ) + 1 , st2 . indexOf ( "".0"" ) ) ; Date dateTime1 = new java . text . SimpleDateFormat ( ""HH:mm"" ) . parse ( time1 ) ; Date dateTime2 = new java . text . SimpleDateFormat ( ""HH:mm"" ) . parse ( time2 ) ; System . out . println ( dateTime1 . after ( dateTime2 ) ) ; }"
248,"void printSquare ( int min , int max ) { int x = max - min + 1 ; for ( int i = min ; i <= max ; i ++ ) { int counter = i ; for ( int j = 0 ; j < x ; j ++ ) { System . out . print ( counter ) ; counter = counter >= max ? min : counter + 1 ; } System . out . println ( ) ; } }"
249,"void printSquare ( int min , int max ) { for ( int i = min ; i <= max ; i ++ ) { for ( int j = i ; j <= max ; j ++ ) { System . out . print ( j ) ; } for ( int k = min ; k < i ; k ++ ) { System . out . print ( k ) ; } System . out . println ( ) ; } }"
250,"void main ( String [ ] args ) { int nth = Integer . parseInt ( args [ 0 ] ) ; Queue < String > q = new LinkedList < > ( ) ; BufferedReader bufferRead = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String s = """" ; while ( ! ""/"" . equals ( ( s = bufferRead . readLine ( ) ) ) ) { q . add ( s ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } String polled = """" ; int count = 1 ; while ( ( polled = q . poll ( ) ) != null ) { if ( count == nth ) { System . out . println ( nth + "" th string is "" + polled ) ; } count ++ ; } }"
251,void main ( String [ ] args ) { Integer n = Integer . parseInt ( args [ 0 ] ) ; Queue < Integer > q = new Queue < Integer > ( ) ; while ( ! StdIn . isEmpty ( ) ) { q . enqueue ( StdIn . readInt ( ) ) ; } while ( q . size ( ) > n ) { q . dequeue ( ) ; } StdOut . println ( q . peek ( ) . toString ( ) ) ; }
252,String inputStreamToString ( InputStream in ) throws IOException { ReadableByteChannel channel = Channels . newChannel ( in ) ; ByteBuffer byteBuffer = ByteBuffer . allocate ( 1024 * 16 ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; WritableByteChannel outChannel = Channels . newChannel ( bout ) ; while ( channel . read ( byteBuffer ) > 0 || byteBuffer . position ( ) > 0 ) { byteBuffer . flip ( ) ; outChannel . write ( byteBuffer ) ; byteBuffer . compact ( ) ; } channel . close ( ) ; outChannel . close ( ) ; return bout . toString ( UTF_8 ) ; }
253,"String inputStreamToString ( InputStream inputStream ) throws IOException { try ( ByteArrayOutputStream result = new ByteArrayOutputStream ( ) ) { byte [ ] buffer = new byte [ 1024 ] ; int length ; while ( ( length = inputStream . read ( buffer ) ) != - 1 ) { result . write ( buffer , 0 , length ) ; } return result . toString ( UTF_8 ) ; } }"
254,"ZonedDateTime parseToZonedDateTime ( String date , String dateFormat ) { DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( dateFormat ) ; TemporalAccessor parsed = formatter . parseBest ( date , ZonedDateTime :: from , LocalDateTime :: from ) ; if ( parsed instanceof ZonedDateTime ) { return ( ZonedDateTime ) parsed ; } if ( parsed instanceof LocalDateTime ) { LocalDateTime dt = ( LocalDateTime ) parsed ; return dt . atZone ( ZoneId . systemDefault ( ) ) ; } return null ; }"
255,"ZonedDateTime parseToZonedDateTime ( String date , String dateFormat ) { DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( dateFormat ) ; ZonedDateTime zonedDateTime = null ; try { zonedDateTime = ZonedDateTime . parse ( date , formatter ) ; } catch ( DateTimeException e ) { LocalDateTime localDateTime = LocalDateTime . parse ( date , formatter ) ; zonedDateTime = localDateTime . atZone ( ZoneId . systemDefault ( ) ) ; } return zonedDateTime ; }"
256,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
257,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
258,"void main ( String ... args ) { int [ ] [ ] bino = new int [ 15 ] [ ] ; for ( int i = 0 ; i < bino . length ; i ++ ) { bino [ i ] = new int [ i + 1 ] ; for ( int j = 0 ; j < i + 1 ; j ++ ) { bino [ i ] [ j ] = nOverk ( i , j ) ; } } }"
259,"void main ( String [ ] args ) { int n = 15 ; int [ ] [ ] pascal = new int [ n + 1 ] [ ] ; pascal [ 1 ] = new int [ 1 + 2 ] ; pascal [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { pascal [ i ] = new int [ i + 2 ] ; for ( int j = 1 ; j < pascal [ i ] . length - 1 ; j ++ ) pascal [ i ] [ j ] = pascal [ i - 1 ] [ j - 1 ] + pascal [ i - 1 ] [ j ] ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j < pascal [ i ] . length - 1 ; j ++ ) { System . out . print ( pascal [ i ] [ j ] + "" "" ) ; } System . out . println ( ) ; } }"
260,"String nthShortWord ( String [ ] words , int n ) { int nthShortWord = 0 ; for ( int i = 0 ; i < words . length ; i ++ ) { if ( words [ i ] . length ( ) <= 3 ) nthShortWord ++ ; if ( nthShortWord == n ) return words [ i ] ; } return """" ; }"
261,"String nthShortWord ( String [ ] words , int n ) { int nthShortWord = 0 ; String shortWord = ""notFound"" ; for ( int i = 0 ; i < words . length ; i ++ ) { if ( words [ i ] . length ( ) <= 3 ) nthShortWord ++ ; if ( nthShortWord == n ) { shortWord = nthShortWord [ i ] ; break ; } } return shortWord ; }"
262,"void run ( ) { synchronized ( obj1 ) { latch . countDown ( ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( ) ; } synchronized ( obj2 ) { System . out . println ( ""Thread finished"" ) ; } } }"
263,"void run ( ) { System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" starting"" ) ; synchronized ( BadRunnable . class ) { System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" acquired the monitor on BadRunnable.class"" ) ; latch . countDown ( ) ; while ( true ) { try { latch . await ( ) ; } catch ( InterruptedException ex ) { continue ; } break ; } } System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" released the monitor on BadRunnable.class"" ) ; System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" ending"" ) ; }"
264,"void paintComponent ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; RenderingHints rh = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; rh . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; g2d . setRenderingHints ( rh ) ; double w = getWidth ( ) ; double m = w / 12 ; double dx = w / 7 ; double dy = w / 8 ; double x = m ; double y = .7 * m ; double r = w / 4 ; int fwdStart = - 30 ; int topStart = 90 - 30 ; float rw = ( float ) w / 40 ; BasicStroke bs = new BasicStroke ( rw * 1.5f ) ; BasicStroke fs = new BasicStroke ( rw ) ; Color blue = new Color ( 0 , 133 , 199 ) ; Color gold = new Color ( 244 , 195 , 0 ) ; Color black = Color . black ; Color green = new Color ( 0 , 159 , 61 ) ; Color red = new Color ( 223 , 0 , 36 ) ; paintRing ( g2d , fs , bs , x , y , r , rw , blue , 0 , 360 ) ; paintRing ( g2d , fs , bs , x + dx , y + dy , r , rw , gold , 0 , 360 ) ; paintRing ( g2d , fs , bs , x + 2 * dx , y , r , rw , black , 0 , 360 ) ; paintRing ( g2d , fs , bs , x + dx , y + dy , r , rw , gold , topStart , 60 ) ; paintRing ( g2d , fs , bs , x , y , r , rw , blue , fwdStart , 60 ) ; paintRing ( g2d , fs , bs , x + 3 * dx , y + dy , r , rw , green , 0 , 360 ) ; paintRing ( g2d , fs , bs , x + 4 * dx , y , r , rw , red , 0 , 360 ) ; paintRing ( g2d , fs , bs , x + 3 * dx , y + dy , r , rw , green , topStart , 60 ) ; paintRing ( g2d , fs , bs , x + 2 * dx , y , r , rw , black , fwdStart , 60 ) ; }"
265,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g . create ( ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; int x = X_START ; int y = Y_START ; myDrawOval ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . BLUE , OVAL_WIDTH ) ; x += DELTA_X ; y += DELTA_Y ; myDrawOval ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , COLOR_GOLD , OVAL_WIDTH ) ; x += DELTA_X ; y -= DELTA_Y ; myDrawOval ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . BLACK , OVAL_WIDTH ) ; x += DELTA_X ; y += DELTA_Y ; myDrawOval ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . GREEN . darker ( ) , OVAL_WIDTH ) ; x += DELTA_X ; y -= DELTA_Y ; myDrawOval ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . RED , OVAL_WIDTH ) ; x = X_START ; y = Y_START ; int angle = CIRCLE_DEGREES - ARC_LENGTH ; myDrawArc ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . BLUE , OVAL_WIDTH , angle , ARC_LENGTH ) ; x += DELTA_X ; y += DELTA_Y ; myDrawArc ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , COLOR_GOLD , OVAL_WIDTH , 0 , ARC_LENGTH ) ; x += DELTA_X ; y -= DELTA_Y ; myDrawArc ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . BLACK , OVAL_WIDTH , angle , ARC_LENGTH ) ; x += DELTA_X ; y += DELTA_Y ; myDrawArc ( g2 , INNER_STROKE , OUTER_STROKE , x , y , BG , Color . GREEN . darker ( ) , OVAL_WIDTH , 0 , ARC_LENGTH ) ; g2 . dispose ( ) ; }"
266,"void layoutPlotChildren ( ) { super . layoutPlotChildren ( ) ; for ( Series < String , Number > series : getData ( ) ) { for ( Data < String , Number > data : series . getData ( ) ) { StackPane bar = ( StackPane ) data . getNode ( ) ; final Text dataText = new Text ( data . getYValue ( ) + """" ) ; bar . getChildren ( ) . add ( dataText ) ; } } }"
267,"void layoutPlotChildren ( ) { super . layoutPlotChildren ( ) ; for ( Series < String , Number > series : getData ( ) ) { for ( Data < String , Number > data : series . getData ( ) ) { StackPane bar = ( StackPane ) data . getNode ( ) ; Label label = null ; for ( Node node : bar . getChildrenUnmodifiable ( ) ) { LOGGER . debug ( ""Bar has child {}, {}."" , node , node . getClass ( ) ) ; if ( node instanceof Label ) { label = ( Label ) node ; break ; } } if ( label == null ) { label = new Label ( series . getName ( ) ) ; label . setRotate ( 90.0 ) ; bar . getChildren ( ) . add ( label ) ; } else { label . setText ( series . getName ( ) ) ; } } } }"
268,"void printTable ( String [ ] countries , int [ ] populations ) { int countryLength = 0 ; long populationLength = 0 ; for ( String country : countries ) { if ( country . length ( ) > countryLength ) countryLength = country . length ( ) ; } for ( int i : populations ) { if ( String . valueOf ( i ) . length ( ) > populationLength ) populationLength = String . valueOf ( i ) . length ( ) ; } for ( int i = 0 ; i < countries . length ; i ++ ) System . out . format ( ""%-"" + ( countryLength + 1 ) + ""s|%"" + ( populationLength + 1 ) + ""d\n"" , countries [ i ] , populations [ i ] ) ; }"
269,"void printTable ( String [ ] countries , int [ ] populations ) { if ( countries . length != 0 ) { int longestNameInput = countries [ 0 ] . length ( ) ; int longestPopInput = String . valueOf ( populations [ 0 ] ) . length ( ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { int countLength = countries [ i ] . length ( ) ; int popLength = String . valueOf ( populations [ i ] ) . length ( ) ; if ( countLength > longestNameInput ) longestNameInput = countLength ; if ( popLength > longestPopInput ) longestPopInput = popLength ; } for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . print ( countries [ i ] ) ; for ( int j = 0 ; j < ( longestNameInput - countries [ i ] . length ( ) ) ; j ++ ) System . out . print ( "" "" ) ; System . out . print ( "" | "" ) ; for ( int k = 0 ; k < ( longestPopInput - String . valueOf ( populations [ i ] ) . length ( ) ) ; k ++ ) System . out . print ( "" "" ) ; System . out . println ( populations [ i ] ) ; } } }"
270,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
271,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
272,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
273,XSSFFont transform ( HSSFFont fontOld ) { XSSFFont fontNew = this . workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }
274,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
275,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
276,"void main ( String [ ] args ) { int a = 100 ; int b = 1000 ; int lowest = b ; int highest = a ; int count = 100000 ; Random random = new Random ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int nextNumber = ( int ) ( ( Math . abs ( random . nextDouble ( ) ) * ( b - a ) ) ) + a ; if ( nextNumber < a || nextNumber > b ) { System . err . println ( ""number not in range :"" + nextNumber ) ; } else { System . out . println ( nextNumber ) ; } if ( nextNumber < lowest ) { lowest = nextNumber ; } if ( nextNumber > highest ) { highest = nextNumber ; } } System . out . println ( ""Produced "" + count + "" numbers from "" + lowest + "" to "" + highest ) ; }"
277,"void main ( String [ ] args ) { int first , second ; Scanner myScanner = new Scanner ( System . in ) ; System . out . println ( ""Enter first integer: "" ) ; int numOne ; numOne = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numOne ) ; System . out . println ( ""Enter second integer: "" ) ; int numTwo ; numTwo = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numTwo ) ; Random generator = new Random ( ) ; int num = ( int ) ( Math . random ( ) * numTwo ) ; System . out . println ( ""Random number: "" + ( ( num > numOne ) ? num : numOne + num ) ) ; }"
278,"String merge ( String ... s ) { int maxLen = 0 ; for ( String str : s ) { maxLen = Math . max ( maxLen , str . length ( ) ) ; } StringBuilder b = new StringBuilder ( ) ; for ( int i = 0 ; i < maxLen ; ++ i ) { for ( String str : s ) { if ( str . length ( ) > i ) { b . append ( str . charAt ( i ) ) ; } } } return b . toString ( ) ; }"
279,String merge ( String ... strings ) { StringBuilder sb = new StringBuilder ( ) ; int adv ; boolean edited ; adv = 0 ; edited = true ; while ( edited ) { edited = false ; for ( String s : strings ) { if ( adv < s . length ( ) ) { sb . append ( s . charAt ( adv ) ) ; edited = true ; } } adv ++ ; } return sb . toString ( ) ; }
280,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String formatedSource = source . subSequence ( start , end ) . toString ( ) ; String destPrefix = dest . subSequence ( 0 , dstart ) . toString ( ) ; String destSuffix = dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; String result = destPrefix + formatedSource + destSuffix ; result = result . replace ( "","" , ""."" ) ; Matcher matcher = mPattern . matcher ( result ) ; if ( matcher . matches ( ) ) { return null ; } return """" ; }"
281,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { int dotPos = - 1 ; int len = dest . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = dest . charAt ( i ) ; if ( c == '.' || c == ',' ) { dotPos = i ; break ; } } if ( dotPos >= 0 ) { if ( source . equals ( ""."" ) || source . equals ( "","" ) ) { return """" ; } if ( dend <= dotPos ) { return null ; } if ( len - dotPos > decimalDigits ) { return """" ; } } return null ; }"
282,"void main ( String [ ] args ) { String string = ""check duplicate charcters in string"" ; string = string . toLowerCase ( ) ; char [ ] charAr = string . toCharArray ( ) ; Arrays . sort ( charAr ) ; for ( int i = 1 ; i < charAr . length ; ) { int count = recursiveMethod ( charAr , i , 1 ) ; if ( count > 1 ) { System . out . println ( ""'"" + charAr [ i ] + ""' comes "" + count + "" times"" ) ; i = i + count ; } else i ++ ; } }"
283,"void main ( String [ ] args ) { String str = ""abcdabghplhhnfl"" . toLowerCase ( ) ; Integer [ ] ar = new Integer [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = str . charAt ( i ) - 'a' ; if ( ar [ j ] == null ) { ar [ j ] = 1 ; } else { ar [ j ] += 1 ; } } for ( int i = 0 ; i < ar . length ; i ++ ) { if ( ar [ i ] != null && ar [ i ] > 1 ) { char c = ( char ) ( 97 + i ) ; System . out . println ( ""'"" + c + ""' comes "" + ar [ i ] + "" times."" ) ; } } }"
284,"void main ( String args [ ] ) { String value = ""This is testing Program testing Program"" ; String item [ ] = value . split ( "" "" ) ; HashMap < String , Integer > map = new HashMap < > ( ) ; for ( String t : item ) { if ( map . containsKey ( t ) ) { map . put ( t , map . get ( t ) + 1 ) ; } else { map . put ( t , 1 ) ; } } Set < String > keys = map . keySet ( ) ; for ( String key : keys ) { System . out . println ( key ) ; System . out . println ( map . get ( key ) ) ; } }"
285,"void main ( String [ ] args ) { Map < String , Integer > unique = new LinkedHashMap < String , Integer > ( ) ; for ( String string : ""House, House, House, Dog, Dog, Dog, Dog"" . split ( "", "" ) ) { if ( unique . get ( string ) == null ) unique . put ( string , 1 ) ; else unique . put ( string , unique . get ( string ) + 1 ) ; } String uniqueString = join ( unique . keySet ( ) , "", "" ) ; List < Integer > value = new ArrayList < Integer > ( unique . values ( ) ) ; System . out . println ( ""Output = "" + uniqueString ) ; System . out . println ( ""Values = "" + value ) ; }"
286,"void main ( String [ ] args ) { String input = ""(A,Name1,200), (A,Name1,200), (R,Name1,200), (A,Name2,900), (A,Name2,500)"" ; Pattern p = Pattern . compile ( ""\\(([A,R]?),(\\w+?),(\\d+?)\\)"" ) ; Matcher m = p . matcher ( input ) ; ArrayList < Score > scores = new ArrayList < Score > ( ) ; ArrayList < Score > topScores = new ArrayList < Score > ( ) ; while ( m . find ( ) ) { String action = m . group ( 1 ) ; String name = m . group ( 2 ) ; double scoreVal = Double . valueOf ( m . group ( 3 ) ) ; Score score = new Score ( name , scoreVal ) ; scores . add ( score ) ; if ( ""A"" . equalsIgnoreCase ( action ) ) { topScores . add ( score ) ; } else { for ( Score topScore : topScores ) { if ( topScore . equals ( score ) ) { topScores . remove ( score ) ; } } } } for ( Score finalScore : topScores ) { System . out . println ( finalScore ) ; } }"
287,"void main ( String [ ] args ) { String input = ""(A,Name1,200), (A,Name1,200), (R,Name1,200), (A,Name2,900), (A,Name2,500)"" ; String [ ] scoreSets = input . split ( ""\\),"" ) ; List < Score > scoreList = new ArrayList < Score > ( ) ; for ( String score : scoreSets ) { score = score . trim ( ) . substring ( 1 ) ; int closeBrace = score . indexOf ( ')' ) ; if ( closeBrace == score . length ( ) - 1 ) { score = score . substring ( 0 , score . length ( ) - 1 ) ; } String [ ] tokens = score . split ( "","" ) ; scoreList . add ( new Score ( tokens [ 0 ] , tokens [ 1 ] , Double . valueOf ( tokens [ 2 ] ) ) ) ; } }"
288,"void actionPerformed ( ActionEvent actionEvent ) { doc . setCharacterAttributes ( stringIndex , 1 , textpane . getStyle ( ""Red"" ) , true ) ; stringIndex ++ ; try { if ( stringIndex >= doc . getLength ( ) || doc . getText ( stringIndex , 1 ) . equals ( "" "" ) ) { index ++ ; } if ( index < times . size ( ) ) { double delay = times . get ( index ) . doubleValue ( ) ; timer . setDelay ( ( int ) ( delay / WORDS [ index ] . length ( ) ) ) ; } else { timer . stop ( ) ; System . err . println ( ""Timer stopped"" ) ; } } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } }"
289,void actionPerformed ( ActionEvent ae ) { if ( count < charsTiming . size ( ) ) { highlightNextWord ( ) ; ( ( Timer ) ae . getSource ( ) ) . setInitialDelay ( charsTiming . get ( count ) ) ; ( ( Timer ) ae . getSource ( ) ) . restart ( ) ; } else { reset ( ) ; ( ( Timer ) ae . getSource ( ) ) . stop ( ) ; } count ++ ; }
290,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
291,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
292,void add ( Distance d ) { int newFeet = this . feet + d . feet ; int newInches = this . inches + d . inches ; if ( newInches > 11 ) { newFeet ++ ; newInches = newInches - 12 ; } this . feet = newFeet ; this . inches = newInches ; }
293,int add ( Distance newDistance ) { int newDistanceFeet = newDistance . getFeet ( ) ; int newDistanceInches = newDistance . getInches ( ) ; int sumInches = newDistanceInches + this . getInches ( ) ; int sumFeet = newDistanceFeet + this . getFeet ( ) ; sumInches += ( sumInches % 12 ) ; sumFeet += ( sumInches / 12 ) ; this . setFeet ( sumFeet ) ; this . setInches ( sumInches ) ; }
294,"void merge ( int [ ] a , int [ ] b , int [ ] all ) { int i = 0 , j = 0 , k = 0 ; while ( i < a . length && j < b . length ) { if ( a [ i ] < b [ j ] ) { all [ k ] = a [ i ] ; i ++ ; } else { all [ k ] = b [ j ] ; j ++ ; } k ++ ; } while ( i < a . length ) { all [ k ++ ] = a [ i ++ ] ; } while ( j < b . length ) { all [ k ++ ] = b [ j ++ ] ; } }"
295,"void merge ( int [ ] a , int [ ] l , int [ ] r ) { int totElem = l . length + r . length ; int i , li , ri ; i = li = ri = 0 ; while ( i < totElem ) { if ( ( li < l . length ) && ( ri < r . length ) ) { if ( l [ li ] < r [ ri ] ) { a [ i ] = l [ li ] ; i ++ ; li ++ ; } else { a [ i ] = r [ ri ] ; i ++ ; ri ++ ; } } else { if ( li >= l . length ) { while ( ri < r . length ) { a [ i ] = r [ ri ] ; i ++ ; ri ++ ; } } if ( ri >= r . length ) { while ( li < l . length ) { a [ i ] = l [ li ] ; li ++ ; i ++ ; } } } } }"
296,int tortoiseMoves ( ) { int i = tGen ( ) ; if ( i >= 1 && i <= 5 ) { int fastplod = 3 ; return fastplod ; } if ( i >= 6 && i <= 8 ) { int slowplod = 1 ; return slowplod ; } if ( i >= 9 && i <= 10 ) { int slip = - 6 ; return slip ; } return someDefaultValue ; }
297,int tortoiseMoves ( ) { switch ( tGen ( ) ) { case 1 : case 2 : case 3 : case 4 : case 5 : return 3 ; case 6 : case 7 : case 8 : return 1 ; case 9 : case 10 : return - 6 ; default : return 0 ; } }
298,"void printArray ( int [ ] [ ] arr ) { System . out . println ( ""["" ) ; int rows = 3 ; int columns = 4 ; int i , j ; for ( i = 0 ; i < rows ; i ++ ) { for ( j = 0 ; j < columns ; j ++ ) { System . out . print ( arr [ i ] [ j ] + "" "" ) ; } System . out . println ( ) ; } System . out . println ( ""]"" ) ; }"
299,"void printArray ( int [ ] arr ) { System . out . print ( ""["" ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i == arr . length - 1 ) System . out . print ( arr [ i ] ) ; else System . out . print ( arr [ i ] + "", "" ) ; } System . out . println ( ""]"" ) ; }"
300,"int [ ] MaxNumber ( String [ ] arr ) { int [ ] Number_arr = new int [ 11 ] ; int count = 1 ; int j = 0 ; int k = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( arr [ i ] . equals ( arr [ i + 1 ] ) ) count ++ ; else { Number_arr [ j ] = count ; j ++ ; count = 1 ; } } Number_arr [ j ] = count ; for ( int i = 0 ; i < Number_arr . length ; i ++ ) { System . out . print ( Number_arr [ i ] + ""  "" ) ; } return Number_arr ; }"
301,int [ ] MaxNumber ( String [ ] arr ) { int [ ] Number_arr = new int [ 11 ] ; int count = 1 ; int j = 0 ; int k = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( arr [ i ] . equals ( arr [ i + 1 ] ) ) count ++ ; else { Number_arr [ j ] = count ; j ++ ; count = 1 ; } } Number_arr [ j ] = count ; return Number_arr ; }
302,"void cleanup ( JComponent c , boolean remove ) { if ( remove && indices != null ) { c . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; DefaultTableModel model = ( DefaultTableModel ) ( ( JTable ) c ) . getModel ( ) ; if ( addCount > 0 ) { for ( int i = 0 ; i < indices . length ; i ++ ) { if ( indices [ i ] >= addIndex ) { indices [ i ] += addCount ; } } } for ( int i = indices . length - 1 ; i >= 0 ; i -- ) { model . removeRow ( indices [ i ] ) ; } } indices = null ; addCount = 0 ; addIndex = - 1 ; }"
303,"void cleanup ( JComponent c , boolean remove ) { JTable source = ( JTable ) c ; if ( remove && rows != null ) { DefaultTableModel model = ( DefaultTableModel ) source . getModel ( ) ; for ( int i = rows . length - 1 ; i >= 0 ; i -- ) { model . removeRow ( rows [ i ] ) ; } } rows = null ; addCount = 0 ; addIndex = - 1 ; }"
304,"void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; System . out . println ( ""Insert The Sentence"" ) ; String [ ] sentence = in . nextLine ( ) . split ( "" "" ) ; ArrayList < String > allDigrams = new ArrayList < String > ( ) ; for ( int i = 0 ; i < sentence . length ; i ++ ) { for ( int j = 0 ; j < sentence [ i ] . length ( ) ; j ++ ) { String oneDigram = """" ; if ( j < sentence [ i ] . length ( ) - 1 ) { oneDigram += sentence [ i ] . charAt ( j ) ; oneDigram += sentence [ i ] . charAt ( j + 1 ) ; allDigrams . add ( oneDigram ) ; } } } ArrayList < Integer > frequency = new ArrayList < Integer > ( ) ; ArrayList < String > digrams = new ArrayList < String > ( ) ; int freqIndex = 0 ; while ( allDigrams . size ( ) > 0 ) { frequency . add ( freqIndex , 0 ) ; for ( int j = 0 ; j < allDigrams . size ( ) ; j ++ ) { if ( allDigrams . get ( 0 ) . equalsIgnoreCase ( allDigrams . get ( j ) ) ) { frequency . set ( freqIndex , frequency . get ( freqIndex ) + 1 ) ; } } String dig = allDigrams . get ( 0 ) ; while ( allDigrams . contains ( dig ) ) { allDigrams . remove ( dig ) ; } digrams . add ( dig ) ; freqIndex ++ ; } for ( int i = 0 ; i < frequency . size ( ) ; i ++ ) { for ( int j = 0 ; j < frequency . size ( ) - i - 1 ; j ++ ) { if ( frequency . get ( j ) < frequency . get ( j + 1 ) || ( ( frequency . get ( j ) == frequency . get ( j + 1 ) ) && ( digrams . get ( j ) . charAt ( 0 ) > digrams . get ( j + 1 ) . charAt ( 0 ) ) ) || ( ( digrams . get ( j ) . charAt ( 0 ) == digrams . get ( j + 1 ) . charAt ( 0 ) ) && ( digrams . get ( j ) . charAt ( 1 ) > digrams . get ( j + 1 ) . charAt ( 1 ) ) ) ) { int swap = frequency . get ( j ) ; String swapS = digrams . get ( j ) ; frequency . set ( j , frequency . get ( j + 1 ) ) ; frequency . set ( j + 1 , swap ) ; digrams . set ( j , digrams . get ( j + 1 ) ) ; digrams . set ( j + 1 , swapS ) ; } } } String sortedResult = """" ; for ( int i = 0 ; i < frequency . size ( ) ; i ++ ) { sortedResult += digrams . get ( i ) + "":"" + frequency . get ( i ) + "" "" ; } System . out . println ( sortedResult ) ; }"
305,"void main ( String args [ ] ) { int ci , i , j , k , l = 0 ; String str , str1 , result , subString ; char c1 , c2 , ch ; Scanner scan = new Scanner ( System . in ) ; System . out . print ( ""Enter a String : "" ) ; str = scan . nextLine ( ) ; i = str . length ( ) ; for ( c1 = 'A' ; c1 <= 'z' ; c1 ++ ) { for ( c2 = 'A' ; c2 <= 'z' ; c2 ++ ) { result = new String ( new char [ ] { c1 , c2 } ) ; k = 0 ; for ( j = 0 ; j < i - 1 ; j ++ ) { subString = str . substring ( j , j + 2 ) ; if ( result . equals ( subString ) ) { k ++ ; } } if ( k > 0 ) { System . out . println ( """" + result + "": "" + k ) ; } } } }"
306,boolean isPrime ( long n ) { if ( n < 2 ) return false ; if ( n == 2 || n == 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; long sqrtN = ( long ) Math . sqrt ( n ) + 1 ; for ( long i = 6L ; i <= sqrtN ; i += 6 ) { if ( n % ( i - 1 ) == 0 || n % ( i + 1 ) == 0 ) return false ; } return true ; }
307,boolean isPrime ( ) { int sqrt = ( int ) Math . sqrt ( ( double ) value ) ; for ( int i = 2 ; i <= sqrt ; i ++ ) { if ( value % i == 0 ) return false ; } return true ; }
308,"void actionPerformed ( ActionEvent e ) { long time = System . nanoTime ( ) ; if ( lastTime < 0 ) { lastTime = time ; timeString = ""00.00"" ; } else if ( time - lastTime > 1000 ) { long duration = time - lastTime ; double fps = 1000000000d * ( double ) frameCount / ( double ) duration ; timeString = format . format ( fps ) ; frameCount = 0 ; lastTime = time ; System . out . println ( timeString ) ; } frameCount ++ ; cards . next ( gui ) ; }"
309,void actionPerformed ( ActionEvent e ) { long start = System . currentTimeMillis ( ) ; frame . remove ( panel ) ; long end = System . currentTimeMillis ( ) ; JPanel newPanel = new JPanel ( ) ; newPanel . setBackground ( Color . BLUE ) ; frame . add ( newPanel ) ; frame . validate ( ) ; }
310,"Node reverse ( Node root ) { if ( root == null || root . next == null ) { return root ; } Node curr , prev , next ; curr = root ; prev = next = null ; while ( curr != null ) { next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; }"
311,"Node reverse ( Node previous , Node current ) { if ( previous == null ) return null ; if ( previous . equals ( head ) ) previous . setNext ( null ) ; if ( current == null ) { head = previous ; return head ; } else { Node temp = current . getNext ( ) ; current . setNext ( previous ) ; reverse ( current , temp ) ; } return null ; }"
312,"void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( ListenToModel . ADD ) ) { JLabel label = createLabel ( evt ) ; for ( Component comp : mainPanel . getComponents ( ) ) { comp . setBackground ( null ) ; } int index = ( ( IndexedPropertyChangeEvent ) evt ) . getIndex ( ) ; mainPanel . add ( label , index ) ; label . setBackground ( SELECTED_COLOR ) ; selectedIndex = index ; } else if ( evt . getPropertyName ( ) . equals ( ListenToModel . REMOVE ) ) { int index = ( ( IndexedPropertyChangeEvent ) evt ) . getIndex ( ) ; mainPanel . remove ( index ) ; for ( Component comp : mainPanel . getComponents ( ) ) { comp . setBackground ( null ) ; } selectedIndex = - 1 ; } else if ( evt . getPropertyName ( ) . equals ( ListenToModel . REMOVE_ALL ) ) { mainPanel . removeAll ( ) ; selectedIndex = - 1 ; } mainPanel . revalidate ( ) ; mainPanel . repaint ( ) ; }"
313,void propertyChange ( PropertyChangeEvent pce ) { if ( MVC_Model . PROGRESS . equals ( pce . getPropertyName ( ) ) ) { view . setProgress ( ( Integer ) pce . getNewValue ( ) ) ; } if ( MVC_Model . PROGRESS1 . equals ( pce . getPropertyName ( ) ) ) { view . setProgressLabel ( ( String ) pce . getNewValue ( ) ) ; } if ( MVC_Model . PROGRESS2 . equals ( pce . getPropertyName ( ) ) ) { view . setIconLabel ( ( Icon ) pce . getNewValue ( ) ) ; } }
314,"void printTree ( OutputStreamWriter out ) throws IOException { if ( right != null ) { right . printTree ( out , true , """" ) ; } printNodeValue ( out ) ; if ( left != null ) { left . printTree ( out , false , """" ) ; } }"
315,"void printTree ( OutputStreamWriter out , boolean isRight , String indent ) throws IOException { if ( right != null ) { right . printTree ( out , true , indent + ( isRight ? ""        "" : "" |      "" ) ) ; } out . write ( indent ) ; if ( isRight ) { out . write ( "" /"" ) ; } else { out . write ( "" \\"" ) ; } out . write ( ""----- "" ) ; printNodeValue ( out ) ; if ( left != null ) { left . printTree ( out , false , indent + ( isRight ? "" |      "" : ""        "" ) ) ; } }"
316,"void start ( Stage primaryStage ) throws Exception { Alert alert = new Alert ( Alert . AlertType . CONFIRMATION ) ; alert . setTitle ( ""Title"" ) ; alert . setHeaderText ( ""Some Text"" ) ; alert . setContentText ( ""Choose your option."" ) ; ButtonType buttonTypeOne = new ButtonType ( ""Yes"" ) ; ButtonType buttonTypeCancel = new ButtonType ( ""No"" , ButtonBar . ButtonData . CANCEL_CLOSE ) ; alert . getButtonTypes ( ) . setAll ( buttonTypeOne , buttonTypeCancel ) ; Thread thread = new Thread ( ( ) -> { try { Thread . sleep ( 5000 ) ; if ( alert . isShowing ( ) ) { Platform . runLater ( ( ) -> alert . close ( ) ) ; } } catch ( Exception exp ) { exp . printStackTrace ( ) ; } } ) ; thread . setDaemon ( true ) ; thread . start ( ) ; Optional < ButtonType > result = alert . showAndWait ( ) ; }"
317,"void start ( final Stage primaryStage ) { Alert alert = new Alert ( Alert . AlertType . CONFIRMATION ) ; alert . setTitle ( ""Title"" ) ; alert . setHeaderText ( ""Some Text"" ) ; alert . setContentText ( ""Choose your option."" ) ; ButtonType buttonTypeOne = new ButtonType ( ""Yes"" ) ; alert . initModality ( Modality . NONE ) ; ButtonType buttonTypeCancel = new ButtonType ( ""No"" , ButtonBar . ButtonData . CANCEL_CLOSE ) ; alert . getButtonTypes ( ) . setAll ( buttonTypeOne , buttonTypeCancel ) ; Button b = new Button ( ""close alert"" ) ; b . setOnAction ( ( ActionEvent event ) -> { for ( ButtonType bt : alert . getDialogPane ( ) . getButtonTypes ( ) ) { System . out . println ( ""bt = "" + bt ) ; if ( bt . getButtonData ( ) == ButtonBar . ButtonData . CANCEL_CLOSE ) { Button cancelButton = ( Button ) alert . getDialogPane ( ) . lookupButton ( bt ) ; cancelButton . fire ( ) ; break ; } } } ) ; final Scene scene = new Scene ( new Group ( b ) , 400 , 300 ) ; primaryStage . setScene ( scene ) ; primaryStage . show ( ) ; Optional < ButtonType > result = alert . showAndWait ( ) ; if ( result . get ( ) == buttonTypeOne ) { System . out . println ( ""one "" ) ; } else if ( result . get ( ) == buttonTypeCancel ) { System . out . println ( ""cancel "" ) ; } }"
318,int read ( ) throws IOException { if ( currentPos < currentLineEnd ) { in . seek ( currentPos ++ ) ; int readByte = in . readByte ( ) ; return readByte ; } else if ( currentPos < 0 ) { return - 1 ; } else { findPrevLine ( ) ; return read ( ) ; } }
319,int read ( ) throws IOException { if ( currentFilePos <= 0 && currentBufferPos < 0 && currentLineReadPos < 0 ) { return - 1 ; } if ( ! lineBuffered ) { fillLineBuffer ( ) ; } if ( lineBuffered ) { if ( currentLineReadPos == 0 ) { lineBuffered = false ; } return currentLine [ currentLineReadPos -- ] ; } return 0 ; }
320,"void run ( ) { synchronized ( list ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( list . size ( ) >= 1 ) { try { System . out . println ( ""producer is waiting "" ) ; list . wait ( ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } System . out . println ( ""produce="" + i ) ; list . add ( i ) ; list . notifyAll ( ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } } }"
321,"void run ( ) { synchronized ( list ) { for ( int i = 0 ; i < 10 ; i ++ ) { while ( list . isEmpty ( ) ) { System . out . println ( ""Consumer is waiting"" ) ; try { list . wait ( ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } int k = list . remove ( 0 ) ; System . out . println ( ""consume="" + k ) ; list . notifyAll ( ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { ex . printStackTrace ( ) ; } } } }"
322,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
323,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
324,"void main ( String [ ] args ) { final String str1 = ""HELLO WORLD"" ; System . out . println ( capitalizeFirstLetter ( str1 ) ) ; final String str2 = ""Hello WORLD"" ; System . out . println ( capitalizeFirstLetter ( str2 ) ) ; final String str3 = ""hello world"" ; System . out . println ( capitalizeFirstLetter ( str3 ) ) ; final String str4 = ""heLLo wORld"" ; System . out . println ( capitalizeFirstLetter ( str4 ) ) ; }"
325,"void main ( String [ ] args ) { String str = ""my name is khan"" ; String words [ ] = str . split ( ""\\s"" ) ; String capitalizedWord = """" ; for ( String w : words ) { String first = w . substring ( 0 , 1 ) ; String f_after = w . substring ( 1 ) ; capitalizedWord += first . toUpperCase ( ) + f_after + "" "" ; } System . out . println ( capitalizedWord ) ; }"
326,void type ( char character ) { handleSpecialCharacter ( character ) ; if ( Character . isLowerCase ( character ) ) { typeCharacter ( Character . toUpperCase ( character ) ) ; } if ( Character . isUpperCase ( character ) ) { typeShiftCharacter ( character ) ; } if ( Character . isDigit ( character ) ) { typeCharacter ( character ) ; } }
327,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_SHIFT , VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_SHIFT , VK_AT ) ; break ; case '#' : doType ( VK_SHIFT , VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_SHIFT , VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_SHIFT , VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_SHIFT , VK_AMPERSAND ) ; break ; case '*' : doType ( VK_SHIFT , VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_SHIFT , VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_SHIFT , VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_SHIFT , VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_SHIFT , VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; case '\b' : doType ( VK_BACK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
328,"boolean deleteDirectory ( File dir ) { if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { return false ; } String [ ] files = dir . list ( ) ; for ( int i = 0 , len = files . length ; i < len ; i ++ ) { File f = new File ( dir , files [ i ] ) ; if ( f . isDirectory ( ) ) { deleteDirectory ( f ) ; } else { f . delete ( ) ; } } return dir . delete ( ) ; }"
329,boolean deleteDirectory ( File directory ) { if ( directory . exists ( ) ) { File [ ] files = directory . listFiles ( ) ; if ( null != files ) { for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . isDirectory ( ) ) { deleteDirectory ( files [ i ] ) ; } else { files [ i ] . delete ( ) ; } } } } return ( directory . delete ( ) ) ; }
330,"int binarySearch ( int anArray [ ] , int first , int last , int value ) { int index ; int done = 0 ; while ( done == 0 ) { if ( first > last ) { index = - 1 ; done = 1 ; } else { int mid = ( first + last ) / 2 ; if ( value == anArray [ mid ] ) { index = mid ; done = 1 ; } else if ( value < anArray [ mid ] ) { last = mid - 1 ; } else { first = mid + 1 ; } } } return index ; }"
331,"int binarySearch ( int anArray [ ] , int first , int last , int value ) { do { if ( first > last ) { return - 1 ; } else { int mid = ( first + last ) / 2 ; if ( value == anArray [ mid ] ) { return mid ; } else if ( value < anArray [ mid ] ) { last = mid - 1 ; } else { first = mid + 1 ; } } } while ( true ) ; }"
332,"int solution ( int N ) { int tempGap = 0 , gap = 0 ; String binaryString = Integer . toBinaryString ( N ) ; int i = 0 ; while ( i < binaryString . length ( ) ) { if ( binaryString . charAt ( i ) == '1' ) { ++ i ; tempGap = 0 ; while ( i < binaryString . length ( ) && binaryString . charAt ( i ) != '1' ) { ++ i ; tempGap ++ ; } if ( i >= binaryString . length ( ) ) { tempGap = 0 ; } } else { ++ i ; } if ( tempGap > gap ) { gap = tempGap ; } } return gap ; }"
333,"int solution ( int N ) { int gap = 0 ; String binaryStr = Integer . toBinaryString ( N ) ; String [ ] zeroArrays = binaryStr . split ( ""1"" ) ; System . out . println ( Arrays . toString ( zeroArrays ) ) ; for ( String zeroArray : zeroArrays ) { gap = zeroArray . length ( ) > gap ? zeroArray . length ( ) : gap ; } return gap ; }"
334,"void actionPerformed ( ActionEvent e ) { Container parent = getParent ( ) ; int nextX = getLocation ( ) . x + ( deltaX * directionX ) ; if ( nextX < 0 ) { nextX = 0 ; directionX *= - 1 ; } if ( nextX + getSize ( ) . width > parent . getSize ( ) . width ) { nextX = parent . getSize ( ) . width - getSize ( ) . width ; directionX *= - 1 ; } int nextY = getLocation ( ) . y + ( deltaY * directionY ) ; if ( nextY < 0 ) { nextY = 0 ; directionY *= - 1 ; } if ( nextY + getSize ( ) . height > parent . getSize ( ) . height ) { nextY = parent . getSize ( ) . height - getSize ( ) . height ; directionY *= - 1 ; } setLocation ( nextX , nextY ) ; }"
335,void actionPerformed ( ActionEvent e ) { switch ( direction ) { case UP : draw . incrementY ( false ) ; break ; case DOWN : draw . incrementY ( true ) ; break ; case LEFT : draw . incrementX ( false ) ; break ; case RIGHT : draw . incrementX ( true ) ; break ; default : break ; } }
336,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
337,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
338,"String toHexString ( byte [ ] bytes ) { char [ ] hexArray = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] hexChars = new char [ bytes . length * 2 ] ; int v ; for ( int j = 0 ; j < bytes . length ; j ++ ) { v = bytes [ j ] & 0xFF ; hexChars [ j * 2 ] = hexArray [ v / 16 ] ; hexChars [ j * 2 + 1 ] = hexArray [ v % 16 ] ; } return new String ( hexChars ) ; }"
339,String toHexString ( byte bytes [ ] ) { if ( bytes == null ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; for ( int iter = 0 ; iter < bytes . length ; iter ++ ) { byte high = ( byte ) ( ( bytes [ iter ] & 0xf0 ) > > 4 ) ; byte low = ( byte ) ( bytes [ iter ] & 0x0f ) ; sb . append ( nibble2char ( high ) ) ; sb . append ( nibble2char ( low ) ) ; } return sb . toString ( ) ; }
340,int countZeros ( int [ ] f ) { for ( int i = f . length - 1 ; i >= 0 ; i -- ) { if ( f [ i ] != 0 && i > 0 && f [ i - 1 ] == 0 ) { i -- ; int count = 0 ; while ( i >= 0 && f [ i ] == 0 ) { i -- ; count ++ ; } if ( i == 0 ) return null ; else return count ; } } return null ; }
341,"int countZeros ( int [ ] f ) { int start = 0 , end = 0 , cnt = 0 ; for ( int i = 1 ; i < f . length ; i ++ ) { if ( f [ i - 1 ] != 0 && f [ i ] == 0 ) { start = i ; } else if ( f [ i - 1 ] == 0 && f [ i ] != 0 && start > 0 ) { end = i ; cnt += end - start ; } } return cnt ; }"
342,"void main ( String [ ] args ) { VolumeControllerV4 volumeControllerV4 = new VolumeControllerV4 ( ) ; BrightnessControllerV4 brightnessControllerV4 = new BrightnessControllerV4 ( ) ; ColourControllerV4 colourControllerV4 = new ColourControllerV4 ( ) ; List < ControllerV4 > controllerV4s = new ArrayList < > ( ) ; controllerV4s . add ( brightnessControllerV4 ) ; controllerV4s . add ( volumeControllerV4 ) ; controllerV4s . add ( colourControllerV4 ) ; List < OnStart > controllersToInitialize = new ArrayList < > ( ) ; controllersToInitialize . addAll ( controllerV4s ) ; InitializeDeviceV4 initializeDeviceV4 = new InitializeDeviceV4 ( controllersToInitialize ) ; initializeDeviceV4 . initialize ( ) ; List < OnReset > controllersToReset = new ArrayList < > ( ) ; controllersToReset . addAll ( controllerV4s ) ; ResetFunctionV4 resetFunctionV4 = new ResetFunctionV4 ( controllersToReset ) ; OUTER : while ( true ) { Scanner sc = new Scanner ( System . in ) ; System . out . println ( "" Enter your option \n Press 1 to increase volume \n Press 2 to decrease volume"" ) ; System . out . println ( "" Press 3 to increase brightness \n Press 4 to decrease brightness"" ) ; System . out . println ( "" Press 5 to increase color \n Press 6 to decrease color"" ) ; System . out . println ( "" Press 7 to reset TV \n Press any other Button to shutdown"" ) ; int button = sc . nextInt ( ) ; switch ( button ) { case 1 : { volumeControllerV4 . adjust ( 5 ) ; break ; } case 2 : { volumeControllerV4 . adjust ( - 5 ) ; break ; } case 3 : { brightnessControllerV4 . adjust ( 5 ) ; break ; } case 4 : { brightnessControllerV4 . adjust ( - 5 ) ; break ; } case 5 : { colourControllerV4 . adjust ( 5 ) ; break ; } case 6 : { colourControllerV4 . adjust ( - 5 ) ; break ; } case 7 : { resetFunctionV4 . onReset ( ) ; break ; } default : System . out . println ( ""Shutting down..........."" ) ; break OUTER ; } } }"
343,void main ( String args [ ] ) { try { Game game = new Chess ( ) ; Thread t1 = new Thread ( game ) ; t1 . start ( ) ; Thread . sleep ( 1000 ) ; game . setRunGame ( false ) ; Thread . sleep ( 1000 ) ; game = new TicTacToe ( ) ; Thread t2 = new Thread ( game ) ; t2 . start ( ) ; Thread . sleep ( 1000 ) ; game . setRunGame ( false ) ; } catch ( Exception err ) { err . printStackTrace ( ) ; } }
344,"String replaceHostInUrl ( String url , String newHost ) { if ( url == null || newHost == null ) { return url ; } try { URL originalURL = new URL ( url ) ; boolean hostHasPort = newHost . indexOf ( "":"" ) != - 1 ; int newPort = originalURL . getPort ( ) ; if ( hostHasPort ) { URL hostURL = new URL ( ""http://"" + newHost ) ; newHost = hostURL . getHost ( ) ; newPort = hostURL . getPort ( ) ; } else { newPort = - 1 ; } boolean isHttps = originalURL . getProtocol ( ) . equals ( ""https"" ) ; boolean useDefaultPort = ( newPort == 443 && isHttps ) || ( newPort == 80 && ! isHttps ) ; newPort = useDefaultPort ? - 1 : newPort ; URL newURL = new URL ( originalURL . getProtocol ( ) , newHost , newPort , originalURL . getFile ( ) ) ; String result = newURL . toString ( ) ; return result ; } catch ( MalformedURLException e ) { throw new RuntimeException ( ""Couldnt replace host in url, originalUrl="" + url + "", newHost="" + newHost ) ; } }"
345,"String replaceHostInUrl ( String originalURL , String newAuthority ) throws URISyntaxException , MalformedURLException { URI uri = new URI ( originalURL ) ; uri = new URI ( uri . getScheme ( ) . toLowerCase ( Locale . US ) , newAuthority , uri . getPath ( ) , uri . getQuery ( ) , uri . getFragment ( ) ) ; int port = uri . getPort ( ) ; if ( port > 0 && port == uri . toURL ( ) . getDefaultPort ( ) ) { uri = new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , - 1 , uri . getPath ( ) , uri . getQuery ( ) , uri . getFragment ( ) ) ; } return uri . toString ( ) ; }"
346,"void main ( String [ ] args ) { outerloop : for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { if ( i * j > 6 ) { System . out . println ( ""Breaking"" ) ; break outerloop ; } System . out . println ( i + "" "" + j ) ; } } System . out . println ( ""Done"" ) ; }"
347,"void main ( String [ ] args ) { for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { for ( int k = 0 ; k < 9 ; k ++ ) { if ( condition1 ) { System . out . println ( ""Breaking from Loop K and J"" ) ; k = 9 ; j = 9 ; } if ( condition2 ) { System . out . println ( ""Breaking from Loop K, J and I"" ) ; k = 9 ; j = 9 ; i = 9 ; } } } } System . out . println ( ""End of I , J , K"" ) ; }"
348,"int [ ] solution ( String S , int [ ] P , int [ ] K ) { char [ ] sc = S . toCharArray ( ) ; int [ ] A = new int [ sc . length ] ; int [ ] G = new int [ sc . length ] ; int [ ] C = new int [ sc . length ] ; int prevA = - 1 , prevG = - 1 , prevC = - 1 ; for ( int i = 0 ; i < sc . length ; i ++ ) { if ( sc [ i ] == 'A' ) prevA = i ; else if ( sc [ i ] == 'G' ) prevG = i ; else if ( sc [ i ] == 'C' ) prevC = i ; A [ i ] = prevA ; G [ i ] = prevG ; C [ i ] = prevC ; } int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { if ( A [ K [ i ] ] >= P [ i ] && A [ K [ i ] ] <= K [ i ] ) { result [ i ] = 1 ; } else if ( C [ K [ i ] ] >= P [ i ] && C [ K [ i ] ] <= K [ i ] ) { result [ i ] = 2 ; } else if ( G [ K [ i ] ] >= P [ i ] && G [ K [ i ] ] <= K [ i ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } return result ; }"
349,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int N = S . length ( ) ; int M = P . length ; int [ ] result = new int [ M ] ; lastOccurrencesMap = new int [ 3 ] [ N ] ; int lastA = - 1 ; int lastC = - 1 ; int lastG = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { char c = S . charAt ( i ) ; if ( c == 'A' ) { lastA = i ; } else if ( c == 'C' ) { lastC = i ; } else if ( c == 'G' ) { lastG = i ; } lastOccurrencesMap [ 0 ] [ i ] = lastA ; lastOccurrencesMap [ 1 ] [ i ] = lastC ; lastOccurrencesMap [ 2 ] [ i ] = lastG ; } for ( int i = 0 ; i < M ; i ++ ) { int startIndex = P [ i ] ; int endIndex = Q [ i ] ; int minimum = 4 ; for ( int n = 0 ; n < 3 ; n ++ ) { int lastOccurence = getLastNucleotideOccurrence ( startIndex , endIndex , n ) ; if ( lastOccurence != 0 ) { minimum = n + 1 ; break ; } } result [ i ] = minimum ; } return result ; }"
350,"String startOz ( String str ) { if ( str . length ( ) >= 2 && str . substring ( 0 , 2 ) . equals ( ""oz"" ) ) { return ""oz"" ; } else if ( str . length ( ) >= 2 && str . substring ( 1 , 2 ) . equals ( ""z"" ) ) { return ""z"" ; } else if ( str . length ( ) >= 2 && str . substring ( 0 , 1 ) . equals ( ""o"" ) ) { return ""o"" ; } return """" ; }"
351,"String startOz ( String str ) { int len = str . length ( ) ; if ( len < 1 ) return new String ( """" ) ; if ( len > 1 && str . charAt ( 0 ) == 'o' && str . charAt ( 1 ) == 'z' ) return new String ( ""oz"" ) ; if ( str . charAt ( 0 ) == 'o' ) return new String ( ""o"" ) ; if ( str . charAt ( 1 ) == 'z' ) return new String ( ""z"" ) ; return new String ( """" ) ; }"
352,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
353,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
354,"int countLines ( String filename ) throws IOException { LineNumberReader reader = new LineNumberReader ( new FileReader ( filename ) ) ; int cnt = 0 ; String lineRead = """" ; while ( ( lineRead = reader . readLine ( ) ) != null ) { } cnt = reader . getLineNumber ( ) ; reader . close ( ) ; return cnt ; }"
355,int countLines ( File input ) throws IOException { try ( InputStream is = new FileInputStream ( input ) ) { int count = 1 ; for ( int aChar = 0 ; aChar != - 1 ; aChar = is . read ( ) ) count += aChar == '\n' ? 1 : 0 ; return count ; } }
356,"void processRow ( ResultSet rs ) throws SQLException { Long id = rs . getLong ( ""CUSTOMER_ID"" ) ; Customer customer = map . get ( id ) ; if ( customer == null ) { customer = new Customer ( ) ; customer . setId ( id ) ; customer . setName ( rs . getString ( ""CUSTOMER_NAME"" ) ) ; customer . setAccountNumber ( rs . getLong ( ""CUSTOMER_ACCOUNT_NO"" ) ) ; map . put ( id , customer ) ; } }"
357,"void processRow ( ResultSet rs ) throws SQLException { Long id = rs . getLong ( ""CUSTOMER_ID"" ) ; Customer customer = map . get ( id ) ; if ( customer != null ) { List ordersList = customer . getOrders ( ) ; if ( ordersList == null ) { ordersList = new ArrayList < Order > ( ) ; customer . setOrders ( ordersList ) ; } Order order = new Order ( ) ; order . setId ( rs . getLong ( ""ORDER_ID"" ) ) ; ordersList . add ( order ) ; } }"
358,int [ ] zeroFront ( int [ ] nums ) { if ( nums == null ) { return null ; } int zerosPos = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { num [ i ] = num [ zerosPos ] ; num [ zerosPos ] = 0 ; ++ zerosPos ; } } return num ; }
359,int [ ] zeroFront ( int [ ] nums ) { if ( nums == null ) { return null ; } int [ ] result = new int [ nums . length ] ; int zeroesPos = 0 ; int othersPos = result . length - 1 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { result [ zeroesPos ] = 0 ; ++ zeroesPos ; } else { result [ othersPos ] = nums [ i ] ; -- othersPos ; } } return result ; }
360,VV remove ( String key ) { synchronized ( lock ) { Item < VV > item = cache . remove ( key ) ; if ( item != null ) { return item . payload ; } else { return null ; } } }
361,K remove ( ) { if ( head == null ) return null ; K val = head . value ; if ( head . next == null ) { head = null ; tail = null ; } else { head = head . next ; head . prev = null ; } return val ; }
362,int computeHeight ( Node root ) { int levels = 0 ; for ( Node child : root . children ) { int childHeight = computeHeight ( child ) ; if ( childHeight > levels ) { levels = childHeight ; } } return levels + 1 ; }
363,"int computeHeight ( ) { int maxHeight = 0 ; int [ ] heights = new int [ parent . length ] ; for ( int vertex = 0 ; vertex < n ; vertex ++ ) { if ( heights [ vertex ] != 0 ) continue ; int height = 0 ; for ( int i = vertex ; i != - 1 ; i = parent [ i ] ) { if ( heights [ i ] != 0 ) { height += heights [ i ] ; break ; } height ++ ; } maxHeight = Math . max ( maxHeight , height ) ; for ( int i = vertex ; i != - 1 ; i = parent [ i ] ) { if ( heights [ i ] != 0 ) break ; heights [ i ] = height -- ; } } return maxHeight ; }"
364,"void mouseMoved ( MouseEvent e ) { p = e . getX ( ) ; l = e . getY ( ) ; l5 . setBounds ( p , l , 150 , 50 ) ; }"
365,"void mouseMoved ( MouseEvent e ) { int x = e . getX ( ) ; int y = e . getY ( ) ; int imgWidth = 50 ; int imgHeight = 50 ; l5 . setBounds ( x - ( imgWidth / 2 ) , y - ( imgHeight / 2 ) , imgWidth , imgHeight ) ; l5 . repaint ( ) ; }"
366,"void main ( String [ ] args ) { final int ThirtyOne = 31 ; final int Thirty = 30 ; final int FebNorm = 28 ; final int FebLeap = 29 ; int numOfSundays = 0 ; int calendar [ ] [ ] = new int [ 12 ] [ ] ; calendar [ 0 ] = new int [ ThirtyOne ] ; calendar [ 1 ] = new int [ FebLeap ] ; calendar [ 2 ] = new int [ ThirtyOne ] ; calendar [ 3 ] = new int [ Thirty ] ; calendar [ 4 ] = new int [ ThirtyOne ] ; calendar [ 5 ] = new int [ Thirty ] ; calendar [ 6 ] = new int [ ThirtyOne ] ; calendar [ 7 ] = new int [ ThirtyOne ] ; calendar [ 8 ] = new int [ Thirty ] ; calendar [ 9 ] = new int [ ThirtyOne ] ; calendar [ 10 ] = new int [ Thirty ] ; calendar [ 11 ] = new int [ ThirtyOne ] ; int dayOfWeek = 1 ; for ( int year = 1900 ; year < 2001 ; year ++ ) { for ( int month = 0 ; month < calendar . length ; month ++ ) { int dayOfMonth = 0 ; int daysInMonth ; if ( month == 1 ) { daysInMonth = isLeapYear ( year ) ? FebLeap : FebNorm ; } else { daysInMonth = calendar [ month ] . length ; } while ( dayOfWeek < 8 && dayOfMonth < daysInMonth ) { System . out . println ( ""year: "" + year + ""\tday: "" + dayOfWeek + ""\tcalendar["" + month + ""]["" + dayOfMonth + ""]: "" + calendar [ month ] [ dayOfMonth ] ) ; if ( dayOfWeek == 7 && year > 1900 ) { calendar [ month ] [ dayOfMonth ] ++ ; if ( dayOfMonth == 0 ) { numOfSundays ++ ; } } dayOfMonth ++ ; dayOfWeek ++ ; if ( dayOfWeek > 7 ) { dayOfWeek = 1 ; } } } } for ( int month = 0 ; month < calendar . length ; month ++ ) { System . out . println ( calendar [ month ] [ 0 ] ) ; } System . out . println ( numOfSundays ) ; }"
367,"void main ( String [ ] argv ) { int counter = 0 ; for ( int year = 1901 , last_year = 2000 ; year <= last_year ; year ++ ) { for ( int month = 1 , last_month = 12 ; month <= last_month ; month ++ ) { Date d = new GregorianCalendar ( year , month - 1 , 1 ) . getTime ( ) ; if ( d . getDay ( ) == 0 ) { counter ++ ; System . out . println ( String . valueOf ( counter ) + "" "" + d ) ; } } } System . out . println ( ""Total sunday in XX century: "" + counter ) ; }"
368,"void main ( String [ ] args ) throws Exception { Experius a = new Experius ( ) ; int count = 10000000 ; int v = 0 ; long tm = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < count ; ++ i ) { v = a . something ( i + v ) ; ++ v ; } tm = System . currentTimeMillis ( ) - tm ; System . out . println ( ""Time: "" + tm ) ; tm = System . currentTimeMillis ( ) ; Method method = Experius . class . getMethod ( ""something"" , Integer . TYPE ) ; for ( int i = 0 ; i < count ; ++ i ) { Object o = method . invoke ( a , i + v ) ; ++ v ; } tm = System . currentTimeMillis ( ) - tm ; System . out . println ( ""Time: "" + tm ) ; }"
369,"void main ( String [ ] args ) throws NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { Object obj = new Object ( ) ; Class < Object > objClass = Object . class ; String s ; long start = System . nanoTime ( ) ; s = obj . toString ( ) ; long directInvokeEnd = System . nanoTime ( ) ; System . out . println ( s ) ; long methodLookupStart = System . nanoTime ( ) ; java . lang . reflect . Method method = objClass . getMethod ( ""toString"" ) ; long methodLookupEnd = System . nanoTime ( ) ; s = ( String ) ( method . invoke ( obj ) ) ; long reflectInvokeEnd = System . nanoTime ( ) ; System . out . println ( s ) ; System . out . println ( directInvokeEnd - start ) ; System . out . println ( methodLookupEnd - methodLookupStart ) ; System . out . println ( reflectInvokeEnd - methodLookupEnd ) ; }"
370,"String output ( String [ ] fourLetter , String [ ] fiveLetter , String [ ] sixLetter ) { String answer = """" ; for ( int i = 0 ; i < Math . max ( Math . max ( fourLetter . length , fiveLetter . length ) , sixLetter . length ) ; i ++ ) { if ( sixLetter . length > i ) { answer += sixLetter [ i ] + "" "" ; } if ( fiveLetter . length > i ) { answer += fiveLetter [ i ] + "" "" ; } if ( fourLetter . length > i ) { answer += fourLetter [ i ] ; } answer += ""\n"" ; } return answer ; }"
371,"String output ( String [ ] fourLetter , String [ ] fiveLetter , String [ ] sixLetter ) { String answer = """" ; int count = 1 ; for ( int i = 0 ; i < Math . max ( Math . max ( fourLetter . length , fiveLetter . length ) , sixLetter . length ) ; i ++ ) { if ( sixLetter . length > i ) { answer += sixLetter [ i ] + "" "" ; } if ( fiveLetter . length > i ) { answer += fiveLetter [ i ] + "" "" ; } if ( fourLetter . length > i ) { answer += fourLetter [ i ] ; } answer += ""\n"" ; for ( int j = 0 ; j < count ; j ++ ) { answer += ""\t"" ; } count ++ ; } return answer ; }"
372,void run ( ) { if ( ! isFinished ( ) ) { realRunnable . run ( ) ; if ( ! isInfinite ( ) ) { repetitions -- ; if ( isFinished ( ) ) { synchronized ( this ) { if ( self == null ) { try { wait ( ) ; } catch ( Exception e ) { } } self . cancel ( false ) ; } } } } }
373,void run ( ) { if ( ! this . infinite ) { if ( this . repeatCounter > 0 ) { this . command . run ( ) ; this . repeatCounter -- ; } else { this . control . cancel ( false ) ; } } else { this . command . run ( ) ; } }
374,"void main ( String [ ] args ) throws IOException , UnsupportedAudioFileException , LineUnavailableException { File in = new File ( ""C:\\Users\\Sandra\\Desktop\\music\\rags.wav"" ) ; AudioInputStream audioInputStream = AudioSystem . getAudioInputStream ( in ) ; Clip play = AudioSystem . getClip ( ) ; play . open ( audioInputStream ) ; FloatControl volume = ( FloatControl ) play . getControl ( FloatControl . Type . MASTER_GAIN ) ; volume . setValue ( 1.0f ) ; play . start ( ) ; play . drain ( ) ; play . close ( ) ; }"
375,"void main ( String [ ] args ) throws InterruptedException { Clip play = null ; try { File in = new File ( ""C:\\Users\\Public\\Music\\Sample Music\\Kalimba.wav"" ) ; AudioInputStream audioInputStream = AudioSystem . getAudioInputStream ( in ) ; play = AudioSystem . getClip ( ) ; play . open ( audioInputStream ) ; FloatControl volume = ( FloatControl ) play . getControl ( FloatControl . Type . MASTER_GAIN ) ; volume . setValue ( 1.0f ) ; play . start ( ) ; play . drain ( ) ; } catch ( UnsupportedAudioFileException | IOException | LineUnavailableException ex ) { ex . printStackTrace ( ) ; } finally { try { play . close ( ) ; } catch ( Exception exp ) { } } System . out . println ( ""..."" ) ; }"
376,"V put ( K key , V value ) { readWriteLock . writeLock ( ) . lock ( ) ; V old ; try { old = super . put ( key , value ) ; } finally { readWriteLock . writeLock ( ) . unlock ( ) ; } return old ; }"
377,"void put ( K key , V val ) { while ( currentSize >= maxSize ) { freeSpace ( ) ; } if ( map . containsKey ( key ) ) { get ( key ) ; return ; } ListNode < K > ln = queue . add ( key ) ; ValueHolder < K , V > rv = new ValueHolder < K , V > ( val , ln ) ; map . put ( key , rv ) ; currentSize ++ ; }"
378,"void main ( String [ ] args ) { SendMyFiles sendMyFiles = new SendMyFiles ( ) ; if ( args . length < 1 ) { System . err . println ( ""Usage: java "" + sendMyFiles . getClass ( ) . getName ( ) + "" Properties_file File_To_FTP "" ) ; System . exit ( 1 ) ; } String propertiesFile = args [ 0 ] . trim ( ) ; String fileToFTP = args [ 1 ] . trim ( ) ; sendMyFiles . startFTP ( propertiesFile , fileToFTP ) ; }"
379,"void main ( String args [ ] ) { JSch jsch = new JSch ( ) ; Session session = null ; try { session = jsch . getSession ( ""username"" , ""127.0.0.1"" , 22 ) ; session . setConfig ( ""StrictHostKeyChecking"" , ""no"" ) ; session . setPassword ( ""password"" ) ; session . connect ( ) ; Channel channel = session . openChannel ( ""sftp"" ) ; channel . connect ( ) ; ChannelSftp sftpChannel = ( ChannelSftp ) channel ; sftpChannel . get ( ""remotefile.txt"" , ""localfile.txt"" ) ; sftpChannel . exit ( ) ; session . disconnect ( ) ; } catch ( JSchException e ) { e . printStackTrace ( ) ; } catch ( SftpException e ) { e . printStackTrace ( ) ; } }"
380,"void initData ( ) { testData = new ArrayList < EventStatus > ( ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1476950160000L , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1476952200000L , 2 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1476964800000L , 4 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1476966600000L , 3 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1476943200000L , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1476946800000L , 4 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1476954000000L , 2 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1476955800000L , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1476973800000L , 3 ) ) ; testData . add ( new EventStatus ( ""Mach-3"" , 1476959400000L , 2 ) ) ; testData . add ( new EventStatus ( ""Mach-3"" , 1476966600000L , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-3"" , 1476970200000L , 4 ) ) ; testData . add ( new EventStatus ( ""Mach-3"" , 1476972000000L , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-3"" , 1476986400000L , 2 ) ) ; }"
381,"void initData ( ) { testData = new ArrayList < EventStatus > ( ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1477468500000L , 1 , 0 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1477472100000L , 2 , 0 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1477474200000L , 5 , 0 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1477476000000L , 3 , 0 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1477479600000L , 4 , 0 ) ) ; testData . add ( new EventStatus ( ""Mach-1"" , 1477486800000L , 1 , 0 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1477465200000L , 3 , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1477472400000L , 2 , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1477474200000L , 5 , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1477476000000L , 2 , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1477479600000L , 3 , 1 ) ) ; testData . add ( new EventStatus ( ""Mach-2"" , 1477486800000L , 4 , 1 ) ) ; ArrayList < String > list = new ArrayList < > ( ) ; for ( EventStatus eventStatus : testData ) { if ( list . contains ( eventStatus . getName ( ) ) ) continue ; else list . add ( eventStatus . getName ( ) ) ; } catArray = new String [ list . size ( ) ] ; catArray = list . toArray ( catArray ) ; }"
382,"void actionPerformed ( ActionEvent ae ) { int x = Integer . parseInt ( f1 . getText ( ) ) ; int y = Integer . parseInt ( f3 . getText ( ) ) ; graph . setValues ( x , y ) ; }"
383,"void actionPerformed ( ActionEvent event ) { f = Integer . parseInt ( f1 . getText ( ) ) ; g = Integer . parseInt ( f2 . getText ( ) ) ; System . out . println ( f + ""  "" + g ) ; graph . repaint ( ) ; }"
384,"void main ( String [ ] args ) { int [ ] array = { 1 , 2 , 3 , 3 , 2 , 2 , 4 , 4 , 5 , 4 } ; int count = 0 ; int maxCount = 10 ; int [ ] results = new int [ array . length ] ; int k = 0 ; for ( int i = 0 ; i < results . length ; i ++ ) { results [ i ] = - 1 ; } for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = 0 ; j < array . length ; j ++ ) { if ( array [ j ] == array [ i ] ) { count ++ ; } } if ( count <= maxCount ) { maxCount = count ; results [ k ++ ] = array [ i ] ; } count = 0 ; } for ( int i : results ) { if ( i != - 1 ) { System . out . println ( ""Element: "" + i + "", Number of occurences: "" + maxCount ) ; } } }"
385,"void main ( String [ ] args ) { int [ ] array = { 1 , 2 , 3 , 3 , 2 , 2 , 4 , 4 , 5 , 4 } ; Map < Integer , Integer > counts = new HashMap < > ( ) ; for ( Integer i : array ) { if ( counts . get ( i ) == null ) { counts . put ( i , 1 ) ; } else { counts . put ( i , counts . get ( i ) + 1 ) ; } } List < Integer > cs = new ArrayList < Integer > ( counts . values ( ) ) ; Collections . sort ( cs ) ; int minVal = cs . get ( 0 ) ; List < Integer > minElements = new ArrayList < > ( ) ; for ( Entry < Integer , Integer > entry : counts . entrySet ( ) ) { if ( entry . getValue ( ) == minVal ) { minElements . add ( entry . getKey ( ) ) ; } } for ( Integer i : minElements ) { System . out . println ( ""Element: "" + i + "" Number of occurences: "" + minVal ) ; } }"
386,"void main ( String ... args ) { Node tree = new Node ( ) ; tree . value = ""root"" ; Node [ ] n = { new Node ( ) , new Node ( ) } ; tree . nodes = n ; tree . nodes [ 0 ] . value = ""leftish"" ; tree . nodes [ 1 ] . value = ""rightish-leafy"" ; Node [ ] nn = { new Node ( ) } ; tree . nodes [ 0 ] . nodes = nn ; tree . nodes [ 0 ] . nodes [ 0 ] . value = ""off-leftish-leaf"" ; System . out . println ( Arrays . toString ( list ( tree , args [ 0 ] ) . toArray ( ) ) ) ; }"
387,void main ( String [ ] args ) { BinaryTreeWithoutRecursion < Integer > ls = new BinaryTreeWithoutRecursion < > ( ) ; ls . insert ( 1 ) ; ls . insert ( 2 ) ; ls . insert ( 3 ) ; ls . insert ( 4 ) ; ls . insert ( 5 ) ; ls . insert ( 6 ) ; ls . insert ( 7 ) ; ls . inOrderPrint ( ) ; }
388,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { final char [ ] characterInput = S . toCharArray ( ) ; final int [ ] integerInput = new int [ characterInput . length ] ; for ( int counter = 0 ; counter < characterInput . length ; counter ++ ) { integerInput [ counter ] = characterMapping . get ( characterInput [ counter ] ) ; } int [ ] result = new int [ P . length ] ; for ( int index = 0 ; index < P . length ; index ++ ) { if ( P [ index ] == Q [ index ] ) { result [ index ] = integerInput [ P [ index ] ] ; break ; } final int [ ] subArray = Arrays . copyOfRange ( integerInput , P [ index ] , Q [ index ] + 1 ) ; final int minimumValue = minimum ( subArray ) ; result [ index ] = minimumValue ; } return result ; }"
389,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] answer = new int [ P . length ] ; char [ ] chars = S . toCharArray ( ) ; int [ ] [ ] cumulativeAnswers = new int [ 4 ] [ chars . length + 1 ] ; for ( int iii = 0 ; iii < chars . length ; iii ++ ) { if ( iii > 0 ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { cumulativeAnswers [ zzz ] [ iii + 1 ] = cumulativeAnswers [ zzz ] [ iii ] ; } } switch ( chars [ iii ] ) { case 'A' : cumulativeAnswers [ 0 ] [ iii + 1 ] ++ ; break ; case 'C' : cumulativeAnswers [ 1 ] [ iii + 1 ] ++ ; break ; case 'G' : cumulativeAnswers [ 2 ] [ iii + 1 ] ++ ; break ; case 'T' : cumulativeAnswers [ 3 ] [ iii + 1 ] ++ ; break ; } } for ( int iii = 0 ; iii < P . length ; iii ++ ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { if ( ( cumulativeAnswers [ zzz ] [ Q [ iii ] + 1 ] - cumulativeAnswers [ zzz ] [ P [ iii ] ] ) > 0 ) { answer [ iii ] = zzz + 1 ; break ; } } } return answer ; }"
390,"void main ( String [ ] args ) { System . out . println ( ""Enter name"" ) ; Scanner kb = new Scanner ( System . in ) ; String text = kb . next ( ) ; if ( null == text || text . isEmpty ( ) ) { System . out . println ( ""Text empty"" ) ; } else if ( text . charAt ( 0 ) == ( text . toUpperCase ( ) . charAt ( 0 ) ) ) { System . out . println ( ""First letter in word "" + text + "" is upper case"" ) ; } }"
391,"void main ( String [ ] args ) { String str1 = """" ; String str2 = null ; String str3 = ""Starts with upper case"" ; String str4 = ""starts with lower case"" ; System . out . println ( startWithUpperCase ( str1 ) ) ; System . out . println ( startWithUpperCase ( str2 ) ) ; System . out . println ( startWithUpperCase ( str3 ) ) ; System . out . println ( startWithUpperCase ( str4 ) ) ; }"
392,void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == select ) { activeTool = SELECTION_TOOL ; } else if ( ae . getSource ( ) == draw ) { activeTool = DRAW_TOOL ; } else if ( ae . getSource ( ) == text ) { activeTool = TEXT_TOOL ; } }
393,"void actionPerformed ( ActionEvent e ) { int x = ( int ) ( Math . random ( ) * getWidth ( ) ) ; int y = ( int ) ( Math . random ( ) * getHeight ( ) ) ; int width = ( int ) ( Math . random ( ) * ( getWidth ( ) / 4 ) ) ; int height = ( int ) ( Math . random ( ) * ( getHeight ( ) / 4 ) ) ; if ( x + width > getWidth ( ) ) { x = getWidth ( ) - width ; } if ( y + height > getHeight ( ) ) { y = getHeight ( ) - height ; } Color color = new Color ( ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) ) ; lstShapes . add ( new MyRectangle ( x , y , width , height , color ) ) ; repaint ( ) ; }"
394,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
395,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
396,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
397,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , HSSFRow rowOld , XSSFRow rowNew ) { XSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( HSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
398,"void main ( String [ ] args ) { Random rand = new Random ( ) ; List < Item > items = new ArrayList < > ( ) ; int a = 1 , b = 1 , c = 1 , d = 1 , e = 1 ; for ( int i = 0 ; i < 100 ; i ++ ) { int randomNumber = rand . nextInt ( 5 ) + 1 ; CATEGORY_TYPE categoryType = null ; int num = 0 ; switch ( randomNumber ) { case 1 : categoryType = CATEGORY_TYPE . A ; num = a ++ ; break ; case 2 : categoryType = CATEGORY_TYPE . B ; num = b ++ ; break ; case 3 : categoryType = CATEGORY_TYPE . C ; num = c ++ ; break ; case 4 : categoryType = CATEGORY_TYPE . D ; num = d ++ ; break ; case 5 : categoryType = CATEGORY_TYPE . E ; num = e ++ ; break ; } String dummyData = ""Item "" + categoryType . toString ( ) + num ; Item item = new Item ( dummyData , categoryType ) ; items . add ( item ) ; } List < Item > categoryAItemsList = new ArrayList < > ( ) ; List < Item > categoryBItemsList = new ArrayList < > ( ) ; List < Item > categoryCItemsList = new ArrayList < > ( ) ; List < Item > categoryDItemsList = new ArrayList < > ( ) ; List < Item > categoryEItemsList = new ArrayList < > ( ) ; for ( Item item : items ) { if ( item . getCategoryType ( ) == CATEGORY_TYPE . A ) categoryAItemsList . add ( item ) ; else if ( item . getCategoryType ( ) == CATEGORY_TYPE . B ) categoryBItemsList . add ( item ) ; else if ( item . getCategoryType ( ) == CATEGORY_TYPE . C ) categoryCItemsList . add ( item ) ; else if ( item . getCategoryType ( ) == CATEGORY_TYPE . D ) categoryDItemsList . add ( item ) ; else if ( item . getCategoryType ( ) == CATEGORY_TYPE . E ) categoryEItemsList . add ( item ) ; } List < Item [ ] > subsetStoringListA = new ArrayList < > ( ) ; List < Item [ ] > subsetStoringListB = new ArrayList < > ( ) ; List < Item [ ] > subsetStoringListC = new ArrayList < > ( ) ; List < Item [ ] > subsetStoringListD = new ArrayList < > ( ) ; List < Item [ ] > subsetStoringListE = new ArrayList < > ( ) ; processSubsets ( categoryAItemsList . toArray ( new Item [ 0 ] ) , 2 , subsetStoringListA ) ; processSubsets ( categoryBItemsList . toArray ( new Item [ 0 ] ) , 2 , subsetStoringListB ) ; processSubsets ( categoryCItemsList . toArray ( new Item [ 0 ] ) , 2 , subsetStoringListC ) ; processSubsets ( categoryDItemsList . toArray ( new Item [ 0 ] ) , 2 , subsetStoringListD ) ; processSubsets ( categoryEItemsList . toArray ( new Item [ 0 ] ) , 1 , subsetStoringListE ) ; System . out . println ( "" A groups number: "" + subsetStoringListA . size ( ) ) ; System . out . println ( "" B groups number: "" + subsetStoringListB . size ( ) ) ; System . out . println ( "" C groups number: "" + subsetStoringListC . size ( ) ) ; System . out . println ( "" D groups number: "" + subsetStoringListD . size ( ) ) ; System . out . println ( "" E groups number: "" + subsetStoringListE . size ( ) ) ; }"
399,"void main ( String [ ] args ) { int [ ] constraints = { 2 , 1 , 0 , 1 } ; List < boolean [ ] > items = new ArrayList < boolean [ ] > ( ) ; boolean [ ] i1 = { true , false , true , false } ; boolean [ ] i2 = { true , false , false , false } ; boolean [ ] i3 = { false , true , false , true } ; boolean [ ] i4 = { false , false , false , true } ; items . add ( i1 ) ; items . add ( i2 ) ; items . add ( i3 ) ; items . add ( i4 ) ; backtrack ( constraints , items ) ; }"
400,"void inOrder ( ) { Stack < BSTNode > myStack = new Stack < BSTNode > ( ) ; Set < BSTNode > visited = new HashSet < BSTNode > ( ) ; BSTNode current = m_root ; if ( current != null ) myStack . push ( current ) ; while ( ! myStack . isEmpty ( ) ) { current = myStack . peek ( ) ; if ( current . getLeft ( ) != null && ! visited . contains ( current . getLeft ( ) ) ) myStack . push ( current . getLeft ( ) ) ; else { System . out . print ( current . getInfo ( ) + "" "" ) ; visited . add ( current ) ; myStack . pop ( ) ; if ( current . getRight ( ) != null && ! visited . contains ( current . getRight ) ) myStack . push ( current . getRight ( ) ) ; } } }"
401,"void inOrder ( ) { if ( m_root == null ) { return ; } Stack < BSTNode > myStack = new Stack < BSTNode > ( ) ; BSTNode current = m_root ; while ( current != null ) { myStack . push ( current ) ; current = current . getLeft ( ) ; } while ( ! myStack . isEmpty ( ) ) { current = ( BSTNode ) myStack . pop ( ) ; System . out . print ( current . getInfo ( ) + "" "" ) ; if ( current . getRight ( ) != null ) { current = current . getRight ( ) ; while ( current != null ) { myStack . push ( current ) ; current = current . getLeft ( ) ; } } } }"
402,void type ( char c ) { keyPress ( VK_ALT ) ; keyPress ( VK_NUMPAD0 ) ; keyRelease ( VK_NUMPAD0 ) ; String altCode = Integer . toString ( c ) ; for ( int i = 0 ; i < altCode . length ( ) ; i ++ ) { c = ( char ) ( altCode . charAt ( i ) + '0' ) ; keyPress ( c ) ; keyRelease ( c ) ; } keyRelease ( VK_ALT ) ; }
403,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_SHIFT , VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_SHIFT , VK_AT ) ; break ; case '#' : doType ( VK_SHIFT , VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_SHIFT , VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_SHIFT , VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_SHIFT , VK_AMPERSAND ) ; break ; case '*' : doType ( VK_SHIFT , VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_SHIFT , VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_SHIFT , VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_SHIFT , VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_SHIFT , VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; case '\b' : doType ( VK_BACK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
404,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
405,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
406,"boolean check ( double x , double y , double x1 , double y1 , double x2 , double y2 ) { double dx1 = x - x1 , dx2 = x2 - x1 , dy1 = y - y1 , dy2 = y2 - y1 ; double dotp = dx1 * dx2 + dy1 * dy2 ; double theta = Math . acos ( dotp / ( Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) * Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ) ) ; theta = Math . abs ( theta ) ; if ( theta > ( Math . PI / 2 ) ) return false ; dx1 = x - x2 ; dx2 = x1 - x2 ; dy1 = y - y2 ; dy2 = y1 - y2 ; dotp = dx1 * dx2 + dy1 * dy2 ; theta = Math . acos ( dotp / ( Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) * Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ) ) ; theta = Math . abs ( theta ) ; if ( theta > ( Math . PI / 2 ) ) return false ; return true ; }"
407,"boolean check ( double x1 , double y1 , double x2 , double y2 , double x , double y ) { if ( x1 == x2 ) { return y1 < y2 ? ( y1 <= y && y <= y2 ) : ( y2 <= y && y <= y1 ) ; } double m = ( y2 - y1 ) / ( x2 - x1 ) ; double r1 = x1 + m * y1 ; double r2 = x2 + m * y2 ; double r = x + m * y ; return r1 < r2 ? ( r1 <= r && r <= r2 ) : ( r2 <= r && r <= r1 ) ; }"
408,int read ( char [ ] charBuf ) { char [ ] temp = new char [ charBuf . length ] ; int charsRead = reader . read ( temp ) ; int index = - 1 ; if ( ! ( charsRead == - 1 ) ) { for ( char c : temp ) { if ( ! blacklist . contains ( c ) ) { charBuf [ index ] = c ; index ++ ; } } } return index ; }
409,"int read ( char [ ] cbuf , int off , int len ) throws IOException { int read = super . read ( cbuf , off , len ) ; if ( read == - 1 ) { return - 1 ; } int pos = off - 1 ; for ( int readPos = off ; readPos < off + read ; readPos ++ ) { if ( read == '@' ) { continue ; } else { pos ++ ; } if ( pos < readPos ) { cbuf [ pos ] = cbuf [ readPos ] ; } } return pos - off + 1 ; }"
410,"String getDurationBreakdown ( long millis ) { String [ ] units = { "" Days "" , "" Hours "" , "" Minutes "" , "" Seconds "" } ; Long [ ] values = new Long [ units . length ] ; if ( millis < 0 ) { throw new IllegalArgumentException ( ""Duration must be greater than zero!"" ) ; } values [ 0 ] = TimeUnit . MILLISECONDS . toDays ( millis ) ; millis -= TimeUnit . DAYS . toMillis ( values [ 0 ] ) ; values [ 1 ] = TimeUnit . MILLISECONDS . toHours ( millis ) ; millis -= TimeUnit . HOURS . toMillis ( values [ 1 ] ) ; values [ 2 ] = TimeUnit . MILLISECONDS . toMinutes ( millis ) ; millis -= TimeUnit . MINUTES . toMillis ( values [ 2 ] ) ; values [ 3 ] = TimeUnit . MILLISECONDS . toSeconds ( millis ) ; StringBuilder sb = new StringBuilder ( 64 ) ; boolean startPrinting = false ; for ( int i = 0 ; i < units . length ; i ++ ) { if ( ! startPrinting && values [ i ] != 0 ) startPrinting = true ; if ( startPrinting ) { sb . append ( values [ i ] ) ; sb . append ( units [ i ] ) ; } } return ( sb . toString ( ) ) ; }"
411,"String getDurationBreakdown ( long millis ) { if ( millis < 0 ) { throw new IllegalArgumentException ( ""Duration must be greater than zero!"" ) ; } long days = TimeUnit . MILLISECONDS . toDays ( millis ) ; millis -= TimeUnit . DAYS . toMillis ( days ) ; long hours = TimeUnit . MILLISECONDS . toHours ( millis ) ; millis -= TimeUnit . HOURS . toMillis ( hours ) ; long minutes = TimeUnit . MILLISECONDS . toMinutes ( millis ) ; millis -= TimeUnit . MINUTES . toMillis ( minutes ) ; long seconds = TimeUnit . MILLISECONDS . toSeconds ( millis ) ; StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( days ) ; sb . append ( "" Days "" ) ; sb . append ( hours ) ; sb . append ( "" Hours "" ) ; sb . append ( minutes ) ; sb . append ( "" Minutes "" ) ; sb . append ( seconds ) ; sb . append ( "" Seconds"" ) ; return ( sb . toString ( ) ) ; }"
412,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
413,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
414,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
415,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""toe"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
416,"char wf ( ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( ""What is your choice? (x/o)"" ) ; char choice = input . findInLine ( ""."" ) . charAt ( 0 ) ; while ( choice != 'x' && choice != 'o' ) { System . out . println ( ""You must enter x or o!"" ) ; choice = input . next ( ) . charAt ( 0 ) ; } return choice ; }"
417,"char wf ( ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( ""What is your choice? (x/o)"" ) ; if ( input . findInLine ( ""."" ) != null ) { choice = input . findInLine ( ""."" ) . charAt ( 0 ) ; while ( choice != 'x' && choice != 'o' ) { System . out . println ( ""You must enter x or o!"" ) ; choice = input . findInLine ( ""."" ) . charAt ( 0 ) ; } } return choice ; }"
418,"int [ ] genRandoms ( int n , int numberOfRandoms , int min ) { int randomArray [ ] = new int [ numberOfRandoms ] ; for ( int i = 0 ; i < numberOfRandoms ; i ++ ) { randomArray [ i ] = min ; } for ( int i = min * numberOfRandoms ; i < n ; i ++ ) { randomArray [ randomRange ( numberOfRandoms ) ] += 1 ; } return randomArray ; }"
419,"int [ ] genRandoms ( int total , int numberOfRandoms , int minimumValue ) { int [ ] ret = new int [ numberOfRandoms ] ; Random rnd = new Random ( ) ; int totalLeft = total ; for ( int i = 0 ; i < numberOfRandoms ; i ++ ) { final int rollsLeft = numberOfRandoms - i ; int thisMax = totalLeft - ( rollsLeft - 1 ) * minimumValue ; int thisMin = Math . max ( minimumValue , totalLeft / rollsLeft ) ; int range = thisMax - thisMin ; if ( range < 0 ) throw new IllegalArgumentException ( ""Cannot have "" + minimumValue + "" * "" + numberOfRandoms + "" < "" + total ) ; int rndValue = range ; for ( int j = 0 ; j * j < rollsLeft ; j ++ ) rndValue = rnd . nextInt ( rndValue + 1 ) ; totalLeft -= ret [ i ] = rndValue + thisMin ; } Collections . shuffle ( Arrays . asList ( ret ) , rnd ) ; return ret ; }"
420,"int [ ] removeEven ( int [ ] k , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k [ i ] % 2 == 0 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( k [ j ] % 2 != 0 ) { k [ i ] = k [ i ] + k [ j ] ; k [ j ] = k [ i ] - k [ j ] ; k [ i ] = k [ i ] - k [ j ] ; break ; } } } } return k ; }"
421,"void removeEven ( int [ ] k , int n ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( k [ i ] % 2 == 1 ) k [ counter ++ ] = k [ i ] ; for ( int i = counter ; i < n ; i ++ ) k [ i ] = 0 ; }"
422,"boolean hasSameAncestor ( String person1 , String person2 ) { ArrayList < ArrayList < String > > allRelations = allRelations ( ) ; int i = 0 ; String name1 = person1 ; String name2 = person2 ; String parent1 ; String parent2 ; for ( i = 0 , parent1 = """" ; i < allRelations . size ( ) ; i ++ ) { if ( name1 . equals ( allRelations . get ( i ) . get ( 1 ) ) ) { parent1 = allRelations . get ( i ) . get ( 0 ) ; name1 = parent1 ; i = - 1 ; } } for ( i = 0 , parent2 = """" ; i < allRelations . size ( ) ; i ++ ) { if ( name2 . equals ( allRelations . get ( i ) . get ( 1 ) ) ) { parent2 = allRelations . get ( i ) . get ( 0 ) ; name2 = parent2 ; i = - 1 ; } } System . out . println ( parent1 ) ; System . out . println ( parent2 ) ; if ( parent1 . equals ( parent2 ) ) { return true ; } return false ; }"
423,"boolean hasSameAncestor ( String person1 , String person2 ) { if ( allRelations . containsKey ( person1 ) ) { if ( ancestors . contains ( allRelations . get ( person1 ) ) ) { if ( allRelations . containsKey ( person2 ) ) { if ( ancestors . contains ( allRelations . get ( person2 ) ) ) { return true ; } else if ( allRelations . containsKey ( allRelations . get ( person2 ) ) ) { return hasSameAncestor ( person1 , allRelations . get ( person2 ) ) ; } else { return false ; } } else { return false ; } } else { ancestors . add ( allRelations . get ( person1 ) ) ; if ( allRelations . containsKey ( allRelations . get ( person1 ) ) ) { return hasSameAncestor ( allRelations . get ( person1 ) , person2 ) ; } else if ( allRelations . containsKey ( person2 ) ) { return hasSameAncestor ( person1 , allRelations . get ( person2 ) ) ; } else { return false ; } } } else { return false ; } }"
424,"File createTempDir ( ) throws IOException { final File sysTempDir = new File ( System . getProperty ( ""java.io.tmpdir"" ) ) ; File newTempDir ; final int maxAttempts = 9 ; int attemptCount = 0 ; do { attemptCount ++ ; if ( attemptCount > maxAttempts ) { throw new IOException ( ""The highly improbable has occurred! Failed to "" + ""create a unique temporary directory after "" + maxAttempts + "" attempts."" ) ; } String dirName = UUID . randomUUID ( ) . toString ( ) ; newTempDir = new File ( sysTempDir , dirName ) ; } while ( newTempDir . exists ( ) ) ; if ( newTempDir . mkdirs ( ) ) { return newTempDir ; } else { throw new IOException ( ""Failed to create temp dir named "" + newTempDir . getAbsolutePath ( ) ) ; } }"
425,"File createTempDir ( ) { File baseDir = new File ( System . getProperty ( ""java.io.tmpdir"" ) ) ; String baseName = System . currentTimeMillis ( ) + ""-"" ; for ( int counter = 0 ; counter < TEMP_DIR_ATTEMPTS ; counter ++ ) { File tempDir = new File ( baseDir , baseName + counter ) ; if ( tempDir . mkdir ( ) ) { return tempDir ; } } throw new IllegalStateException ( ""Failed to create directory within "" + TEMP_DIR_ATTEMPTS + "" attempts (tried "" + baseName + ""0 to "" + baseName + ( TEMP_DIR_ATTEMPTS - 1 ) + ')' ) ; }"
426,"void actionPerformed ( ActionEvent arg0 ) { int result = JOptionPane . OK_OPTION ; if ( dirty ) { result = JOptionPane . showConfirmDialog ( gui , ""Erase the current painting?"" ) ; } if ( result == JOptionPane . OK_OPTION ) { clear ( canvasImage ) ; } }"
427,"void actionPerformed ( ActionEvent e ) { JFileChooser ch = getFileChooser ( ) ; int result = ch . showSaveDialog ( gui ) ; if ( result == JFileChooser . APPROVE_OPTION ) { try { File f = ch . getSelectedFile ( ) ; ImageIO . write ( BasicPaint . this . canvasImage , ""png"" , f ) ; BasicPaint . this . originalImage = BasicPaint . this . canvasImage ; dirty = false ; } catch ( IOException ioe ) { showError ( ioe ) ; ioe . printStackTrace ( ) ; } } }"
428,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
429,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tic"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
430,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
431,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
432,int hashCode ( ) { int result = 17 ; result = 31 * result + ( booleanField ? 1 : 0 ) ; result = 31 * result + byteField ; result = 31 * result + charField ; result = 31 * result + shortField ; result = 31 * result + intField ; result = 31 * result + ( int ) ( longField ^ ( longField > > > 32 ) ) ; result = 31 * result + Float . floatToIntBits ( floatField ) ; long doubleFieldBits = Double . doubleToLongBits ( doubleField ) ; result = 31 * result + ( int ) ( doubleFieldBits ^ ( doubleFieldBits > > > 32 ) ) ; result = 31 * result + Arrays . hashCode ( arrayField ) ; result = 31 * result + referenceField . hashCode ( ) ; result = 31 * result + ( nullableReferenceField == null ? 0 : nullableReferenceField . hashCode ( ) ) ; return result ; }
433,int hashCode ( ) { int hashCode = 1 ; Iterator i = iterator ( ) ; while ( i . hasNext ( ) ) { Object obj = i . next ( ) ; hashCode = 31 * hashCode + ( obj == null ? 0 : obj . hashCode ( ) ) ; } return hashCode ; }
434,int TestTryFinallyBlock ( ) { int returnValue ; try { int i = 0 ; i = 10 ; returnValue = i ; i = 40 ; return returnValue ; } catch ( RuntimeException e ) { i = 40 ; throw e ; } }
435,"int TestTryFinallyBlock ( ) { int i = 0 ; try { i = 10 ; return i ; } finally { i = 40 ; System . out . println ( ""local: "" + i ) ; } }"
436,"String getNextMonth ( boolean maxDate ) { Calendar calendar = Calendar . getInstance ( ) ; if ( maxDate ) { calendar . set ( year , monthNo , 1 ) ; } else { calendar . set ( year , monthNo , day ) ; } if ( monthNo == 11 ) { calendar . add ( calendar . MONTH , 1 ) ; } else { calendar . add ( calendar . MONTH , 1 ) ; } int maxD = calendar . getActualMaximum ( calendar . DAY_OF_MONTH ) ; calendar . set ( year , monthNo , maxD ) ; }"
437,"String getNextMonth ( boolean maxDate ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , monthNo , 1 ) ; calendar . add ( Calendar . MONTH , 1 ) ; if ( maxDate ) { int maxD = calendar . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; calendar . set ( Calendar . DAY_OF_MONTH , maxD ) ; } else { calendar . set ( Calendar . DAY_OF_MONTH , day ) ; } String date = ( calendar . get ( Calendar . YEAR ) ) + ""-"" + ( calendar . get ( Calendar . MONTH ) + 1 ) + ""-"" + calendar . get ( Calendar . DAY_OF_MONTH ) ; calendar . clear ( ) ; return date ; }"
438,int [ ] bubbleSort ( int [ ] a ) { int n = a . length ; int j = 0 ; boolean swap = true ; while ( swap ) { swap = false ; for ( int j = 1 ; j < n ; j ++ ) { if ( a [ j - 1 ] > a [ j ] ) { j = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = j ; swap = true ; } } n = n - 1 ; } return a ; }
439,void bubbleSort ( int [ ] numArray ) { int n = numArray . length ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j < ( n - i ) ; j ++ ) { if ( numArray [ j - 1 ] > numArray [ j ] ) { temp = numArray [ j - 1 ] ; numArray [ j - 1 ] = numArray [ j ] ; numArray [ j ] = temp ; } } } }
440,"void main ( String [ ] args ) throws Exception { final int [ ] original = new int [ ] { 1 , 1 , 2 , 8 , 9 , 8 , 4 , 7 , 4 , 9 , 1 } ; System . out . println ( Arrays . toString ( original ) ) ; quicksort ( original ) ; System . out . println ( Arrays . toString ( original ) ) ; final int [ ] unqiue = new int [ original . length ] ; int prev = original [ 0 ] ; unqiue [ 0 ] = prev ; int count = 1 ; for ( int i = 1 ; i < original . length ; ++ i ) { if ( original [ i ] != prev ) { unqiue [ count ++ ] = original [ i ] ; } prev = original [ i ] ; } System . out . println ( Arrays . toString ( unqiue ) ) ; final int [ ] compressed = new int [ count ] ; System . arraycopy ( unqiue , 0 , compressed , 0 , count ) ; System . out . println ( Arrays . toString ( compressed ) ) ; }"
441,"void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( ""enter size of the array"" ) ; int l = Integer . parseInt ( br . readLine ( ) ) ; int [ ] a = new int [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { System . out . println ( ""enter a element"" ) ; int el = Integer . parseInt ( br . readLine ( ) ) ; a [ i ] = el ; } for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < l - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { int temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; } } } int b = 0 ; a [ b ] = a [ 0 ] ; for ( int i = 1 ; i < l ; i ++ ) { if ( a [ b ] != a [ i ] ) { b ++ ; a [ b ] = a [ i ] ; } } for ( int i = 0 ; i <= b ; i ++ ) { System . out . println ( a [ i ] ) ; } }"
442,void type ( char c ) { keyPress ( VK_ALT ) ; keyPress ( VK_NUMPAD0 ) ; keyRelease ( VK_NUMPAD0 ) ; String altCode = Integer . toString ( c ) ; for ( int i = 0 ; i < altCode . length ( ) ; i ++ ) { c = ( char ) ( altCode . charAt ( i ) + '0' ) ; keyPress ( c ) ; keyRelease ( c ) ; } keyRelease ( VK_ALT ) ; }
443,"void type ( String characters ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection stringSelection = new StringSelection ( characters ) ; clipboard . setContents ( stringSelection , clipboardOwner ) ; robot . keyPress ( KeyEvent . VK_CONTROL ) ; robot . keyPress ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_CONTROL ) ; }"
444,"void main ( String [ ] args ) { Node node1 = new Node ( ) ; node1 . length = 1 ; Node node2 = new Node ( ) ; node2 . length = 2 ; Node node3 = new Node ( ) ; node3 . length = 3 ; Node node4 = new Node ( ) ; node4 . children . add ( node1 ) ; node4 . children . add ( node2 ) ; Node node5 = new Node ( ) ; node5 . children . add ( node3 ) ; Node node6 = new Node ( ) ; node6 . children . add ( node4 ) ; node6 . children . add ( node5 ) ; Object array = createArray ( String . class , node6 ) ; outputArray ( array ) ; System . out . println ( ) ; }"
445,"void main ( String [ ] args ) { Random r = new Random ( ) ; int dims = 1 + r . nextInt ( 3 ) ; int [ ] sizes = new int [ dims ] ; for ( int i = 0 ; i < sizes . length ; i ++ ) sizes [ i ] = 1 + r . nextInt ( 3 ) ; System . out . println ( ""Creating array with dimensions / sizes: "" + Arrays . toString ( sizes ) . replaceAll ( "", "" , ""]["" ) ) ; Object multiDimArray = Array . newInstance ( String . class , sizes ) ; fillWithSomeValues ( multiDimArray , ""pos "" , sizes ) ; System . out . println ( Arrays . deepToString ( ( Object [ ] ) multiDimArray ) ) ; }"
446,"void main ( String [ ] args ) { String string = ""check duplicate charcters in string"" ; string = string . toLowerCase ( ) ; char [ ] charAr = string . toCharArray ( ) ; Arrays . sort ( charAr ) ; for ( int i = 1 ; i < charAr . length ; ) { int count = recursiveMethod ( charAr , i , 1 ) ; if ( count > 1 ) { System . out . println ( ""'"" + charAr [ i ] + ""' comes "" + count + "" times"" ) ; i = i + count ; } else i ++ ; } }"
447,"void main ( String ... a ) { System . out . print ( ""Enter the String"" ) ; Scanner sc = new Scanner ( System . in ) ; String st = sc . nextLine ( ) ; int [ ] ar = new int [ 256 ] ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { ar [ st . charAt ( i ) ] = ar [ st . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { char ch = ( char ) i ; if ( ar [ i ] > 0 ) { if ( ar [ i ] == 1 ) { System . out . print ( ch ) ; } else { System . out . print ( ch + """" + ar [ i ] ) ; } } } }"
448,"int solution ( int N ) { String binary = Integer . toString ( N , 2 ) ; int largestGap = 0 ; for ( int i = 1 , gap = 0 ; i < binary . length ( ) ; i ++ ) { while ( i < binary . length ( ) && binary . charAt ( i ) == '0' ) { i ++ ; gap ++ ; } if ( gap > largestGap && i < binary . length ( ) ) { largestGap = gap ; } gap = 0 ; } return largestGap ; }"
449,"int solution ( int N ) { int result = 0 ; while ( N > 0 ) { if ( ( N & 1 ) == 1 ) { int temp = 0 ; while ( ( N >>= 1 ) > 0 && ( ( N & 1 ) != 1 ) ) { temp ++ ; } result = Math . max ( result , temp ) ; } else { N >>= 1 ; } } return result ; }"
450,"String deriveCurveName ( org . bouncycastle . jce . spec . ECParameterSpec ecParameterSpec ) throws GeneralSecurityException { for ( @ SuppressWarnings ( ""rawtypes"" ) Enumeration names = ECNamedCurveTable . getNames ( ) ; names . hasMoreElements ( ) ; ) { final String name = ( String ) names . nextElement ( ) ; final X9ECParameters params = ECNamedCurveTable . getByName ( name ) ; if ( params . getN ( ) . equals ( ecParameterSpec . getN ( ) ) && params . getH ( ) . equals ( ecParameterSpec . getH ( ) ) && params . getCurve ( ) . equals ( ecParameterSpec . getCurve ( ) ) && params . getG ( ) . equals ( ecParameterSpec . getG ( ) ) ) { return name ; } } throw new GeneralSecurityException ( ""Could not find name for curve"" ) ; }"
451,"String deriveCurveName ( PrivateKey privateKey ) throws GeneralSecurityException { if ( privateKey instanceof java . security . interfaces . ECPrivateKey ) { final java . security . interfaces . ECPrivateKey pk = ( java . security . interfaces . ECPrivateKey ) privateKey ; final ECParameterSpec params = pk . getParams ( ) ; return deriveCurveName ( EC5Util . convertSpec ( params , false ) ) ; } else if ( privateKey instanceof org . bouncycastle . jce . interfaces . ECPrivateKey ) { final org . bouncycastle . jce . interfaces . ECPrivateKey pk = ( org . bouncycastle . jce . interfaces . ECPrivateKey ) privateKey ; return deriveCurveName ( pk . getParameters ( ) ) ; } else throw new IllegalArgumentException ( ""Can only be used with instances of ECPrivateKey (either jce or bc implementation)"" ) ; }"
452,"void main ( String [ ] args ) { int n = 0 ; Scanner s = new Scanner ( System . in ) ; System . out . print ( ""Enter an integer number: "" ) ; n = s . nextInt ( ) ; if ( n <= 0 ) System . out . print ( ""Enter numbers greater than 0"" ) ; else { NumberToWord a = new NumberToWord ( ) ; System . out . print ( ""After conversion number in words is :"" ) ; a . pw ( ( n / 1000000000 ) , "" Hundred"" ) ; a . pw ( ( n / 10000000 ) % 100 , "" crore"" ) ; a . pw ( ( ( n / 100000 ) % 100 ) , "" lakh"" ) ; a . pw ( ( ( n / 1000 ) % 100 ) , "" thousand"" ) ; a . pw ( ( ( n / 100 ) % 10 ) , "" hundred"" ) ; a . pw ( ( n % 100 ) , "" "" ) ; } }"
453,"void main ( String ... args ) { processor = new DefaultProcessor ( ) ; long [ ] values = new long [ ] { 0 , 4 , 10 , 12 , 100 , 108 , 299 , 1000 , 1003 , 2040 , 45213 , 100000 , 100005 , 100010 , 202020 , 202022 , 999999 , 1000000 , 1000001 , 10000000 , 10000007 , 99999999 , Long . MAX_VALUE , Long . MIN_VALUE } ; String [ ] strValues = new String [ ] { ""0"" , ""1.30"" , ""0001.00"" , ""3.141592"" } ; for ( long val : values ) { System . out . println ( val + "" = "" + processor . getName ( val ) ) ; } for ( String strVal : strValues ) { System . out . println ( strVal + "" = "" + processor . getName ( strVal ) ) ; } StringBuilder bigNumber = new StringBuilder ( ) ; for ( int d = 0 ; d < 66 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } bigNumber . append ( ""."" ) ; for ( int d = 0 ; d < 26 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } System . out . println ( bigNumber . toString ( ) + "" = "" + processor . getName ( bigNumber . toString ( ) ) ) ; }"
454,void throwException ( final String key ) throws Throwable { ExceptionMapping exceptionMapping = exceptionMappings . getExceptionMappings ( ) . get ( key ) ; if ( exceptionMapping != null ) { try { Class < Throwable > exceptionClass = ( Class < Throwable > ) Class . forName ( exceptionMapping . getClassName ( ) ) ; try { throw exceptionClass . cast ( exceptionClass . newInstance ( ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } }
455,"void throwException ( final String exClassName ) throws CheckedException , UncheckedException { Class < ? > clazz ; try { clazz = Class . forName ( exClassName ) ; } catch ( ClassNotFoundException cnfe ) { throw new InternalError ( exClassName , cnfe ) ; } if ( CheckedException . class . isAssignableFrom ( clazz ) ) { throw newException ( clazz . asSubclass ( CheckedException . class ) ) ; } else if ( UncheckedException . class . isAssignableFrom ( clazz ) ) { throw newException ( clazz . asSubclass ( UncheckedException . class ) ) ; } else { throw new InternalError ( exClassName + "" is not a valid exception"" ) ; } }"
456,"int binarySearch ( int [ ] a , int start , int end , int target ) { int middle = ( start + end ) / 2 ; if ( end < start ) { return - 1 ; } if ( target == a [ middle ] ) { return middle ; } else if ( target < a [ middle ] ) { return binarySearch ( a , start , middle - 1 , target ) ; } else { return binarySearch ( a , middle + 1 , end , target ) ; } }"
457,"int binarySearch ( int intToSearch , int [ ] sortedArray ) { int lower = 0 ; int upper = sortedArray . length - 1 ; while ( lower <= upper ) { int mid = lower + ( upper - lower ) / 2 ; if ( intToSearch < sortedArray [ mid ] ) upper = mid - 1 ; else if ( intToSearch > sortedArray [ mid ] ) lower = mid + 1 ; else return mid ; } return - 1 ; }"
458,"void dispatchEvent ( Event event ) { checkNotNull ( event ) ; CancellableEvent cancellableEvent = null ; boolean cancellable ; if ( cancellable = event instanceof CancellableEvent ) { cancellableEvent = ( CancellableEvent ) event ; checkArgument ( cancellableEvent . isCancelled ( ) ) ; } handleEvents ( event , true ) ; handleEvents ( event , false , cancellableEvent ) ; }"
459,"void dispatchEvent ( Event event ) { checkNotNull ( event ) ; CancellableEvent cancellableEvent = null ; boolean cancellable ; if ( cancellable = event instanceof CancellableEvent ) { cancellableEvent = ( CancellableEvent ) event ; checkArgument ( cancellableEvent . isCancelled ( ) ) ; } for ( EventPriority priority : EventPriority . values ( ) ) { Map < Method , EventListener > internalMapping = getRegistry ( ) . getMethodMap ( event . getClass ( ) , priority , true ) ; if ( internalMapping != null ) { for ( Entry < Method , EventListener > entry : internalMapping . entrySet ( ) ) { invokeEntry ( entry , event ) ; } } } for ( EventPriority priority : EventPriority . values ( ) ) { Map < Method , EventListener > internalMapping = getRegistry ( ) . getMethodMap ( event . getClass ( ) , priority , false ) ; if ( internalMapping != null ) { for ( Entry < Method , EventListener > entry : internalMapping . entrySet ( ) ) { invokeEntry ( entry , event ) ; if ( cancellable && cancellableEvent . isCancelled ( ) ) { return ; } } } } }"
460,boolean isPalindrome ( String original ) { int i = original . length ( ) - 1 ; int j = 0 ; while ( i > j ) { if ( original . charAt ( i ) != original . charAt ( j ) ) { return false ; } i -- ; j ++ ; } return true ; }
461,boolean isPalindrome ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < ( n / 2 ) ; ++ i ) { if ( s . charAt ( i ) != s . charAt ( n - i - 1 ) ) { return false ; } } return true ; }
462,"void main ( String [ ] args ) { String str = ""abcdabghplhhnfl"" . toLowerCase ( ) ; Integer [ ] ar = new Integer [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = str . charAt ( i ) - 'a' ; if ( ar [ j ] == null ) { ar [ j ] = 1 ; } else { ar [ j ] += 1 ; } } for ( int i = 0 ; i < ar . length ; i ++ ) { if ( ar [ i ] != null && ar [ i ] > 1 ) { char c = ( char ) ( 97 + i ) ; System . out . println ( ""'"" + c + ""' comes "" + ar [ i ] + "" times."" ) ; } } }"
463,"void main ( String ... a ) { System . out . print ( ""Enter the String"" ) ; Scanner sc = new Scanner ( System . in ) ; String st = sc . nextLine ( ) ; int [ ] ar = new int [ 256 ] ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { ar [ st . charAt ( i ) ] = ar [ st . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { char ch = ( char ) i ; if ( ar [ i ] > 0 ) { if ( ar [ i ] == 1 ) { System . out . print ( ch ) ; } else { System . out . print ( ch + """" + ar [ i ] ) ; } } } }"
464,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
465,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
466,"void copyFolder ( File src , File dest ) { if ( src == null || dest == null ) return ; if ( ! src . isDirectory ( ) ) return ; if ( dest . exists ( ) ) { if ( ! dest . isDirectory ( ) ) { return ; } } else { dest . mkdir ( ) ; } if ( src . listFiles ( ) == null || src . listFiles ( ) . length == 0 ) return ; for ( File file : src . listFiles ( ) ) { File fileDest = new File ( dest , file . getName ( ) ) ; if ( file . isDirectory ( ) ) { copyFolder ( file , fileDest ) ; } else { if ( fileDest . exists ( ) ) continue ; try { Files . copy ( file . toPath ( ) , fileDest . toPath ( ) ) ; } catch ( IOException e ) { } } } }"
467,"void copyFolder ( Path src , Path dest ) { try { Files . walk ( src ) . forEach ( s -> { try { Path d = dest . resolve ( src . relativize ( s ) ) ; if ( Files . isDirectory ( s ) ) { if ( ! Files . exists ( d ) ) Files . createDirectory ( d ) ; return ; } Files . copy ( s , d ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }"
468,"void main ( String [ ] args ) throws Exception { Console console = System . console ( ) ; if ( console == null ) { System . out . println ( ""Unable to fetch console"" ) ; return ; } String line = console . readLine ( ) ; console . printf ( ""I saw this line: %s"" , line ) ; }"
469,"void main ( final String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( ""Enter some text, or '"" + EXIT_COMMAND + ""' to quit"" ) ; while ( true ) { System . out . print ( ""><![CDATA[ "" ) ; String input = br . readLine ( ) ; System . out . println ( input ) ; if ( input . length ( ) == EXIT_COMMAND . length ( ) && input . toLowerCase ( ) . equals ( EXIT_COMMAND ) ) { System . out . println ( ""Exiting."" ) ; return ; } System . out . println ( ""...response goes here..."" ) ; } }"
470,"String shuffle ( String s ) { String shuffledString = """" ; while ( s . length ( ) != 0 ) { int index = ( int ) Math . floor ( Math . random ( ) * s . length ( ) ) ; char c = s . charAt ( index ) ; s = s . substring ( 0 , index ) + s . substring ( index + 1 ) ; shuffledString += c ; } return shuffledString ; }"
471,void shuffle ( String input ) { List < Character > characters = new ArrayList < Character > ( ) ; for ( char c : input . toCharArray ( ) ) { characters . add ( c ) ; } StringBuilder output = new StringBuilder ( input . length ( ) ) ; while ( characters . size ( ) != 0 ) { int randPicker = ( int ) ( Math . random ( ) * characters . size ( ) ) ; output . append ( characters . remove ( randPicker ) ) ; } System . out . println ( output . toString ( ) ) ; }
472,"boolean areAnagrams ( CharSequence a , CharSequence b ) { int len = a . length ( ) ; if ( len != b . length ( ) ) return false ; Map < Integer , Integer > ocr = new HashMap < > ( 64 ) ; a . codePoints ( ) . forEach ( c -> ocr . merge ( c , 1 , Integer :: sum ) ) ; for ( int i = 0 , c = 0 ; i < len ; i += Character . charCount ( c ) ) { int cc = ocr . getOrDefault ( ( c = Character . codePointAt ( b , i ) ) , 0 ) ; if ( cc == 0 ) return false ; ocr . put ( c , cc - 1 ) ; } return true ; }"
473,"boolean areAnagrams ( String one , String two ) { if ( one . length ( ) == two . length ( ) ) { String s0 = one . toLowerCase ( ) ; String s1 = two . toLowerCase ( ) ; HashMap < Character , Integer > chars = new HashMap < Character , Integer > ( one . length ( ) ) ; Integer count ; for ( char c : s0 . toCharArray ( ) ) { count = chars . get ( c ) ; count = Integer . valueOf ( count != null ? count + 1 : 1 ) ; chars . put ( c , count ) ; } for ( char c : s1 . toCharArray ( ) ) { count = chars . get ( c ) ; if ( count == null ) { return false ; } else { count -- ; chars . put ( c , count ) ; } } for ( Integer i : chars . values ( ) ) { if ( i != 0 ) { return false ; } } return true ; } else { return false ; } }"
474,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_SHIFT , VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_AT ) ; break ; case '#' : doType ( VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_AMPERSAND ) ; break ; case '*' : doType ( VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
475,void type ( String text ) { char c ; for ( int ii = 0 ; ii < text . length ( ) ; ii ++ ) { c = text . charAt ( ii ) ; if ( c <= 31 || c == 129 ) { pressControlKey ( c ) ; } else { typeAsciiCode ( c ) ; } } }
476,"void run ( ) { int emptyCycleCounter = 0 ; while ( true ) { int i = counter . get ( ) ; if ( i > MAX_COUNTER ) { break ; } if ( i % 2 == ( odd ? 1 : 0 ) ) { System . out . println ( i + ( odd ? "" odd"" : "" even"" ) ) ; counter . incrementAndGet ( ) ; } else { emptyCycleCounter ++ ; Thread . yield ( ) ; } } System . out . println ( ""Finished"" + ( odd ? "" odd"" : "" even"" ) + "" with "" + emptyCycleCounter + "" empty cycles."" ) ; }"
477,void run ( ) { for ( int i = 1 ; i < 10 ; i += 2 ) { synchronized ( o ) { try { while ( ! turn ) { o . wait ( ) ; } } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } finally { System . out . println ( i ) ; turn = ! turn ; o . notifyAll ( ) ; } } } }
478,"void sort ( int [ ] arr ) { int index = 0 ; int n = arr . length ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( compare ( arr [ index ] , arr [ index - 1 ] ) ) index ++ ; else { int temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } }"
479,int [ ] sort ( int arr [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = i ; j < arr . length ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } return arr ; }
480,"boolean isPrime ( long num ) { if ( num > 2 && num % 2 == 0 ) { System . out . println ( num + "" is not prime"" ) ; return false ; } int top = ( int ) Math . sqrt ( num ) + 1 ; for ( int i = 3 ; i < top ; i += 2 ) { if ( num % i == 0 ) { System . out . println ( num + "" is not prime"" ) ; return false ; } } System . out . println ( num + "" is prime"" ) ; return true ; }"
481,boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { return false ; } } return true ; }
482,"void main ( String [ ] args ) { n = 4 ; set = new Vector < String > ( 4 ) ; d = new int [ 6 ] ; set . add ( ""a"" ) ; set . add ( ""b"" ) ; set . add ( ""c"" ) ; set . add ( ""d"" ) ; recursion ( 0 ) ; }"
483,"void main ( String [ ] args ) { for ( int i = 1 ; i < 16 ; ++ i ) { if ( ( i & 1 ) > 0 ) System . out . print ( ""A"" ) ; if ( ( i & 2 ) > 0 ) System . out . print ( ""B"" ) ; if ( ( i & 4 ) > 0 ) System . out . print ( ""C"" ) ; if ( ( i & 8 ) > 0 ) System . out . print ( ""D"" ) ; System . out . println ( """" ) ; } }"
484,"void contextDestroyed ( ServletContextEvent servletContextEvent ) { if ( this . driver != null ) { try { DriverManager . deregisterDriver ( driver ) ; LOG . info ( String . format ( ""deregistering jdbc driver: %s"" , driver ) ) ; } catch ( SQLException e ) { LOG . warn ( String . format ( ""Error deregistering driver %s"" , driver ) , e ) ; } this . driver = null ; } else { LOG . warn ( ""No driver to deregister"" ) ; } }"
485,"void contextDestroyed ( ServletContextEvent sce ) { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { Driver driver = drivers . nextElement ( ) ; if ( driver . getClass ( ) . getClassLoader ( ) == cl ) { try { log . info ( ""Deregistering JDBC driver {}"" , driver ) ; DriverManager . deregisterDriver ( driver ) ; } catch ( SQLException ex ) { log . error ( ""Error deregistering JDBC driver {}"" , driver , ex ) ; } } else { log . trace ( ""Not deregistering JDBC driver {} as it does not belong to this webapp's ClassLoader"" , driver ) ; } } }"
486,"Node reverse ( Node n , Node p ) { if ( n == null ) return null ; if ( n . next == null ) { n . next = p ; return n ; } Node r = reverse ( n . next , n ) ; n . next = p ; return r ; }"
487,"Node reverse ( Node previous , Node current ) { if ( previous == null ) return null ; if ( previous . equals ( head ) ) previous . setNext ( null ) ; if ( current == null ) { head = previous ; return head ; } else { Node temp = current . getNext ( ) ; current . setNext ( previous ) ; reverse ( current , temp ) ; } return null ; }"
488,"boolean isAnagram ( String leftString , String rightString ) { if ( leftString == null || rightString == null ) { return false ; } else if ( leftString . length ( ) != rightString . length ( ) ) { return false ; } char letters [ ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' } ; Map < Character , Integer > occurrencesMap = new HashMap < > ( ) ; for ( char l : letters ) { occurrencesMap . put ( l , 0 ) ; } for ( int i = 0 ; i < leftString . length ( ) ; i ++ ) { char charFromLeft = leftString . charAt ( i ) ; Integer nrOfCharsInLeft = occurrencesMap . get ( charFromLeft ) ; occurrencesMap . put ( charFromLeft , ++ nrOfCharsInLeft ) ; char charFromRight = rightString . charAt ( i ) ; Integer nrOfCharsInRight = occurrencesMap . get ( charFromRight ) ; occurrencesMap . put ( charFromRight , -- nrOfCharsInRight ) ; } for ( Integer occurrencesNr : occurrencesMap . values ( ) ) { if ( occurrencesNr != 0 ) { return false ; } } return true ; }"
489,"boolean isAnagram ( String first , String second ) { String positive = first . toLowerCase ( ) ; String negative = second . toLowerCase ( ) ; if ( positive . length ( ) != negative . length ( ) ) { return false ; } int [ ] counts = new int [ 26 ] ; int diff = 0 ; for ( int i = 0 ; i < positive . length ( ) ; i ++ ) { int pos = ( int ) positive . charAt ( i ) - 97 ; if ( counts [ pos ] >= 0 ) { diff ++ ; } else { diff -- ; } counts [ pos ] ++ ; int neg = ( int ) negative . charAt ( i ) - 97 ; if ( counts [ neg ] <= 0 ) { diff ++ ; } else { diff -- ; } counts [ neg ] -- ; } return diff == 0 ; }"
490,"void countString ( String str , Character character ) { int [ ] counts = new int [ MAX_CHAR ] ; char [ ] chars = str . toCharArray ( ) ; for ( char ch : chars ) { if ( character != null && character != ch ) { continue ; } counts [ ch ] ++ ; } for ( int i = 0 ; i < counts . length ; i ++ ) { if ( counts [ i ] > 0 ) { System . out . println ( ""Character "" + ( char ) i + "" appeared "" + counts [ i ] + "" times"" ) ; } } }"
491,"void countString ( String str , char searchKey ) { String count = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == searchKey ) count += str . charAt ( i ) + ""\n"" ; } System . out . println ( count + ""\nNumber of Occurrence of "" + searchKey + "" is "" + count . length ( ) + "" in string "" + str ) ; }"
492,"void main ( String [ ] args ) { List < Integer > numberList = new ArrayList < > ( ) ; List < String > strList = new ArrayList < > ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( Pattern . matches ( ""-?\\d+"" , args [ i ] ) ) { numberList . add ( Integer . parseInt ( args [ i ] ) ) ; } else { strList . add ( args [ i ] ) ; } } String [ ] colors = strList . toArray ( new String [ 0 ] ) ; int [ ] number = ArrayUtils . toPrimitive ( numberList . toArray ( new Integer [ numberList . size ( ) ] ) ) ; }"
493,"void main ( String [ ] args ) { String [ ] colors = new String [ args . length ] ; int color_ix = 0 ; int number_idx = 0 ; Integer [ ] number = new Integer [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] == null ) { continue ; } try { number [ number_idx ] = Integer . parseInt ( args [ i ] ) ; number_idx ++ ; } catch ( NumberFormatException e ) { colors [ color_ix ] = args [ i ] ; color_ix ++ ; } } System . out . println ( ""-----Number-----"" ) ; for ( int i = 0 ; i < number_idx ; i ++ ) { System . out . println ( number [ i ] ) ; } System . out . println ( ""-----Colors-----"" ) ; for ( int i = 0 ; i < color_ix ; i ++ ) { System . out . println ( colors [ i ] ) ; } }"
494,"void unzip ( File zipFile , File targetDirectory ) throws IOException { ZipInputStream zis = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( zipFile ) ) ) ; try { ZipEntry ze ; int count ; byte [ ] buffer = new byte [ 8192 ] ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { File file = new File ( targetDirectory , ze . getName ( ) ) ; File dir = ze . isDirectory ( ) ? file : file . getParentFile ( ) ; if ( ! dir . isDirectory ( ) && ! dir . mkdirs ( ) ) throw new FileNotFoundException ( ""Failed to ensure directory: "" + dir . getAbsolutePath ( ) ) ; if ( ze . isDirectory ( ) ) continue ; FileOutputStream fout = new FileOutputStream ( file ) ; try { while ( ( count = zis . read ( buffer ) ) != - 1 ) fout . write ( buffer , 0 , count ) ; } finally { fout . close ( ) ; } } } finally { zis . close ( ) ; } }"
495,"void unzip ( ) { try { FileInputStream fin = new FileInputStream ( _zipFile ) ; ZipInputStream zin = new ZipInputStream ( fin ) ; ZipEntry ze = null ; while ( ( ze = zin . getNextEntry ( ) ) != null ) { Log . v ( ""Decompress"" , ""Unzipping "" + ze . getName ( ) ) ; if ( ze . isDirectory ( ) ) { _dirChecker ( ze . getName ( ) ) ; } else { FileOutputStream fout = new FileOutputStream ( _location + ze . getName ( ) ) ; BufferedOutputStream bufout = new BufferedOutputStream ( fout ) ; byte [ ] buffer = new byte [ 1024 ] ; int read = 0 ; while ( ( read = zin . read ( buffer ) ) != - 1 ) { bufout . write ( buffer , 0 , read ) ; } bufout . close ( ) ; zin . closeEntry ( ) ; fout . close ( ) ; } } zin . close ( ) ; Log . d ( ""Unzip"" , ""Unzipping complete. path :  "" + _location ) ; } catch ( Exception e ) { Log . e ( ""Decompress"" , ""unzip"" , e ) ; Log . d ( ""Unzip"" , ""Unzipping failed"" ) ; } }"
496,"void run ( ) { int emptyCycleCounter = 0 ; while ( true ) { int i = counter . get ( ) ; if ( i > MAX_COUNTER ) { break ; } if ( i % 2 == ( odd ? 1 : 0 ) ) { System . out . println ( i + ( odd ? "" odd"" : "" even"" ) ) ; counter . incrementAndGet ( ) ; } else { emptyCycleCounter ++ ; Thread . yield ( ) ; } } System . out . println ( ""Finished"" + ( odd ? "" odd"" : "" even"" ) + "" with "" + emptyCycleCounter + "" empty cycles."" ) ; }"
497,void run ( ) { for ( int i = 0 ; i <= 10 ; i += 2 ) { synchronized ( o ) { try { while ( turn ) { o . wait ( ) ; } } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } finally { System . out . println ( i ) ; turn = ! turn ; o . notifyAll ( ) ; } } } }
498,"void runScript ( Reader reader ) throws IOException , SQLException { try { boolean originalAutoCommit = connection . getAutoCommit ( ) ; try { if ( originalAutoCommit != this . autoCommit ) { connection . setAutoCommit ( this . autoCommit ) ; } runScript ( connection , reader ) ; } finally { connection . setAutoCommit ( originalAutoCommit ) ; } } catch ( IOException e ) { throw e ; } catch ( SQLException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( ""Error running script.  Cause: "" + e , e ) ; } }"
499,"void runScript ( Connection conn , Reader reader ) throws IOException , SQLException { StringBuffer command = null ; try { LineNumberReader lineReader = new LineNumberReader ( reader ) ; String line = null ; while ( ( line = lineReader . readLine ( ) ) != null ) { if ( command == null ) { command = new StringBuffer ( ) ; } String trimmedLine = line . trim ( ) ; if ( trimmedLine . startsWith ( ""--"" ) ) { println ( trimmedLine ) ; } else if ( trimmedLine . length ( ) < 1 || trimmedLine . startsWith ( ""//"" ) ) { } else if ( trimmedLine . length ( ) < 1 || trimmedLine . startsWith ( ""--"" ) ) { } else if ( ! fullLineDelimiter && trimmedLine . endsWith ( getDelimiter ( ) ) || fullLineDelimiter && trimmedLine . equals ( getDelimiter ( ) ) ) { command . append ( line . substring ( 0 , line . lastIndexOf ( getDelimiter ( ) ) ) ) ; command . append ( "" "" ) ; Statement statement = conn . createStatement ( ) ; println ( command ) ; boolean hasResults = false ; if ( stopOnError ) { hasResults = statement . execute ( command . toString ( ) ) ; } else { try { statement . execute ( command . toString ( ) ) ; } catch ( SQLException e ) { e . fillInStackTrace ( ) ; printlnError ( ""Error executing: "" + command ) ; printlnError ( e ) ; } } if ( autoCommit && ! conn . getAutoCommit ( ) ) { conn . commit ( ) ; } ResultSet rs = statement . getResultSet ( ) ; if ( hasResults && rs != null ) { ResultSetMetaData md = rs . getMetaData ( ) ; int cols = md . getColumnCount ( ) ; for ( int i = 0 ; i < cols ; i ++ ) { String name = md . getColumnLabel ( i ) ; print ( name + ""\t"" ) ; } println ( """" ) ; while ( rs . next ( ) ) { for ( int i = 0 ; i < cols ; i ++ ) { String value = rs . getString ( i ) ; print ( value + ""\t"" ) ; } println ( """" ) ; } } command = null ; try { statement . close ( ) ; } catch ( Exception e ) { } Thread . yield ( ) ; } else { command . append ( line ) ; command . append ( "" "" ) ; } } if ( ! autoCommit ) { conn . commit ( ) ; } } catch ( SQLException e ) { e . fillInStackTrace ( ) ; printlnError ( ""Error executing: "" + command ) ; printlnError ( e ) ; throw e ; } catch ( IOException e ) { e . fillInStackTrace ( ) ; printlnError ( ""Error executing: "" + command ) ; printlnError ( e ) ; throw e ; } finally { conn . rollback ( ) ; flush ( ) ; } }"
500,"void main ( String [ ] args ) throws InterruptedException { CountDownLatch theLatch = new CountDownLatch ( 100 ) ; List < String > output = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; SecureRandom random = new SecureRandom ( ) ; ExecutorService service = Executors . newCachedThreadPool ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { service . execute ( new CountDownTask ( theLatch , output , random ) ) ; } theLatch . await ( 1 , TimeUnit . MINUTES ) ; service . shutdown ( ) ; System . out . println ( output . size ( ) ) ; }"
501,"void main ( String [ ] args ) throws InterruptedException { AtomicInteger counter = new AtomicInteger ( ) ; ExecutorService pool = Executors . newFixedThreadPool ( 4 ) ; for ( int i = 0 ; i < 4 ; ++ i ) { pool . execute ( new MyTask ( counter ) ) ; } pool . shutdown ( ) ; pool . awaitTermination ( 1 , TimeUnit . HOURS ) ; }"
502,"String join ( String separator , String ... values ) { StringBuilder sb = new StringBuilder ( 128 ) ; int end = 0 ; for ( String s : values ) { if ( s != null ) { sb . append ( s ) ; end = sb . length ( ) ; sb . append ( separator ) ; } } return sb . substring ( 0 , end ) ; }"
503,"String join ( String separator , String ... values ) { if ( values . length == 0 ) return """" ; char [ ] sep = separator . toCharArray ( ) ; int totalSize = ( values . length - 1 ) * sep . length ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] == null ) values [ i ] = """" ; else totalSize += values [ i ] . length ( ) ; } char [ ] joined = new char [ totalSize ] ; int pos = 0 ; for ( int i = 0 , end = values . length - 1 ; i < end ; i ++ ) { System . arraycopy ( values [ i ] . toCharArray ( ) , 0 , joined , pos , values [ i ] . length ( ) ) ; pos += values [ i ] . length ( ) ; System . arraycopy ( sep , 0 , joined , pos , sep . length ) ; pos += sep . length ; } System . arraycopy ( values [ values . length - 1 ] . toCharArray ( ) , 0 , joined , pos , values [ values . length - 1 ] . length ( ) ) ; return new String ( joined ) ; }"
504,"void main ( String [ ] args ) { int red = 111 ; int green = 222 ; int blue = 121 ; int code = red * 256 * 256 + green * 256 + blue ; blue = code % 256 ; green = ( code % ( 256 * 256 ) - blue ) / 256 ; red = ( code - blue - green * 256 ) / ( 256 * 256 ) ; System . out . println ( """" + red + green + blue ) ; }"
505,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int code ; int red , green , blue ; int rMask = 0xFF0000 , gMask = 0xFF00 , bMask = 0xFF ; System . out . println ( ""Please enter the red color. Range [0, 255] only please."" ) ; red = scan . nextInt ( ) ; System . out . println ( ""Please enter the green color. Range [0, 255] only please."" ) ; green = scan . nextInt ( ) ; System . out . println ( ""Please enter the blue color. Range [0, 255] only please."" ) ; blue = scan . nextInt ( ) ; code = 0 ; code += ( int ) ( red * Math . pow ( 2 , 16 ) ) ; code += ( int ) ( green * Math . pow ( 2 , 8 ) ) ; code += ( int ) ( blue * Math . pow ( 2 , 0 ) ) ; System . out . println ( ""The code is "" + code + ""."" ) ; red = 0 ; green = 0 ; blue = 0 ; red = ( code & rMask ) > > 16 ; green = ( code & gMask ) > > 8 ; blue = ( code & bMask ) ; System . out . println ( ""Your red value is: "" + red ) ; System . out . println ( ""Your green value is: "" + green ) ; System . out . println ( ""Your blue value is: "" + blue ) ; }"
506,"int findCombinationsCount ( int amount , int coins [ ] ) { if ( coins . length == 1 ) { return amount % coins [ 0 ] == 0 ? 1 : 0 ; } else { int total = 0 ; int [ ] subCoins = arrayOfCoinsExceptTheFirstOne ( coins ) ; for ( int i = 0 ; i * coins [ 0 ] <= amount ; ++ i ) { total += findCombinationsCount ( amount - i * coins [ 0 ] , subCoins ) ; } return total ; } }"
507,"int findCombinationsCount ( int amount , int coins [ ] , int checkFromIndex ) { if ( amount == 0 ) return 1 ; else if ( amount < 0 || coins . length == checkFromIndex ) return 0 ; else { int withFirstCoin = findCombinationsCount ( amount - coins [ checkFromIndex ] , coins , checkFromIndex ) ; int withoutFirstCoin = findCombinationsCount ( amount , coins , checkFromIndex + 1 ) ; return withFirstCoin + withoutFirstCoin ; } }"
508,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String formatedSource = source . subSequence ( start , end ) . toString ( ) ; String destPrefix = dest . subSequence ( 0 , dstart ) . toString ( ) ; String destSuffix = dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; String result = destPrefix + formatedSource + destSuffix ; result = result . replace ( "","" , ""."" ) ; Matcher matcher = mPattern . matcher ( result ) ; if ( matcher . matches ( ) ) { return null ; } return """" ; }"
509,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { int dotPos = - 1 ; int len = dest . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = dest . charAt ( i ) ; if ( c == '.' || c == ',' ) { dotPos = i ; break ; } } if ( dotPos >= 0 ) { if ( source . equals ( ""."" ) || source . equals ( "","" ) ) { return """" ; } if ( dend <= dotPos ) { return null ; } if ( len - dotPos > decimalDigits ) { return """" ; } } return null ; }"
510,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
511,"XSSFFont transform ( XSSFWorkbook workbookNew , HSSFFont fontOld ) { XSSFFont fontNew = workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }"
512,"void main ( String [ ] args ) { int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int mArray [ ] = new int [ 5 ] ; int j = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > lower ( mArray ) ) { mArray [ lowerPos ( mArray ) ] = array [ i ] ; } } System . out . println ( Arrays . toString ( mArray ) ) ; }"
513,"void main ( String args [ ] ) { int i ; int largestSize = 4 ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 } ; int large [ ] = Arrays . copyOf ( array , largestSize ) ; int smallest = large [ 0 ] ; int smallestIndex = 0 ; for ( int j = 1 ; j < large . length ; ++ j ) { if ( smallest > large [ j ] ) { smallest = large [ j ] ; smallestIndex = j ; } } for ( i = large . length ; i < array . length ; i ++ ) { if ( smallest < array [ i ] ) { large [ smallestIndex ] = array [ i ] ; smallest = large [ 0 ] ; smallestIndex = 0 ; for ( int j = 1 ; j < large . length ; ++ j ) { if ( smallest > large [ j ] ) { smallest = large [ j ] ; smallestIndex = j ; } } } } for ( int j = 0 ; j < large . length ; j ++ ) { System . out . println ( ""Largest 5 : "" + large [ j ] ) ; } System . out . println ( ) ; System . out . println ( ""Largest is: "" + getHighest ( large ) ) ; }"
514,"void main ( String ... aArgs ) { log ( ""Generating 10 random integers in range 1..10."" ) ; int START = 1 ; int END = 10 ; Random randomGenerator = new Random ( ) ; for ( int idx = 1 ; idx <= 10 ; ++ idx ) { showRandomInteger ( START , END , randomGenerator ) ; } log ( ""Done"" ) ; }"
515,"void main ( String [ ] args ) { Random ran = new Random ( ) ; int min , max ; Scanner sc = new Scanner ( System . in ) ; System . out . println ( ""Enter min range:"" ) ; min = sc . nextInt ( ) ; System . out . println ( ""Enter max range:"" ) ; max = sc . nextInt ( ) ; int num = ran . nextInt ( min ) ; int num1 = ran . nextInt ( max ) ; System . out . println ( ""Random Number between given range is "" + num1 ) ; }"
516,"void printPath ( int [ ] [ ] mat , int i , int j ) { System . out . println ( ""("" + i + "","" + j + "")"" ) ; if ( i >= 0 && i < mat . length - 1 && mat [ i ] [ j ] < mat [ i + 1 ] [ j ] ) { printPath ( mat , i + 1 , j ) ; } else if ( j >= 0 && j < mat [ 0 ] . length - 1 && mat [ i ] [ j ] < mat [ i ] [ j + 1 ] ) { printPath ( mat , i , j + 1 ) ; } else if ( i > 0 && i < mat . length - 1 && mat [ i ] [ j ] < mat [ i - 1 ] [ j ] ) { printPath ( mat , i - 1 , j ) ; } else if ( j > 0 && j < mat [ 0 ] . length - 1 && mat [ i ] [ j ] < mat [ i ] [ j - 1 ] ) { printPath ( mat , i , j - 1 ) ; } }"
517,"void printPath ( int [ ] [ ] mat , int i , int j ) { if ( mat . length == 0 || mat [ 0 ] . length == 0 ) { System . out . println ( ""Empty matrix"" ) ; return ; } System . out . println ( ""("" + i + "","" + j + "")"" ) ; int rightValue = i >= 0 && i < mat . length - 1 && mat [ i ] [ j ] < mat [ i + 1 ] [ j ] ? mat [ i + 1 ] [ j ] : mat [ i ] [ j ] ; int belowValue = j >= 0 && j < mat [ 0 ] . length - 1 && mat [ i ] [ j ] < mat [ i ] [ j + 1 ] ? mat [ i ] [ j + 1 ] : mat [ i ] [ j ] ; int aboveValue = i > 0 && i < mat . length - 1 && mat [ i ] [ j ] < mat [ i - 1 ] [ j ] ? mat [ i - 1 ] [ j ] : mat [ i ] [ j ] ; int leftValue = j > 0 && j < mat [ 0 ] . length - 1 && mat [ i ] [ j ] < mat [ i ] [ j - 1 ] ? mat [ i ] [ j - 1 ] : mat [ i ] [ j ] ; if ( rightValue > leftValue ) { if ( rightValue > belowValue ) { if ( rightValue > aboveValue ) { printPath ( mat , i + 1 , j ) ; } else { printPath ( mat , i , j + 1 ) ; } } else { if ( belowValue > aboveValue ) { printPath ( mat , i - 1 , j ) ; } else { printPath ( mat , i , j + 1 ) ; } } } else { if ( leftValue > belowValue ) { if ( leftValue > aboveValue ) { printPath ( mat , i - 1 , j ) ; } else { printPath ( mat , i , j + 1 ) ; } } else { if ( belowValue > aboveValue ) { printPath ( mat , i - 1 , j ) ; } else { printPath ( mat , i , j + 1 ) ; } } } }"
518,"void printTable ( String [ ] countries , int [ ] populations ) { if ( countries . length != 0 ) { int longestNameInput = countries [ 0 ] . length ( ) ; int longestPopInput = String . valueOf ( populations [ 0 ] ) . length ( ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { int countLength = countries [ i ] . length ( ) ; int popLength = String . valueOf ( populations [ i ] ) . length ( ) ; if ( countLength > longestNameInput ) longestNameInput = countLength ; if ( popLength > longestPopInput ) longestPopInput = popLength ; } for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . print ( countries [ i ] ) ; for ( int j = 0 ; j < ( longestNameInput - countries [ i ] . length ( ) ) ; j ++ ) System . out . print ( "" "" ) ; System . out . print ( "" | "" ) ; for ( int k = 0 ; k < ( longestPopInput - String . valueOf ( populations [ i ] ) . length ( ) ) ; k ++ ) System . out . print ( "" "" ) ; System . out . println ( populations [ i ] ) ; } } }"
519,"void printTable ( String [ ] countries , int [ ] populations ) { int defaultLength = 10 ; int maxCountryLength = stream ( countries ) . mapToInt ( String :: length ) . max ( ) . orElse ( defaultLength ) ; int maxPopulationLength = stream ( populations ) . mapToObj ( Integer :: toString ) . mapToInt ( String :: length ) . max ( ) . orElse ( defaultLength ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . format ( ""%-"" + maxCountryLength + ""s | %"" + maxPopulationLength + ""d\n"" , countries [ i ] , populations [ i ] ) ; } }"
520,int singleNumber ( int [ ] nums ) { int temp = 0 ; int answer = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { boolean flag = true ; temp = nums [ i ] ; for ( int j = 0 ; j < nums . length ; j ++ ) { if ( temp == nums [ j ] ) { if ( i != j ) { flag = false ; break ; } } } if ( flag == true ) { answer = temp ; } } return answer ; }
521,int singleNumber ( int [ ] nums ) { int answer = 0 ; ArrayList al = new ArrayList ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { al . add ( nums [ i ] ) ; } for ( int i = 0 ; i < nums . length ; i ++ ) { int test = nums [ i ] ; if ( al . indexOf ( test ) == al . lastIndexOf ( test ) ) { answer = nums [ i ] ; } } return answer ; }
522,void actionPerformed ( ActionEvent e ) { long duration = System . currentTimeMillis ( ) - startTime ; float progress = ( float ) duration / ( float ) RUN_TIME ; if ( progress > 1f ) { progress = 1f ; ( ( Timer ) e . getSource ( ) ) . stop ( ) ; } ballPoint = new Point ( ) ; ballPoint . x = getWidth ( ) / 2 ; ballPoint . y = Math . round ( getHeight ( ) * progress ) ; repaint ( ) ; }
523,void actionPerformed ( ActionEvent e ) { long duration = System . currentTimeMillis ( ) - startTime ; float progress = ( float ) duration / ( float ) RUN_TIME ; linePoint = new Point ( ) ; linePoint . x = getWidth ( ) / 2 ; if ( progress < 0.5f ) { linePoint . y = Math . round ( getHeight ( ) * ( progress * 2 ) ) ; } else { if ( progress > 1f ) { progress = 1f ; ( ( Timer ) e . getSource ( ) ) . stop ( ) ; linePoint = null ; ballPoint = null ; } else { linePoint . y = Math . round ( getHeight ( ) * ( progress * 2 ) ) ; linePoint . y = getHeight ( ) - ( linePoint . y - getHeight ( ) ) ; ballPoint . y = linePoint . y ; } } repaint ( ) ; }
524,void move ( Container container ) { if ( leftRight ) { x += deltaX ; if ( x >= canvasWidth ) { leftRight = false ; updateDelta ( ) ; } } else { x += - deltaX ; if ( x <= 0 ) { leftRight = true ; updateDelta ( ) ; } } if ( upDown ) { y += deltaY ; upDown = ! ( y >= ( canvasHeight ) ) ; if ( y >= ( canvasHeight ) ) { upDown = false ; updateDelta ( ) ; } } else { y += - deltaY ; if ( y <= 0 ) { upDown = true ; updateDelta ( ) ; } } }
525,void move ( Container container ) { if ( x >= canvasWidth || x <= 0 ) { deltaX = - 1 * deltaX ; } if ( y >= canvasHeight || y <= 0 ) { deltaY = - 1 * deltaY ; } x += deltaX ; y += deltaY ; }
526,"String replacer ( StringBuffer outBuffer ) { String data = outBuffer . toString ( ) ; try { StringBuffer tempBuffer = new StringBuffer ( ) ; int incrementor = 0 ; int dataLength = data . length ( ) ; while ( incrementor < dataLength ) { char charecterAt = data . charAt ( incrementor ) ; if ( charecterAt == '%' ) { tempBuffer . append ( ""<percentage>"" ) ; } else if ( charecterAt == '+' ) { tempBuffer . append ( ""<plus>"" ) ; } else { tempBuffer . append ( charecterAt ) ; } incrementor ++ ; } data = tempBuffer . toString ( ) ; data = URLDecoder . decode ( data , ""utf-8"" ) ; data = data . replaceAll ( ""<percentage>"" , ""%"" ) ; data = data . replaceAll ( ""<plus>"" , ""+"" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return data ; }"
527,"String replacer ( StringBuffer outBuffer ) { String data = outBuffer . toString ( ) ; try { data = data . replaceAll ( ""%(?![0-9a-fA-F]{2})"" , ""%25"" ) ; data = data . replaceAll ( ""\\+"" , ""%2B"" ) ; data = URLDecoder . decode ( data , ""utf-8"" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return data ; }"
528,"void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { if ( requestCode == mRequestCode ) { if ( grantResults . length > 0 ) { for ( int grantResult : grantResults ) { if ( grantResult != PackageManager . PERMISSION_GRANTED ) { mRequestPermissionListener . onFailed ( ) ; return ; } } mRequestPermissionListener . onSuccess ( ) ; } else { mRequestPermissionListener . onFailed ( ) ; } } }"
529,"void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; switch ( requestCode ) { case REQUEST_READ_PHONE_STATE : { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { Toast . makeText ( LoginActivity . this , ""Permission granted."" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; startActivity ( getIntent ( ) ) ; } else { Toast . makeText ( LoginActivity . this , ""The app was not allowed to get your phone state. Hence, it cannot function properly. Please consider granting it this permission"" , Toast . LENGTH_LONG ) . show ( ) ; } } case REQUEST_ACCESS_FINE_LOCATION : { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { Toast . makeText ( LoginActivity . this , ""Permission granted."" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; startActivity ( getIntent ( ) ) ; } else { Toast . makeText ( LoginActivity . this , ""The app was not allowed to get your location. Hence, it cannot function properly. Please consider granting it this permission"" , Toast . LENGTH_LONG ) . show ( ) ; } } case REQUEST_WRITE_STORAGE : { if ( grantResults . length > 0 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { Toast . makeText ( LoginActivity . this , ""Permission granted."" , Toast . LENGTH_SHORT ) . show ( ) ; finish ( ) ; startActivity ( getIntent ( ) ) ; } else { Toast . makeText ( LoginActivity . this , ""The app was not allowed to write to your storage. Hence, it cannot function properly. Please consider granting it this permission"" , Toast . LENGTH_LONG ) . show ( ) ; } } } }"
530,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( ""how many number you want to put in the pot?"" ) ; int num = input . nextInt ( ) ; int numbers [ ] = new int [ num ] ; for ( int i = 0 ; i < num ; i ++ ) { System . out . println ( ""number"" + i + "":"" ) ; numbers [ i ] = input . nextInt ( ) ; } for ( int temp : numbers ) { System . out . print ( temp + ""\t"" ) ; } input . close ( ) ; }"
531,"void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; Scanner stdin = new Scanner ( System . in ) ; do { System . out . println ( ""Current list is "" + list ) ; System . out . println ( ""Add more? (y/n)"" ) ; if ( stdin . next ( ) . startsWith ( ""y"" ) ) { System . out . println ( ""Enter : "" ) ; list . add ( stdin . next ( ) ) ; } else { break ; } } while ( true ) ; stdin . close ( ) ; System . out . println ( ""List is "" + list ) ; String [ ] arr = list . toArray ( new String [ 0 ] ) ; System . out . println ( ""Array is "" + Arrays . toString ( arr ) ) ; }"
532,"void main ( String [ ] args ) { try { File file = new File ( ""company.xml"" ) ; DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . parse ( file ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList nodeLst = doc . getElementsByTagName ( ""employee"" ) ; for ( int s = 0 ; s < nodeLst . getLength ( ) ; s ++ ) { Node fstNode = nodeLst . item ( s ) ; if ( fstNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element fstElmnt = ( Element ) fstNode ; NodeList fstNmElmntLst = fstElmnt . getElementsByTagName ( ""firstname"" ) ; Element fstNmElmnt = ( Element ) fstNmElmntLst . item ( 0 ) ; NodeList fstNm = fstNmElmnt . getChildNodes ( ) ; System . out . println ( ""First Name: "" + ( ( Node ) fstNm . item ( 0 ) ) . getNodeValue ( ) ) ; NodeList lstNmElmntLst = fstElmnt . getElementsByTagName ( ""lastname"" ) ; Element lstNmElmnt = ( Element ) lstNmElmntLst . item ( 0 ) ; NodeList lstNm = lstNmElmnt . getChildNodes ( ) ; System . out . println ( ""Last Name: "" + ( ( Node ) lstNm . item ( 0 ) ) . getNodeValue ( ) ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
533,"void main ( String [ ] args ) { List < String > keywords = Arrays . asList ( ""Apple"" , ""Ananas"" , ""Mango"" , ""Banana"" , ""Beer"" ) ; Map < Character , List < String > > result = new HashMap < Character , List < String > > ( ) ; for ( String k : keywords ) { char firstChar = k . charAt ( 0 ) ; if ( ! result . containsKey ( firstChar ) ) { result . put ( firstChar , new ArrayList < String > ( ) ) ; } result . get ( firstChar ) . add ( k ) ; } for ( List < String > list : result . values ( ) ) { Collections . sort ( list ) ; } System . out . println ( result ) ; }"
534,void main ( String [ ] args ) throws Exception { ObservableList < Integer > olist = new ObservableList < > ( ) ; olist . getObservable ( ) . subscribe ( System . out :: println ) ; olist . add ( 1 ) ; Thread . sleep ( 1000 ) ; olist . add ( 2 ) ; Thread . sleep ( 1000 ) ; olist . add ( 3 ) ; }
535,"void main ( String [ ] args ) { List < Integer > initialNumbers = new ArrayList < Integer > ( ) ; initialNumbers . add ( 1 ) ; initialNumbers . add ( 2 ) ; Observable < Integer > observableInitial = Observable . from ( initialNumbers ) ; ReplaySubject < Integer > subject = ReplaySubject . create ( ) ; Observable < Integer > source = Observable . merge ( observableInitial , subject ) ; source . subscribe ( System . out :: println ) ; for ( int i = 0 ; i < 100 ; ++ i ) { subject . onNext ( i ) ; } }"
536,"void start ( Stage primaryStage ) { ProgressData vb1 = new ProgressData ( ""Progressbar 1"" , - 1 ) ; ProgressData vb2 = new ProgressData ( ""Progressbar 2"" , 0.2 ) ; ProgressData vb3 = new ProgressData ( ""Progressbar 3"" , 0.3 ) ; TextChooser textChooser = new TextChooser ( vb1 , vb2 , vb3 ) ; textChooser . setStyle ( ""-fx-font: 10px \""Verdana\"";"" ) ; StackPane root = new StackPane ( ) ; root . getChildren ( ) . add ( textChooser ) ; Scene scene = new Scene ( root , 300 , 250 ) ; primaryStage . setTitle ( ""Hello World!"" ) ; primaryStage . setScene ( scene ) ; primaryStage . show ( ) ; }"
537,"void start ( Stage primaryStage ) { double y1 = 15 ; ProgressBar p1 = new ProgressBar ( ) ; p1 . setLayoutY ( y1 ) ; HBox vb1 = new HBox ( 10 ) ; vb1 . getChildren ( ) . addAll ( new Label ( ""Progressbar 1"" ) , p1 ) ; double y2 = 15 ; ProgressBar p2 = new ProgressBar ( ) ; p2 . setLayoutY ( y2 ) ; HBox vb2 = new HBox ( 10 ) ; vb2 . getChildren ( ) . addAll ( new Label ( ""Progressbar 2"" ) , p2 ) ; double y3 = 15 ; ProgressBar p3 = new ProgressBar ( ) ; p3 . setLayoutY ( y3 ) ; HBox vb3 = new HBox ( 10 ) ; vb3 . getChildren ( ) . addAll ( new Label ( ""Progressbar 3"" ) , p3 ) ; TextChooser textChooser = new TextChooser ( vb1 , vb2 , vb3 ) ; textChooser . setStyle ( ""-fx-font: 10px \""Verdana\"";"" ) ; StackPane root = new StackPane ( ) ; root . getChildren ( ) . add ( textChooser ) ; Scene scene = new Scene ( root , 300 , 250 ) ; primaryStage . setTitle ( ""Hello World!"" ) ; primaryStage . setScene ( scene ) ; primaryStage . show ( ) ; }"
538,"boolean contains ( String a , String b ) { String temp = b ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { temp = temp . replaceFirst ( Pattern . quote ( a . substring ( i , i + 1 ) ) , """" ) ; if ( b . length ( ) - temp . length ( ) != i + 1 ) return false ; } return true ; }"
539,"boolean contains ( String a , String b ) { int diff = a . length ( ) - b . length ( ) ; while ( a . length ( ) > 0 ) { b = b . replace ( a . substring ( 0 , 1 ) , """" ) ; a = a . replace ( a . substring ( 0 , 1 ) , """" ) ; if ( diff != a . length ( ) - b . length ( ) ) return false ; } return true ; }"
540,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
541,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
542,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Time (s)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; drawRotate ( gg , getWidth ( ) , ( getHeight ( ) + width ) / 2 , 270 , string ) ; }"
543,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
544,"Object next ( ) throws NoSuchElementException { formNextPermutation ( ) ; int i = size - 1 ; while ( permutation [ i ] > permutation [ i + 1 ] ) i -- ; if ( i == 0 ) { next = false ; for ( int j = 0 ; j < size + 1 ; j ++ ) { permutation [ j ] = j ; } return ar ; } int j = size ; while ( permutation [ i ] > permutation [ j ] ) j -- ; swap ( i , j ) ; int r = size ; int s = i + 1 ; while ( r > s ) { swap ( r , s ) ; r -- ; s ++ ; } return ar ; }"
545,"E [ ] next ( ) { if ( ! has_next ) throw new NoSuchElementException ( ) ; for ( int i = 0 ; i < ind . length ; i ++ ) { output [ i ] = arr [ ind [ i ] ] ; } has_next = false ; for ( int tail = ind . length - 1 ; tail > 0 ; tail -- ) { if ( ind [ tail - 1 ] < ind [ tail ] ) { int s = ind . length - 1 ; while ( ind [ tail - 1 ] >= ind [ s ] ) s -- ; swap ( ind , tail - 1 , s ) ; for ( int i = tail , j = ind . length - 1 ; i < j ; i ++ , j -- ) { swap ( ind , i , j ) ; } has_next = true ; break ; } } return output ; }"
546,"void main ( String args [ ] ) { FileReader fr = null ; FileWriter fw = null ; try { fr = new FileReader ( ""1.txt"" ) ; fw = new FileWriter ( ""2.txt"" ) ; int c = fr . read ( ) ; while ( c != - 1 ) { fw . write ( c ) ; c = fr . read ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { close ( fr ) ; close ( fw ) ; } }"
547,"void main ( String [ ] args ) throws IOException { File dir = new File ( ""."" ) ; String source = dir . getCanonicalPath ( ) + File . separator + ""Code.txt"" ; String dest = dir . getCanonicalPath ( ) + File . separator + ""Dest.txt"" ; File fin = new File ( source ) ; FileInputStream fis = new FileInputStream ( fin ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( fis ) ) ; FileWriter fstream = new FileWriter ( dest , true ) ; BufferedWriter out = new BufferedWriter ( fstream ) ; String aLine = null ; while ( ( aLine = in . readLine ( ) ) != null ) { out . write ( aLine ) ; out . newLine ( ) ; } in . close ( ) ; out . close ( ) ; }"
548,"void run ( ) { try { writeLatch . await ( ) ; map . put ( 150 , 150 ) ; readLatch . countDown ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } }"
549,"void run ( ) { for ( int i = 0 ; ; i ++ ) { if ( i % 1000 == 0 ) { System . out . printf ( ""get: %d\n"" , i ) ; } Map < K , String > m2 = new HashMap < > ( map ) ; } }"
550,"void main ( String args [ ] ) throws Exception { out . println ( ""****************************************"" ) ; out . println ( ""DATE INFO"" ) ; printCurrentTime ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""JVM COMMAND LINE ARGUMENTS"" ) ; printCommandLineArguments ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""ENVIRONMENT"" ) ; printSystemEnvironment ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""SYSTEM PROPERTIES"" ) ; printSystemProperties ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""CLASS LOADER"" ) ; printClassLoaderInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""OPERATING SYSTEM"" ) ; printOSInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""MEMORY"" ) ; printRuntimeMemory ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""CPU"" ) ; printCPUUsage ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""DISK"" ) ; printDiskInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""NETWORK"" ) ; printNetworkInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""SECURITY"" ) ; printSecurityInfo ( ) ; out . println ( """" ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""LOG"" ) ; printLoggingInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""KEY MANAGER"" ) ; printKeyManagerInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""DISPLAY DEVICES"" ) ; printDisplayInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""FONTS"" ) ; printFontsInfo ( ) ; out . println ( """" ) ; out . println ( ""****************************************"" ) ; out . println ( ""LOCALES"" ) ; printLocaleInfo ( ) ; }"
551,"void main ( String [ ] args ) { Runnable r = ( ) -> { MediaTypes mediaTypes = new MediaTypes ( ) ; JPanel p = new JPanel ( ) ; mediaTypes . createGui ( p ) ; JOptionPane . showMessageDialog ( null , p ) ; } ; SwingUtilities . invokeLater ( r ) ; }"
552,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
553,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
554,"void main ( String [ ] args ) { String s = ""aaaabbccccdddeee"" ; String s1 = """" ; String s2 = """" ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s1 . indexOf ( s . charAt ( i ) ) < 0 ) { s1 = s1 + s . charAt ( i ) ; } } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s1 . charAt ( i ) == s . charAt ( j ) ) { count ++ ; } } s2 = s2 + s1 . charAt ( i ) + count ; count = 0 ; } System . out . println ( s2 ) ; }"
555,"void main ( String args [ ] ) { inp = new Scanner ( System . in ) ; String str = inp . nextLine ( ) ; List < Character > arrlist = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arrlist . add ( str . charAt ( i ) ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int freq = Collections . frequency ( arrlist , str . charAt ( i ) ) ; System . out . println ( ""Frequency of "" + str . charAt ( i ) + ""  is:   "" + freq ) ; } }"
556,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
557,XSSFFont transform ( HSSFFont fontOld ) { XSSFFont fontNew = this . workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }
558,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
559,"void transform ( ) { String call = ""transform "" ; System . out . println ( call + ""Workbook"" ) ; XSSFSheet sheetNew ; HSSFSheet sheetOld ; this . workbookNew . setForceFormulaRecalculation ( this . workbookOld . getForceFormulaRecalculation ( ) ) ; this . workbookNew . setMissingCellPolicy ( this . workbookOld . getMissingCellPolicy ( ) ) ; for ( int i = 0 ; i < this . workbookOld . getNumberOfSheets ( ) ; i ++ ) { sheetOld = this . workbookOld . getSheetAt ( i ) ; sheetNew = this . workbookNew . getSheet ( sheetOld . getSheetName ( ) ) ; System . out . println ( call + ""Sheet erstellt: "" + sheetOld . getSheetName ( ) ) ; sheetNew = this . workbookNew . createSheet ( sheetOld . getSheetName ( ) ) ; this . transform ( sheetOld , sheetNew ) ; } System . out . println ( call + ""Anzahl verwendeter Styles: "" + this . styleMap . size ( ) ) ; System . out . println ( call + ""abgeschlossen"" ) ; }"
560,"void main ( String [ ] args ) throws TwilioRestException { TwilioRestClient client = new TwilioRestClient ( ACCOUNT_SID , AUTH_TOKEN ) ; List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ; params . add ( new BasicNameValuePair ( ""Body"" , ""Test Twilio message"" ) ) ; params . add ( new BasicNameValuePair ( ""To"" , ""+14159352345"" ) ) ; params . add ( new BasicNameValuePair ( ""From"" , ""+14158141829"" ) ) ; MessageFactory messageFactory = client . getAccount ( ) . getMessageFactory ( ) ; Message message = messageFactory . create ( params ) ; System . out . println ( message . getSid ( ) ) ; }"
561,"void main ( String args [ ] ) { GSMConnect gsm = new GSMConnect ( comPort ) ; if ( gsm . init ( ) ) { try { System . out . println ( ""Initialization Success"" ) ; gsm . connect ( ) ; Thread . sleep ( 5000 ) ; gsm . checkStatus ( ) ; Thread . sleep ( 5000 ) ; gsm . sendMessage ( ""+91XXXXXXXX"" , ""Trial Success"" ) ; Thread . sleep ( 1000 ) ; gsm . hangup ( ) ; Thread . sleep ( 1000 ) ; gsm . closePort ( ) ; gsm . outCommand ( ) ; System . exit ( 1 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { System . out . println ( ""Can't init this card"" ) ; } }"
562,"void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { jgen . writeStartObject ( ) ; JavaType javaType = provider . constructType ( CustomClass . class ) ; BeanDescription beanDesc = provider . getConfig ( ) . introspect ( javaType ) ; JsonSerializer < Object > serializer = BeanSerializerFactory . instance . findBeanSerializer ( provider , javaType , beanDesc ) ; serializer . unwrappingSerializer ( null ) . serialize ( value , jgen , provider ) ; jgen . writeObjectField ( ""my_extra_field"" , ""some data"" ) ; jgen . writeEndObject ( ) ; }"
563,"void serialize ( Test value , JsonGenerator jgen , SerializerProvider provider ) throws IOException , JsonProcessingException { jgen . writeStartObject ( ) ; Field [ ] fields = value . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { try { jgen . writeObjectField ( field . getName ( ) , field . get ( value ) ) ; } catch ( IllegalArgumentException | IllegalAccessException e ) { e . printStackTrace ( ) ; } } jgen . writeObjectField ( ""extra_field"" , ""whatever_value"" ) ; jgen . writeEndObject ( ) ; }"
564,"void main ( String [ ] args ) { int n = 7 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( i + j <= n - 4 || j == 0 || i == n - 1 ) System . out . print ( ""*"" ) ; else if ( i - j >= n - 4 ) System . out . print ( ""*"" ) ; else System . out . print ( "" "" ) ; } System . out . println ( ) ; } }"
565,"void main ( String [ ] args ) { for ( int row = 1 ; row <= 7 ; row += 2 ) { for ( int space = 7 ; space >= row ; space -= 2 ) { System . out . print ( ""*"" ) ; } for ( int i = 1 ; i <= row ; i ++ ) { System . out . print ( "" "" ) ; } System . out . print ( ""\n"" ) ; } for ( int row = 5 ; row >= 1 ; row -= 2 ) { for ( int space = 7 ; space >= row ; space -= 2 ) { System . out . print ( ""*"" ) ; } for ( int i = 1 ; i <= row ; i ++ ) { System . out . print ( "" "" ) ; } System . out . print ( ""\n"" ) ; } }"
566,"void main ( String [ ] args ) { HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; System . out . println ( ""Enter an String:"" ) ; Scanner sc = new Scanner ( System . in ) ; String s1 = sc . nextLine ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! hm . containsKey ( s1 . charAt ( i ) ) ) { hm . put ( s1 . charAt ( i ) , ( Integer ) 1 ) ; } else { hm . put ( s1 . charAt ( i ) , hm . get ( s1 . charAt ( i ) ) + 1 ) ; } } System . out . println ( ""The Charecters are:"" + hm ) ; }"
567,"void main ( String [ ] args ) { String test = ""The quick brown fox jumped over the lazy dog."" ; int countA = 0 , countO = 0 , countSpace = 0 , countDot = 0 ; for ( int i = 0 ; i < test . length ( ) ; i ++ ) { switch ( test . charAt ( i ) ) { case 'a' : case 'A' : countA ++ ; break ; case 'o' : case 'O' : countO ++ ; break ; case ' ' : countSpace ++ ; break ; case '.' : countDot ++ ; break ; } } System . out . printf ( ""%s%d%n%s%d%n%s%d%n%s%d"" , ""A: "" , countA , ""O: "" , countO , ""Space: "" , countSpace , ""Dot: "" , countDot ) ; }"
568,"String myTrim ( String input , String list ) { StringBuilder result = new StringBuilder ( ) ; char c ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { c = input . charAt ( i ) ; if ( list . indexOf ( c ) < 0 ) result . append ( c ) ; } return result . toString ( ) ; }"
569,"String myTrim ( String input , String list ) { String r = """" ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { int k = 0 ; for ( ; k < list . length ( ) ; k ++ ) { if ( input . charAt ( i ) == list . charAt ( k ) ) { break ; } } if ( k == list . length ( ) ) r += input . charAt ( i ) ; } return r ; }"
570,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ! s1 . contains ( """" + s2 . charAt ( i ) ) ) { return false ; } s1 = s1 . replaceFirst ( """" + s2 . charAt ( i ) , """" ) ; s2 = s2 . replaceFirst ( """" + s2 . charAt ( i ) , """" ) ; } return true ; }"
571,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; char [ ] c1 = s1 . toCharArray ( ) ; char [ ] c2 = s2 . toCharArray ( ) ; Arrays . sort ( c1 ) ; Arrays . sort ( c2 ) ; String sc1 = new String ( c1 ) ; String sc2 = new String ( c2 ) ; return sc1 . equals ( sc2 ) ; }"
572,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String replacement = source . subSequence ( start , end ) . toString ( ) ; String newVal = dest . subSequence ( 0 , dstart ) . toString ( ) + replacement + dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; Matcher matcher = mPattern . matcher ( newVal ) ; if ( matcher . matches ( ) ) return null ; if ( TextUtils . isEmpty ( source ) ) return dest . subSequence ( dstart , dend ) ; else return """" ; }"
573,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String lsStart = """" ; String lsInsert = """" ; String lsEnd = """" ; String lsText = """" ; Log . d ( ""debug"" , moPattern . toString ( ) ) ; Log . d ( ""debug"" , ""source: "" + source + "", start: "" + start + "", end:"" + end + "", dest: "" + dest + "", dstart: "" + dstart + "", dend: "" + dend ) ; lsText = dest . toString ( ) ; if ( lsText . length ( ) > 0 ) { lsStart = lsText . substring ( 0 , dstart ) ; Log . d ( ""debug"" , ""lsStart : "" + lsStart ) ; if ( source != """" ) { lsInsert = source . toString ( ) ; Log . d ( ""debug"" , ""lsInsert: "" + lsInsert ) ; } lsEnd = lsText . substring ( dend ) ; Log . d ( ""debug"" , ""lsEnd   : "" + lsEnd ) ; lsText = lsStart + lsInsert + lsEnd ; Log . d ( ""debug"" , ""lsText  : "" + lsText ) ; } Matcher loMatcher = moPattern . matcher ( lsText ) ; Log . d ( ""debug"" , ""loMatcher.matches(): "" + loMatcher . matches ( ) + "", lsText: "" + lsText ) ; if ( ! loMatcher . matches ( ) ) { return """" ; } return null ; }"
574,"boolean hasDateExpired ( int days , Instant savedDate , Instant currentDate ) { boolean hasExpired = false ; if ( savedDate != null && currentDate != null ) { if ( savedDate . plus ( days , ChronoUnit . DAYS ) . isBefore ( currentDate ) ) { hasExpired = true ; } } return hasExpired ; }"
575,"boolean hasDateExpired ( int days , java . util . Date savedDate ) throws ParseException { SimpleDateFormat dateFormatUtc = new SimpleDateFormat ( ""yyyy-MMM-dd HH:mm:ss"" ) ; dateFormatUtc . setTimeZone ( TimeZone . getTimeZone ( ""UTC"" ) ) ; SimpleDateFormat dateFormatLocal = new SimpleDateFormat ( ""yyyy-MMM-dd HH:mm:ss"" ) ; savedDate = dateFormatLocal . parse ( dateFormatUtc . format ( savedDate ) ) ; Date dateTimeNow = dateFormatLocal . parse ( dateFormatUtc . format ( new Date ( ) ) ) ; long expires = dateTimeNow . getTime ( ) + ( DAY_IN_MS * days ) ; Date expiresDate = new Date ( expires ) ; System . out . println ( ""savedDate \t\t"" + savedDate + ""\nexpiresDate \t"" + expiresDate ) ; return savedDate . before ( expiresDate ) ; }"
576,"void main ( String [ ] args ) { String str = ""abcdabghplhhnfl"" . toLowerCase ( ) ; Integer [ ] ar = new Integer [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = str . charAt ( i ) - 'a' ; if ( ar [ j ] == null ) { ar [ j ] = 1 ; } else { ar [ j ] += 1 ; } } for ( int i = 0 ; i < ar . length ; i ++ ) { if ( ar [ i ] != null && ar [ i ] > 1 ) { char c = ( char ) ( 97 + i ) ; System . out . println ( ""'"" + c + ""' comes "" + ar [ i ] + "" times."" ) ; } } }"
577,"void main ( String [ ] args ) throws IOException { String ch ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter the Statement:"" ) ; ch = br . readLine ( ) ; int count = 0 , len = 0 ; do { try { char name [ ] = ch . toCharArray ( ) ; len = name . length ; count = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( ( name [ 0 ] == name [ j ] ) && ( ( name [ 0 ] >= 65 && name [ 0 ] <= 91 ) || ( name [ 0 ] >= 97 && name [ 0 ] <= 123 ) ) ) count ++ ; } if ( count != 0 ) System . out . println ( name [ 0 ] + "" "" + count + "" Times"" ) ; ch = ch . replace ( """" + name [ 0 ] , """" ) ; } catch ( Exception ex ) { } } while ( len != 1 ) ; }"
578,"void main ( String args [ ] ) { String s1 = new String ( ""Test"" ) ; String s2 = new String ( ""Test"" ) ; System . out . println ( ""\n1 - PRIMITIVES "" ) ; System . out . println ( s1 == s2 ) ; System . out . println ( s1 . equals ( s2 ) ) ; A a1 = new A ( ) ; A a2 = new A ( ) ; System . out . println ( ""\n2 - OBJECT TYPES / STATIC VARIABLE"" ) ; System . out . println ( a1 == a2 ) ; System . out . println ( a1 . s == a2 . s ) ; System . out . println ( a1 . s . equals ( a2 . s ) ) ; B b1 = new B ( ) ; B b2 = new B ( ) ; System . out . println ( ""\n3 - OBJECT TYPES / NON-STATIC VARIABLE"" ) ; System . out . println ( b1 == b2 ) ; System . out . println ( b1 . getS ( ) == b2 . getS ( ) ) ; System . out . println ( b1 . getS ( ) . equals ( b2 . getS ( ) ) ) ; }"
579,"void main ( String [ ] args ) { String s1 = ""Cat"" ; String s2 = ""Cat"" ; String s3 = new String ( ""Cat"" ) ; if ( s1 == s2 ) { System . out . println ( ""true"" ) ; } else { System . out . println ( ""false"" ) ; } if ( s1 == s3 ) { System . out . println ( ""true"" ) ; } else { System . out . println ( ""false"" ) ; } if ( s1 . equals ( s3 ) ) { System . out . println ( ""true"" ) ; } else { System . out . println ( ""False"" ) ; } }"
580,"void insertNodeAfter ( E nVal , E curVal ) { Node < E > newNode = new Node < E > ( nVal ) ; Node < E > curr = head ; while ( curr != null ) { if ( curr . getNodeValue ( ) . equals ( curVal ) ) { newNode . setNext ( curr . getNext ( ) ) ; curr . setNext ( newNode ) ; break ; } else { curr = curr . getNext ( ) ; } } }"
581,"void insertNodeAfter ( E nVal , E curVal ) { Node < E > prev = findPrevOf ( curVal ) ; Node < E > curr = null ; if ( prev == null ) { curr = head ; } else { curr = prev . getNext ( ) ; } Node < E > newNode = new Node < E > ( nVal ) ; insert ( curr , ( curr == null ? curr : curr . getNext ( ) ) , newNode ) ; }"
582,"void run ( ) { int i = 1 ; while ( i < 50 ) { while ( s . getState ( ) != 3 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 3 ) System . out . println ( ""t1 "" + i ) ; s . setState ( 1 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
583,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tic"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
584,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
585,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
586,void shuffleArray ( int [ ] ar ) { Random rnd = ThreadLocalRandom . current ( ) ; for ( int i = ar . length - 1 ; i > 0 ; i -- ) { int index = rnd . nextInt ( i + 1 ) ; int a = ar [ index ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } }
587,void shuffleArray ( int [ ] array ) { List < Integer > list = new ArrayList < > ( ) ; for ( int i : array ) { list . add ( i ) ; } Collections . shuffle ( list ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { array [ i ] = list . get ( i ) ; } }
588,"String getInput ( String file ) { StringBuilder ret = new StringBuilder ( ) ; String buf ; BufferedReader inFile = null ; try { inFile = new BufferedReader ( new FileReader ( filename ) ) ; while ( buf = inFile . readLine ( ) ) ret . append ( buf ) ; } catch ( FileNotFoundException e ) { ret . append ( ""Couldn't find "" + file ) ; } catch ( IOException e ) { ret . append ( ""There was an error reading the file."" ) ; } finally { if ( inFile != null ) { try { inFile . close ( ) ; } catch ( IOException aargh ) { } } } return ret . toString ( ) ; }"
589,String getInput ( String filename ) { BufferedReader infile = null ; try { infile = new BufferedReader ( new FileReader ( filename ) ) ; String response = infile . readLine ( ) ; return response ; } catch ( IOException e ) { } finally { try { infile . close ( ) ; } catch ( IOException e ) { } } return null ; }
590,"void main ( String ... argv ) throws ClassNotFoundException { Class < Foo > fooClass = loadClass ( ) ; initializeClass ( fooClass ) ; URLClassLoader myClassLoader = ( ( URLClassLoader ) InitializeClassMultipleTimes . class . getClassLoader ( ) ) ; URL [ ] urls = myClassLoader . getURLs ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { URLClassLoader newClassLoader = new URLClassLoader ( urls , null ) ; System . out . format ( ""%nLoading class using another class loader%n"" , Foo . class . getSimpleName ( ) ) ; Class < ? > fooClassAgain = Class . forName ( fooClass . getName ( ) , false , newClassLoader ) ; initializeClass ( fooClassAgain ) ; } }"
591,"void main ( String [ ] args ) { CustomClassLoader loader = new CustomClassLoader ( ) ; try { Class < ? > c = loader . findClass ( ""sample.Sample"" ) ; Object o = c . newInstance ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } }"
592,"void main ( String [ ] args ) throws InterruptedException , ExecutionException { CompletableFuture < String > contentsCF = readPage ( ) ; CompletableFuture < List < String > > linksCF = contentsCF . thenApply ( CompletableFutureTest :: getLinks ) ; CompletableFuture < Void > completionStage = linksCF . thenAccept ( list -> { String a = null ; System . out . println ( a . toString ( ) ) ; } ) ; List < String > result = linksCF . get ( ) ; System . out . println ( ""Got "" + result ) ; try { completionStage . get ( ) ; } catch ( ExecutionException e ) { System . out . println ( ""Caught "" + e ) ; Throwable cause = e . getCause ( ) ; System . out . println ( ""cause: "" + cause ) ; } completionStage . exceptionally ( e -> { System . out . println ( ""Future exceptionally finished: "" + e ) ; return null ; } ) ; try { completionStage . get ( ) ; } catch ( Throwable t ) { System . out . println ( ""Already handled by the future "" + t ) ; } }"
593,"void main ( String [ ] args ) throws InterruptedException , ExecutionException { CompletableFuture < String > future = readPage ( ) ; CompletableFuture < Void > future2 = future . thenAccept ( page -> { System . out . println ( page ) ; throw new IllegalArgumentException ( ""unexpected exception"" ) ; } ) ; future2 . exceptionally ( e -> { e . printStackTrace ( System . err ) ; return null ; } ) ; }"
594,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
595,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
596,"void main ( String [ ] args ) { String scaleOne ; String scaleTwo ; System . out . println ( ""What scale is your temp currently in?\n"" + ""1: Fahrenheit\n"" + ""2: Celsius\n"" + ""3: Kelvin\n"" + ""Please enter 1, 2, or 3: \n"" ) ; scaleOne = getScale ( ) ; System . out . println ( ""What scale would you like to convert to?\n"" + ""1: Fahrenheit\n"" + ""2: Celsius\n"" + ""3: Kelvin\n"" + ""Please enter 1, 2, or 3:\n "" ) ; scaleTwo = getScale ( ) ; System . out . print ( ""Your final temp is: "" + convert ( scaleOne , scaleTwo ) ) ; }"
597,"void main ( String [ ] args ) { char cont = 'E' ; do { temp1 = getTemp ( ) ; scale1 = scaleOne ( ) ; scale2 = toScale ( ) ; System . out . print ( ""Your final temp is: "" + convert ( ) + ' ' + scale2 ) ; } while ( cont == 'N' ) ; }"
598,"void run ( ) { while ( appRunning ) { System . out . println ( ""App running..."" ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } if ( pause > 0 ) { System . out . println ( ""App pausing for "" + pause + "" ms"" ) ; try { Thread . sleep ( pause ) ; } catch ( InterruptedException e ) { } pause = 0 ; } } }"
599,"void run ( ) { { System . out . println ( ""New Communication Thread Started"" ) ; try { PrintWriter out = new PrintWriter ( clientSocket . getOutputStream ( ) , true ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( clientSocket . getInputStream ( ) ) ) ; String inputLine ; while ( ( inputLine = in . readLine ( ) ) != null ) { System . out . println ( ""Received: "" + inputLine ) ; try { long pauseCommand = Long . parseLong ( inputLine ) ; pause = pauseCommand ; out . println ( ""OK, pausing for "" + inputLine + "" ms"" ) ; } catch ( NumberFormatException e ) { } if ( inputLine . equals ( ""BYE"" ) ) { out . println ( ""OK, bye!"" ) ; break ; } if ( inputLine . equals ( ""STOP"" ) ) { out . println ( ""OK, stopping!"" ) ; System . exit ( 1 ) ; } } out . close ( ) ; in . close ( ) ; clientSocket . close ( ) ; } catch ( IOException e ) { System . err . println ( ""Problem with Communication Server"" ) ; System . exit ( 1 ) ; } } }"
600,"void draw ( Graphics2D g , int width , int height ) { g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , width , height ) ; for ( Arrow arrow : arrows ) { g . setColor ( Color . ORANGE ) ; g . fillRect ( 350 , 20 , 20 , 280 ) ; g . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_BEVEL ) ) ; g . translate ( 0 , 60 ) ; arrow . draw ( g ) ; g . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER ) ) ; g . translate ( 0 , 100 ) ; arrow . draw ( g ) ; g . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_ROUND ) ) ; g . translate ( 0 , 100 ) ; arrow . draw ( g ) ; g . translate ( 400 , - 260 ) ; } }"
601,"void draw ( Graphics2D g ) { float arrowRatio = 0.5f ; float arrowLength = 80.0f ; BasicStroke stroke = ( BasicStroke ) g . getStroke ( ) ; float endX = 350.0f ; float veeX ; switch ( stroke . getLineJoin ( ) ) { case BasicStroke . JOIN_BEVEL : veeX = endX - stroke . getLineWidth ( ) * 0.25f ; break ; default : case BasicStroke . JOIN_MITER : veeX = endX - stroke . getLineWidth ( ) * 0.5f / arrowRatio ; break ; case BasicStroke . JOIN_ROUND : veeX = endX - stroke . getLineWidth ( ) * 0.5f ; break ; } Path2D . Float path = new Path2D . Float ( ) ; path . moveTo ( veeX - arrowLength , - arrowRatio * arrowLength ) ; path . lineTo ( veeX , 0.0f ) ; path . lineTo ( veeX - arrowLength , arrowRatio * arrowLength ) ; g . setColor ( Color . BLUE ) ; g . draw ( path ) ; g . setColor ( Color . YELLOW ) ; g . draw ( new Line2D . Float ( 50.0f , 0.0f , veeX , 0.0f ) ) ; g . setColor ( Color . RED ) ; g . draw ( new Line2D . Float ( 50.0f , 0.0f , veeX - stroke . getLineWidth ( ) * 0.25f , 0.0f ) ) ; }"
602,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int [ ] seen = new int [ 256 ] ; Arrays . fill ( seen , 0 ) ; s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { seen [ s1 . charAt ( i ) ] = seen [ s1 . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( seen [ s2 . charAt ( i ) ] == 0 ) return false ; seen [ s2 . charAt ( i ) ] = seen [ s2 . charAt ( i ) ] - 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( seen [ i ] != 0 ) return false ; } return true ; }"
603,"boolean isAnagram ( String s1 , String s2 ) { StringBuilder sb1 = new StringBuilder ( ) ; StringBuilder sb2 = new StringBuilder ( ) ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; char arr1 [ ] = s1 . toCharArray ( ) ; char arr2 [ ] = s2 . toCharArray ( ) ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( char c : arr1 ) { sb1 . append ( c ) ; } for ( char c : arr2 ) { sb2 . append ( c ) ; } System . out . println ( sb1 . toString ( ) ) ; System . out . println ( sb2 . toString ( ) ) ; if ( sb1 . toString ( ) . equals ( sb2 . toString ( ) ) ) return true ; else return false ; }"
604,"void main ( String [ ] args ) throws ParseException { String month = ""08"" ; String day = ""05"" ; String year = ""2015"" ; String inputDateStr = String . format ( ""%s/%s/%s"" , day , month , year ) ; Date inputDate = new SimpleDateFormat ( ""dd/MM/yyyy"" ) . parse ( inputDateStr ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( inputDate ) ; String dayOfWeek = calendar . getDisplayName ( Calendar . DAY_OF_WEEK , Calendar . LONG , Locale . US ) . toUpperCase ( ) ; System . out . println ( dayOfWeek ) ; }"
605,"void main ( String [ ] args ) throws ParseException , ParseException { anchorDaysMap . put ( Integer . valueOf ( 0 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1700 ) ) ; add ( Integer . valueOf ( 2100 ) ) ; add ( Integer . valueOf ( 2500 ) ) ; } } ) ; anchorDaysMap . put ( Integer . valueOf ( 2 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1600 ) ) ; add ( Integer . valueOf ( 2000 ) ) ; add ( Integer . valueOf ( 2400 ) ) ; } } ) ; anchorDaysMap . put ( Integer . valueOf ( 3 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1500 ) ) ; add ( Integer . valueOf ( 1900 ) ) ; add ( Integer . valueOf ( 2300 ) ) ; } } ) ; anchorDaysMap . put ( Integer . valueOf ( 5 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1800 ) ) ; add ( Integer . valueOf ( 2200 ) ) ; add ( Integer . valueOf ( 2600 ) ) ; } } ) ; doomsdayDate . put ( Integer . valueOf ( 1 ) , Integer . valueOf ( 3 ) ) ; doomsdayDate . put ( Integer . valueOf ( 2 ) , Integer . valueOf ( 14 ) ) ; doomsdayDate . put ( Integer . valueOf ( 3 ) , Integer . valueOf ( 14 ) ) ; doomsdayDate . put ( Integer . valueOf ( 4 ) , Integer . valueOf ( 4 ) ) ; doomsdayDate . put ( Integer . valueOf ( 5 ) , Integer . valueOf ( 9 ) ) ; doomsdayDate . put ( Integer . valueOf ( 6 ) , Integer . valueOf ( 6 ) ) ; doomsdayDate . put ( Integer . valueOf ( 7 ) , Integer . valueOf ( 4 ) ) ; doomsdayDate . put ( Integer . valueOf ( 8 ) , Integer . valueOf ( 8 ) ) ; doomsdayDate . put ( Integer . valueOf ( 9 ) , Integer . valueOf ( 5 ) ) ; doomsdayDate . put ( Integer . valueOf ( 10 ) , Integer . valueOf ( 10 ) ) ; doomsdayDate . put ( Integer . valueOf ( 11 ) , Integer . valueOf ( 7 ) ) ; doomsdayDate . put ( Integer . valueOf ( 12 ) , Integer . valueOf ( 12 ) ) ; long time = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100000 ; i ++ ) { int year = 1583 + new Random ( ) . nextInt ( 500 ) ; int month = 1 + new Random ( ) . nextInt ( 12 ) ; int day = 1 + new Random ( ) . nextInt ( 7 ) ; int twoDigitsYear = ( year % 100 ) ; int century = year - twoDigitsYear ; int adForCentury = getADCentury ( century ) ; int dd = ( ( int ) twoDigitsYear / 12 ) + twoDigitsYear % 12 + ( int ) ( ( twoDigitsYear % 12 ) / 4 ) ; int referenceDay = doomsdayDate . get ( month ) ; int gap = ( day - referenceDay ) % 7 ; int result = ( gap + adForCentury + dd ) % 7 ; if ( result < 0 ) { result *= - 1 ; } String dayDate = weekdays [ ( result + 1 ) % 8 ] ; } System . out . println ( ""time (ms) : "" + ( System . currentTimeMillis ( ) - time ) ) ; time = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100000 ; i ++ ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( new SimpleDateFormat ( ""dd/MM/yyyy"" ) . parse ( ""12/04/1861"" ) ) ; int result2 = c . get ( Calendar . DAY_OF_WEEK ) ; } System . out . println ( ""time (ms) : "" + ( System . currentTimeMillis ( ) - time ) ) ; }"
606,int isPerfectSquare ( int n ) { int h = n & 0xF ; if ( h > 9 ) return 0 ; if ( h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8 ) { int t = ( int ) floor ( sqrt ( ( double ) n ) + 0.5 ) ; return t * t == n ; } return 0 ; }
607,boolean isPerfectSquare ( long number ) { if ( number < 0 ) return false ; if ( number < 2 ) return true ; for ( int i = 0 ; ; i ++ ) { long square = squareTable [ i ] ; if ( square > number ) return false ; while ( number % square == 0 ) { number /= square ; } if ( number == 1 ) return true ; } }
608,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
609,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
610,"void type ( String characters ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection stringSelection = new StringSelection ( characters ) ; clipboard . setContents ( stringSelection , clipboardOwner ) ; robot . keyPress ( KeyEvent . VK_CONTROL ) ; robot . keyPress ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_CONTROL ) ; }"
611,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_SHIFT , VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_SHIFT , VK_AT ) ; break ; case '#' : doType ( VK_SHIFT , VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_SHIFT , VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_SHIFT , VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_SHIFT , VK_AMPERSAND ) ; break ; case '*' : doType ( VK_SHIFT , VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_SHIFT , VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_SHIFT , VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_SHIFT , VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_SHIFT , VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; case '\b' : doType ( VK_BACK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
612,void afterTextChanged ( Editable s ) { if ( ! mRestoringPreviousValueFlag ) { if ( ! isValid ( s . toString ( ) ) ) { mRestoringPreviousValueFlag = true ; restorePreviousValue ( ) ; } } else { mRestoringPreviousValueFlag = false ; } }
613,"void afterTextChanged ( final Editable text ) { String cost = text . toString ( ) . trim ( ) ; if ( ! cost . endsWith ( ""."" ) && cost . contains ( ""."" ) ) { String numberBeforeDecimal = cost . split ( ""\\."" ) [ 0 ] ; String numberAfterDecimal = cost . split ( ""\\."" ) [ 1 ] ; if ( numberAfterDecimal . length ( ) > 2 ) { numberAfterDecimal = numberAfterDecimal . substring ( 0 , 2 ) ; } cost = numberBeforeDecimal + ""."" + numberAfterDecimal ; } costEditText . removeTextChangedListener ( this ) ; costEditText . setText ( cost ) ; costEditText . setSelection ( costEditText . getText ( ) . toString ( ) . trim ( ) . length ( ) ) ; costEditText . addTextChangedListener ( this ) ; }"
614,"int getHours ( ) { while ( true ) { if ( console . hasNextInt ( ) ) { System . out . print ( ""**hours input accepted**"" ) ; return console . nextInt ( ) ; } console . nextLine ( ) ; System . out . print ( "", please re-enter the hours again:"" ) ; } }"
615,"int getHours ( ) { int hours = 0 ; boolean hoursNotOk = true ; do { try { System . out . println ( ""Here"" ) ; hours = console . nextInt ( ) ; hoursNotOk = false ; } catch ( Exception e ) { e . printStackTrace ( ) ; console . nextLine ( ) ; } finally { if ( hoursNotOk ) { System . out . println ( "", please re-enter the hours again:"" ) ; } else { System . out . println ( ""**hours input accepted**"" ) ; } } } while ( hoursNotOk ) ; return hours ; }"
616,void removeDuplicates ( char [ ] str ) { if ( str == null ) return ; int len = str . length ; if ( len < 2 ) return ; int tail = 1 ; for ( int i = 1 ; i < len ; ++ i ) { int j ; for ( j = 0 ; j < tail ; ++ j ) { if ( str [ i ] == str [ j ] ) break ; } if ( j == tail ) { str [ tail ] = str [ i ] ; ++ tail ; } } str [ tail ] = 0 ; }
617,void removeDuplicates ( char [ ] str ) { int map = 0 ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( ( map & ( 1 << ( str [ i ] - 'a' ) ) ) > 0 ) str [ i ] = 0 ; else map |= 1 << ( str [ i ] - 'a' ) ; } }
618,"int [ ] sort ( int [ ] numbers , int digit ) { if ( numbers . length == 0 || digit <= 0 ) return numbers ; int [ ] [ ] space = new int [ 10 ] [ 0 ] ; int [ ] len = new int [ 10 ] ; int i , j ; for ( j = 0 ; j < numbers . length ; j ++ ) { i = ( numbers [ j ] / digit ) % 10 ; len [ i ] ++ ; space [ i ] = putInBucket ( space [ i ] , numbers [ j ] ) ; } for ( i = 0 ; i < 10 ; i ++ ) { space [ i ] = sort ( space [ i ] , digit / 10 ) ; } int k = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { for ( j = 0 ; j < len [ i ] ; j ++ ) { numbers [ k ] = space [ i ] [ j ] ; k ++ ; } } return numbers ; }"
619,"int [ ] sort ( int [ ] numbers , int digit ) { if ( numbers . length == 0 || digit <= 0 ) return numbers ; int [ ] [ ] space = new int [ 10 ] [ 1 ] ; int [ ] len = new int [ 10 ] ; int i , j = 0 ; for ( j = 0 ; j < numbers . length ; j ++ ) { i = ( numbers [ j ] / digit ) % 10 ; len [ i ] ++ ; space [ i ] = putInBucket ( space [ i ] , numbers [ j ] ) ; } for ( i = 0 ; i < 10 ; i ++ ) { int [ ] bucket = new int [ len [ i ] ] ; for ( int k = 0 ; k < len [ i ] ; k ++ ) bucket [ k ] = space [ i ] [ k ] ; space [ i ] = sort ( bucket , digit / 10 ) ; } int k = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { for ( j = 0 ; j < len [ i ] ; j ++ ) { numbers [ k ] = space [ i ] [ j ] ; k ++ ; } } return numbers ; }"
620,"void main ( String [ ] args ) { int [ ] A = { 9 , 5 , 4 , 3 , 2 , 1 , 34 , 53 } ; int [ ] B = new int [ A . length ] ; int [ ] C = new int [ A . length ] ; int t = 4 ; int countb = 0 ; int countc = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { B [ countb ++ ] = A [ i ] ; } else { C [ countc ++ ] = A [ i ] ; } } System . out . println ( Arrays . toString ( B ) ) ; System . out . println ( Arrays . toString ( C ) ) ; }"
621,"void main ( String [ ] args ) { int [ ] A = { 9 , 5 , 4 , 3 , 2 , 1 , 34 , 53 } ; int t = 4 ; int count = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { count ++ ; } } int [ ] B = new int [ count ] ; int [ ] C = new int [ A . length - count ] ; for ( int i = 0 , j = 0 , k = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { B [ j ] = A [ i ] ; System . out . println ( ""B = "" + B [ j ] ) ; j ++ ; } else { C [ k ] = A [ i ] ; System . out . println ( ""C = "" + C [ k ] ) ; k ++ ; } } }"
622,"int [ ] [ ] getRows ( int i , int j , int [ ] [ ] array ) { int [ ] [ ] ret = new int [ j - i ] [ ] ; for ( int k = i ; k < j ; k ++ ) { ret [ k - i ] = new int [ array [ k ] . length ] ; for ( int m = 0 ; m < ret [ k - i ] . length ; m ++ ) { ret [ k - i ] [ m ] = array [ k ] [ m ] ; } } return ret ; }"
623,"int [ ] [ ] getRows ( int i , int j , int [ ] [ ] array ) { int [ ] [ ] another = new int [ j - i + 1 ] [ ] ; while ( i <= j ) { for ( int k = 0 ; k < another . length ; k ++ ) { another [ k ] = array [ i ] ; i ++ ; } } return another ; }"
624,"boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( obj . getClass ( ) != this . getClass ( ) ) { return false ; } MyClass other = ( MyClass ) obj ; return new EqualsBuilder ( ) . appendSuper ( super . equals ( obj ) ) . append ( field1 , other . field1 ) . append ( field2 , other . field2 ) . append ( field3 , other . field3 ) . isEquals ( ) ; }"
625,boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Connection other = ( Connection ) obj ; if ( dstAddr == null ) { if ( other . dstAddr != null ) return false ; } else if ( ! dstAddr . equals ( other . dstAddr ) ) return false ; if ( dstPort != other . dstPort ) return false ; if ( protocol == null ) { if ( other . protocol != null ) return false ; } else if ( ! protocol . equals ( other . protocol ) ) return false ; if ( srcAddr == null ) { if ( other . srcAddr != null ) return false ; } else if ( ! srcAddr . equals ( other . srcAddr ) ) return false ; if ( srcPort != other . srcPort ) return false ; return true ; }
626,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] result = new int [ P . length ] ; int [ ] factor1 = new int [ S . length ( ) ] ; int [ ] factor2 = new int [ S . length ( ) ] ; int [ ] factor3 = new int [ S . length ( ) ] ; int [ ] factor4 = new int [ S . length ( ) ] ; int factor1Sum = 0 ; int factor2Sum = 0 ; int factor3Sum = 0 ; int factor4Sum = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : factor1Sum ++ ; break ; case 'C' : factor2Sum ++ ; break ; case 'G' : factor3Sum ++ ; break ; case 'T' : factor4Sum ++ ; break ; default : break ; } factor1 [ i ] = factor1Sum ; factor2 [ i ] = factor2Sum ; factor3 [ i ] = factor3Sum ; factor4 [ i ] = factor4Sum ; } for ( int i = 0 ; i < P . length ; i ++ ) { int start = P [ i ] ; int end = Q [ i ] ; if ( start == 0 ) { if ( factor1 [ end ] > 0 ) { result [ i ] = 1 ; } else if ( factor2 [ end ] > 0 ) { result [ i ] = 2 ; } else if ( factor3 [ end ] > 0 ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } else { if ( factor1 [ end ] > factor1 [ start - 1 ] ) { result [ i ] = 1 ; } else if ( factor2 [ end ] > factor2 [ start - 1 ] ) { result [ i ] = 2 ; } else if ( factor3 [ end ] > factor3 [ start - 1 ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } } return result ; }"
627,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int N = S . length ( ) ; int M = P . length ; int [ ] result = new int [ M ] ; lastOccurrencesMap = new int [ 3 ] [ N ] ; int lastA = - 1 ; int lastC = - 1 ; int lastG = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { char c = S . charAt ( i ) ; if ( c == 'A' ) { lastA = i ; } else if ( c == 'C' ) { lastC = i ; } else if ( c == 'G' ) { lastG = i ; } lastOccurrencesMap [ 0 ] [ i ] = lastA ; lastOccurrencesMap [ 1 ] [ i ] = lastC ; lastOccurrencesMap [ 2 ] [ i ] = lastG ; } for ( int i = 0 ; i < M ; i ++ ) { int startIndex = P [ i ] ; int endIndex = Q [ i ] ; int minimum = 4 ; for ( int n = 0 ; n < 3 ; n ++ ) { int lastOccurence = getLastNucleotideOccurrence ( startIndex , endIndex , n ) ; if ( lastOccurence != 0 ) { minimum = n + 1 ; break ; } } result [ i ] = minimum ; } return result ; }"
628,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
629,XSSFFont transform ( HSSFFont fontOld ) { XSSFFont fontNew = this . workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }
630,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( value . isEmpty ( ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! tensName . isEmpty ( ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
631,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
632,boolean isBalanced ( String expression ) { if ( ( expression . length ( ) % 2 ) == 1 ) return false ; else { Stack < Character > s = new Stack < > ( ) ; for ( char bracket : expression . toCharArray ( ) ) switch ( bracket ) { case '{' : s . push ( '}' ) ; break ; case '(' : s . push ( ')' ) ; break ; case '[' : s . push ( ']' ) ; break ; default : if ( s . isEmpty ( ) || bracket != s . peek ( ) ) { return false ; } s . pop ( ) ; } return s . isEmpty ( ) ; } }
633,boolean isBalanced ( String str ) { boolean result = false ; if ( str . length ( ) < 2 ) return false ; Stack < Character > stack = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ! parenthesesMapRight . containsKey ( ch ) && ! parenthesesMapLeft . containsKey ( ch ) ) { continue ; } if ( parenthesesMapLeft . containsKey ( ch ) ) { stack . push ( ch ) ; } else { if ( ! stack . isEmpty ( ) && stack . pop ( ) == parenthesesMapRight . get ( ch ) . charValue ( ) ) { result = true ; } else { return false ; } } } if ( ! stack . isEmpty ( ) ) return result = false ; return result ; }
634,"void main ( String [ ] arguments ) { System . out . println ( ""Type in any integer"" ) ; Scanner inputChar = new Scanner ( System . in ) ; int i ; if ( ! inputChar . hasNextInt ( ) ) System . out . println ( ""Not a number"" ) ; else { i = inputChar . nextInt ( ) ; if ( i != 0 ) { if ( i % 2 == 0 ) System . out . println ( i + "" is even"" ) ; else { System . out . println ( i + "" is odd"" ) ; } } else { System . out . println ( ""Zeros are not allowed, bye!"" ) ; } } }"
635,"void main ( String [ ] arguments ) { Scanner inputChar = new Scanner ( System . in ) ; int i ; while ( true ) { System . out . println ( ""Type in any integer:"" ) ; if ( ! inputChar . hasNextInt ( ) ) { System . out . println ( ""Not a number"" ) ; inputChar . next ( ) ; } else { i = inputChar . nextInt ( ) ; if ( i != 0 ) { if ( i % 2 == 0 ) System . out . println ( i + "" is even"" ) ; else { System . out . println ( i + "" is odd"" ) ; } } else { System . out . println ( ""Zeros are not allowed, bye!"" ) ; break ; } } } }"
636,void run ( ) { try { Thread . sleep ( 500 ) ; changeBtnForegroung ( Color . darkGray ) ; Thread . sleep ( 500 ) ; count = 0 ; Thread . sleep ( 750 ) ; } catch ( Exception e ) { System . out . println ( e ) ; } }
637,"void run ( ) { try { runs = true ; if ( noColor < 2 ) { noColor ++ ; changeBtnForegroung ( clr [ noColor ] ) ; } else { noColor = 0 ; changeBtnForegroung ( clr [ noColor ] ) ; } changeBtnMargin ( new Insets ( initMargin . top , initMargin . left + 10 , initMargin . bottom , initMargin . right - 10 ) ) ; border = new EmptyBorder ( 0 , 5 , 10 , 5 ) ; changePnlBorder ( border ) ; Thread . sleep ( 100 ) ; changeBtnMargin ( new Insets ( initMargin . top , initMargin . left - 10 , initMargin . bottom , initMargin . right + 10 ) ) ; border = new EmptyBorder ( 0 , 0 , 10 , 10 ) ; changePnlBorder ( border ) ; Thread . sleep ( 100 ) ; changeBtnMargin ( new Insets ( initMargin . top , initMargin . left + 10 , initMargin . bottom , initMargin . right - 10 ) ) ; border = new EmptyBorder ( 5 , 10 , 5 , 0 ) ; changePnlBorder ( border ) ; Thread . sleep ( 100 ) ; changeBtnMargin ( new Insets ( initMargin . top , initMargin . left - 10 , initMargin . bottom , initMargin . right + 10 ) ) ; border = new EmptyBorder ( 10 , 10 , 0 , 0 ) ; changePnlBorder ( border ) ; Thread . sleep ( 100 ) ; changeBtnMargin ( new Insets ( initMargin . top , initMargin . left , initMargin . bottom , initMargin . right ) ) ; border = new EmptyBorder ( 5 , 5 , 5 , 5 ) ; changePnlBorder ( border ) ; Thread . sleep ( 100 ) ; count ++ ; } catch ( Exception e ) { System . out . println ( e ) ; } }"
638,"void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == CAMERA_RESULT ) { if ( resultCode == Activity . RESULT_OK ) { String galleryImatePath = SD_CARD_TEMP_DIR ; File f = new File ( galleryImatePath ) ; try { Bitmap cameraBitmap = null ; BitmapFactory . Options bmOptions = new BitmapFactory . Options ( ) ; bmOptions . inJustDecodeBounds = false ; bmOptions . inPurgeable = true ; bmOptions . inBitmap = cameraBitmap ; bmOptions . inMutable = true ; cameraBitmap = BitmapFactory . decodeFile ( galleryImatePath , bmOptions ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; cameraBitmap . compress ( Bitmap . CompressFormat . JPEG , 50 , bos ) ; ExifInterface exif = new ExifInterface ( galleryImatePath ) ; float rotation = exif . getAttributeInt ( ExifInterface . TAG_ORIENTATION , ExifInterface . ORIENTATION_NORMAL ) ; System . out . println ( rotation ) ; float rotationInDegrees = exifToDegrees ( rotation ) ; System . out . println ( rotationInDegrees ) ; Matrix matrix = new Matrix ( ) ; matrix . postRotate ( rotationInDegrees ) ; final Bitmap rotatedBitmap = Bitmap . createBitmap ( cameraBitmap , 0 , 0 , cameraBitmap . getWidth ( ) , cameraBitmap . getHeight ( ) , matrix , true ) ; FileOutputStream fos = new FileOutputStream ( galleryImatePath ) ; rotatedBitmap . compress ( Bitmap . CompressFormat . JPEG , 50 , fos ) ; fos . write ( bos . toByteArray ( ) ) ; cameraBitmap . recycle ( ) ; System . gc ( ) ; fos . flush ( ) ; fos . close ( ) ; Capdialog = new Dialog ( AddToDo . this , android . R . style . Theme_NoTitleBar_Fullscreen ) ; Capdialog . setContentView ( R . layout . captiondialog ) ; Capdialog . setCancelable ( false ) ; TextView cancel = ( TextView ) Capdialog . findViewById ( R . id . cancel ) ; TextView done = ( TextView ) Capdialog . findViewById ( R . id . done ) ; Capdialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_ALWAYS_HIDDEN ) ; ImageView img = ( ImageView ) Capdialog . findViewById ( R . id . image ) ; img . setImageBitmap ( rotatedBitmap ) ; } catch ( Exception e ) { } } } }"
639,"void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == 0 ) { try { Bitmap cameraBitmap ; cameraBitmap = BitmapFactory . decodeFile ( myFilesDir + ""/temp.jpg"" ) ; Bitmap . createBitmap ( cameraBitmap ) ; ivPhoto . setImageBitmap ( cameraBitmap ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }"
640,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
641,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Distance (m)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; gg . drawString ( string , ( getWidth ( ) - width ) / 2 , 11 ) ; }"
642,"void main ( String [ ] args ) { ScottishPerson scottishPerson = new ScottishPerson ( ) ; BritishPerson britishPerson = new BritishPerson ( ) ; BritishPerson britishPersonUpcasted = new ScottishPerson ( ""Another scottish name"" ) ; scottishPerson . salute ( ) ; scottishPerson . warcry ( ) ; System . out . println ( scottishPerson . name ) ; System . out . println ( scottishPerson . clanName ) ; britishPerson . salute ( ) ; System . out . println ( britishPerson . name ) ; britishPersonUpcasted . salute ( ) ; System . out . println ( britishPersonUpcasted . name ) ; }"
643,"void main ( String [ ] args ) { Dog dog = new Dog ( ) ; Horse horse = new Horse ( ) ; Animal animal = dog ; Animal horseAnimal = new Horse ( ) ; Dog upcastedAnimal = upcastToDog ( animal ) ; dog . saySomething ( ) ; dog . getTheBall ( ) ; upcastedAnimal . saySomething ( ) ; upcastedAnimal . getTheBall ( ) ; horse . saySomething ( ) ; horse . getTheBall ( ) ; try { Dog upcastedDog = upcastToDog ( horseAnimal ) ; } catch ( Exception ex ) { System . out . println ( ex . getClass ( ) . getSimpleName ( ) + "": Obviously a horse is not a dog!"" ) ; } }"
644,int sum13 ( int [ ] nums ) { int sum = 0 ; boolean skipNext = false ; for ( int num : nums ) { if ( num == 13 ) { skipNext = true ; } else { if ( ! skipNext ) { sum += num ; } skipNext = false ; } } return sum ; }
645,int sum13 ( int [ ] nums ) { int sum = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] != 13 ) { sum += nums [ i ] ; } else { i ++ ; } } return sum ; }
646,void actionPerformed ( ActionEvent e ) { int index = list . getSelectedIndex ( ) ; listModel . remove ( index ) ; int size = listModel . getSize ( ) ; if ( size == 0 ) { fireButton . setEnabled ( false ) ; } else { if ( index == listModel . getSize ( ) ) { index -- ; } list . setSelectedIndex ( index ) ; list . ensureIndexIsVisible ( index ) ; } }
647,"void actionPerformed ( ActionEvent e ) { String name = employeeName . getText ( ) ; if ( name . equals ( """" ) || alreadyInList ( name ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; employeeName . requestFocusInWindow ( ) ; employeeName . selectAll ( ) ; return ; } int index = list . getSelectedIndex ( ) ; if ( index == - 1 ) { index = 0 ; } else { index ++ ; } listModel . insertElementAt ( employeeName . getText ( ) , index ) ; employeeName . requestFocusInWindow ( ) ; employeeName . setText ( """" ) ; list . setSelectedIndex ( index ) ; list . ensureIndexIsVisible ( index ) ; }"
648,"String decrypt ( String cipher ) { String [ ] cipher_char_codes = cipher . split ( ""#"" ) ; StringBuilder message = new StringBuilder ( ) ; for ( String code : cipher_char_codes ) { int index = Integer . parseInt ( code ) ; if ( index > 26 ) { char [ ] pair = code . toCharArray ( ) ; for ( int i = 0 ; i < pair . length ; i ++ ) { int x = Integer . parseInt ( """" + code . charAt ( i ) ) ; message . append ( ( char ) ( 'a' + ( ( x - 1 ) % 26 ) ) ) ; } } else { message . append ( ( char ) ( 'a' + ( ( index - 1 ) % 26 ) ) ) ; } } return message . toString ( ) ; }"
649,"String decrypt ( final String msg ) { final Pattern regex = Pattern . compile ( ""((\\d\\d)(#)|(\\d))"" ) ; final Matcher regexMatcher = regex . matcher ( msg ) ; final StringBuffer result = new StringBuffer ( ) ; String c ; while ( regexMatcher . find ( ) ) { if ( regexMatcher . group ( 2 ) == null ) { c = regexMatcher . group ( 1 ) ; } else { c = regexMatcher . group ( 2 ) ; } result . append ( ( char ) ( ( Integer . parseInt ( c ) + 'a' ) - 1 ) ) ; } return result . toString ( ) ; }"
650,"void addString ( String ... myString ) { StringBuilder sb = new StringBuilder ( ""("" ) ; for ( int i = 0 ; i < myString . length - 1 ; i ++ ) { sb . append ( myString [ i ] + "" AND "" ) ; } if ( myString . length == 0 ) sb . append ( "")"" ) ; else sb . append ( myString [ myString . length - 1 ] ) ; System . out . println ( sb ) ; }"
651,"void addString ( String ... myString ) { String separator = "" AND "" ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( '(' ) ; boolean needSeparator = false ; for ( String string : myString ) { if ( needSeparator ) { sb . append ( separator ) ; } else { needSeparator = true ; } sb . append ( string ) ; } sb . append ( ')' ) ; System . out . println ( sb ) ; }"
652,"int sqrt ( int x ) { if ( x == 0 || x == 1 ) { return x ; } int start = 1 , end = x / 2 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( mid == x / mid ) { return mid ; } if ( mid < x / mid ) { start = mid + 1 ; } else { end = mid - 1 ; } } return start - 1 ; }"
653,double sqrt ( int n ) { double low = 0 ; double high = n ; double mid = ( high - low ) / 2 ; while ( Math . abs ( ( mid * mid ) - n ) > 0.000000000001 ) { if ( ( mid * mid ) > n ) { high = mid ; mid = ( high - low ) / 2 ; } else { low = mid ; mid = mid + ( ( high - low ) / 2 ) ; } } return mid ; }
654,"byte [ ] hash ( char [ ] password , byte [ ] salt ) { PBEKeySpec spec = new PBEKeySpec ( password , salt , ITERATIONS , KEY_LENGTH ) ; Arrays . fill ( password , Character . MIN_VALUE ) ; try { SecretKeyFactory skf = SecretKeyFactory . getInstance ( ""PBKDF2WithHmacSHA1"" ) ; return skf . generateSecret ( spec ) . getEncoded ( ) ; } catch ( NoSuchAlgorithmException | InvalidKeySpecException e ) { throw new AssertionError ( ""Error while hashing a password: "" + e . getMessage ( ) , e ) ; } finally { spec . clearPassword ( ) ; } }"
655,"byte [ ] hash ( String password , byte [ ] salt ) { Validate . notNull ( password , ""Password must not be null"" ) ; Validate . notNull ( salt , ""Salt must not be null"" ) ; try { final byte [ ] passwordBytes = password . getBytes ( ""UTF-8"" ) ; final byte [ ] all = ArrayUtils . addAll ( passwordBytes , salt ) ; SHA3 . DigestSHA3 md = new SHA3 . Digest512 ( ) ; md . update ( all ) ; return md . digest ( ) ; } catch ( UnsupportedEncodingException e ) { final String message = String . format ( ""Caught UnsupportedEncodingException e: <%s>"" , e . getMessage ( ) ) ; LOGGER . error ( message ) ; } return new byte [ 0 ] ; }"
656,"long countLines ( InputStream is ) throws IOException { try ( LineNumberReader lnr = new LineNumberReader ( new InputStreamReader ( is ) ) ) { char [ ] buf = new char [ 8192 ] ; int n , previousN = - 1 ; while ( ( n = lnr . read ( buf ) ) != - 1 ) { previousN = n ; } int ln = lnr . getLineNumber ( ) ; if ( previousN == - 1 ) { return 0 ; } else { char lastChar = buf [ previousN - 1 ] ; if ( lastChar == '\n' || lastChar == '\r' ) { return ln ; } } return ln + 1 ; } }"
657,int countLines ( File input ) throws IOException { try ( InputStream is = new FileInputStream ( input ) ) { int count = 1 ; for ( int aChar = 0 ; aChar != - 1 ; aChar = is . read ( ) ) count += aChar == '\n' ? 1 : 0 ; return count ; } }
658,"String numLetters ( String str ) { StringBuilder s = new StringBuilder ( s ) ; String end = new String ( ) ; int counter = 0 ; char c , d ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charAt ( i ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { d = s . charAt ( j ) ; if ( c == d ) { s . deleteCharAt ( j ) ; if ( i >= j ) i -- ; j -- ; counter ++ ; } } end = end + counter + c ; counter = 0 ; } return end ; }"
659,"String numLetters ( String s ) { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; count [ ( int ) ( c - 'a' ) ] ++ ; } String ans = """" ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] != 0 ) { ans += String . valueOf ( count [ i ] ) + ( char ) ( i + 'a' ) ; } } return ans ; }"
660,"void main ( String arg [ ] ) { Scanner sc = new Scanner ( System . in ) ; System . out . println ( ""enter string for c"" ) ; String c = sc . next ( ) ; System . out . println ( ""c is "" + c ) ; System . out . println ( ""enter string for d"" ) ; String d = sc . next ( ) ; System . out . println ( ""d is "" + d ) ; }"
661,void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int cases = sc . nextInt ( ) ; String [ ] str = new String [ cases ] ; for ( int i = 0 ; i < cases ; i ++ ) { str [ i ] = sc . next ( ) ; } }
662,void main ( String [ ] args ) { for ( int i = 0 ; i < 5 ; i ++ ) { Link . insert ( i + 5 ) ; } Link . printList ( ) ; Link . deletefromFirst ( ) ; Link . printList ( ) ; }
663,"void main ( String [ ] args ) { LinkList list = new LinkList ( ) ; list . insert ( 1 , 1.01 ) ; list . insert ( 2 , 2.02 ) ; list . insert ( 3 , 3.03 ) ; list . insert ( 4 , 4.04 ) ; list . insert ( 5 , 5.05 ) ; list . printList ( ) ; while ( ! list . isEmpty ( ) ) { Link deletedLink = list . delete ( ) ; System . out . print ( ""deleted: "" ) ; deletedLink . printLink ( ) ; System . out . println ( """" ) ; } list . printList ( ) ; }"
664,"void main ( String ... args ) { processor = new DefaultProcessor ( ) ; long [ ] values = new long [ ] { 0 , 4 , 10 , 12 , 100 , 108 , 299 , 1000 , 1003 , 2040 , 45213 , 100000 , 100005 , 100010 , 202020 , 202022 , 999999 , 1000000 , 1000001 , 10000000 , 10000007 , 99999999 , Long . MAX_VALUE , Long . MIN_VALUE } ; String [ ] strValues = new String [ ] { ""0001.2"" , ""3.141592"" } ; for ( long val : values ) { System . out . println ( val + "" = "" + processor . getName ( val ) ) ; } for ( String strVal : strValues ) { System . out . println ( strVal + "" = "" + processor . getName ( strVal ) ) ; } StringBuilder bigNumber = new StringBuilder ( ) ; for ( int d = 0 ; d < 66 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } bigNumber . append ( ""."" ) ; for ( int d = 0 ; d < 26 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } System . out . println ( bigNumber . toString ( ) + "" = "" + processor . getName ( bigNumber . toString ( ) ) ) ; }"
665,"void main ( String [ ] args ) { System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 0 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 9 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 19 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 21 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 28 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 71 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 72 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 80 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 81 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 89 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 90 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 91 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 97 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 101 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 110 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 120 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 200 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 201 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 232 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 999 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2000000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 3000000000L ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2147483647 ) ) ; }"
666,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
667,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
668,"void primeFactor ( ) { if ( input > 1 ) { for ( int i = input ; i >= 1 ; i -- ) { if ( isPrime ( i ) ) { if ( divide ( i ) ) { System . out . println ( ""Adding a new int..."" ) ; factors . add ( i ) ; input = input / i ; primeFactor ( ) ; } } } } }"
669,"void primeFactor ( ) { input = sc . nextInt ( ) ; for ( num = 1 ; num <= input ; num ++ ) { if ( isPrime ( num ) ) { if ( divide ( num ) ) { System . out . println ( ""Adding a new int..."" ) ; factors . add ( num ) ; } } } for ( int element : factors ) { System . out . println ( element ) ; } }"
670,"void main ( String args [ ] ) { int i ; int largestSize = 4 ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 } ; int large [ ] = Arrays . copyOf ( array , largestSize ) ; int smallest = large [ 0 ] ; int smallestIndex = 0 ; for ( int j = 1 ; j < large . length ; ++ j ) { if ( smallest > large [ j ] ) { smallest = large [ j ] ; smallestIndex = j ; } } for ( i = large . length ; i < array . length ; i ++ ) { if ( smallest < array [ i ] ) { large [ smallestIndex ] = array [ i ] ; smallest = large [ 0 ] ; smallestIndex = 0 ; for ( int j = 1 ; j < large . length ; ++ j ) { if ( smallest > large [ j ] ) { smallest = large [ j ] ; smallestIndex = j ; } } } } for ( int j = 0 ; j < large . length ; j ++ ) { System . out . println ( ""Largest 5 : "" + large [ j ] ) ; } System . out . println ( ) ; System . out . println ( ""Largest is: "" + getHighest ( large ) ) ; }"
671,"void main ( String [ ] args ) { int large [ ] = new int [ 10 ] ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int k = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { large [ k ++ ] = getMax ( 0 , array ) ; } System . out . println ( ""Largest 5 is: "" + Arrays . toString ( Arrays . copyOf ( large , 5 ) ) ) ; }"
672,"void main ( String [ ] args ) { System . out . println ( ""Enter Number to convert into words"" ) ; Scanner sc = new Scanner ( System . in ) ; long num = sc . nextInt ( ) ; int rem = 0 ; int i = 0 ; while ( num > 0 ) { if ( i == 0 ) { rem = ( int ) ( num % 1000 ) ; printText ( rem ) ; num = num / 1000 ; i ++ ; } else if ( num > 0 ) { rem = ( int ) ( num % 100 ) ; if ( rem > 0 ) text = denom . values ( ) [ i - 1 ] + "" "" + text ; printText ( rem ) ; num = num / 100 ; i ++ ; } } if ( i > 0 ) System . out . println ( text ) ; else System . out . println ( ""Zero"" ) ; }"
673,"void main ( String [ ] args ) { int n = 0 ; Scanner s = new Scanner ( System . in ) ; System . out . print ( ""Enter an integer number: "" ) ; n = s . nextInt ( ) ; if ( n <= 0 ) System . out . print ( ""Enter numbers greater than 0"" ) ; else { NumberToWord a = new NumberToWord ( ) ; System . out . print ( ""After conversion number in words is :"" ) ; a . pw ( ( n / 1000000000 ) , "" Hundred"" ) ; a . pw ( ( n / 10000000 ) % 100 , "" crore"" ) ; a . pw ( ( ( n / 100000 ) % 100 ) , "" lakh"" ) ; a . pw ( ( ( n / 1000 ) % 100 ) , "" thousand"" ) ; a . pw ( ( ( n / 100 ) % 10 ) , "" hundred"" ) ; a . pw ( ( n % 100 ) , "" "" ) ; } }"
674,"void main ( String [ ] args ) { FileReader fr = null ; BufferedReader br = null ; String [ ] stringArray ; int counLine = 0 ; int arrayLength ; String s = """" ; String stringLine = """" ; try { fr = new FileReader ( ""F:/Line.txt"" ) ; br = new BufferedReader ( fr ) ; while ( ( s = br . readLine ( ) ) != null ) { stringLine = stringLine + s ; stringLine = stringLine + "" "" ; counLine ++ ; } System . out . println ( stringLine ) ; stringArray = stringLine . split ( "" "" ) ; arrayLength = stringArray . length ; System . out . println ( ""The number of Words is "" + arrayLength ) ; for ( int i = 0 ; i < arrayLength ; i ++ ) { int c = 1 ; for ( int j = i + 1 ; j < arrayLength ; j ++ ) { if ( stringArray [ i ] . equalsIgnoreCase ( stringArray [ j ] ) ) { c ++ ; for ( int j2 = j ; j2 < arrayLength ; j2 ++ ) { stringArray [ j2 ] = stringArray [ j2 + 1 ] ; arrayLength = arrayLength - 1 ; } } } System . out . println ( ""The "" + stringArray [ i ] + "" present "" + c + "" times ."" ) ; } System . out . println ( ""The number of Line is "" + counLine ) ; System . out . println ( ) ; fr . close ( ) ; br . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
675,"void main ( String [ ] args ) { int count = 0 ; String str = ""hi this is is is line"" ; String [ ] s1 = str . split ( "" "" ) ; for ( int i = 0 ; i <= s1 . length - 1 ; i ++ ) { if ( s1 [ i ] . equals ( ""is"" ) ) { count ++ ; } } System . out . println ( count ) ; }"
676,"int getLastFriday ( int month , int year ) { Calendar cal = Calendar . getInstance ( ) ; cal . set ( year , month , 1 , 0 , 0 , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; int friday = - 1 ; while ( cal . get ( Calendar . MONTH ) == month ) { if ( cal . get ( Calendar . DAY_OF_WEEK ) == Calendar . FRIDAY ) { friday = cal . get ( Calendar . DAY_OF_MONTH ) ; cal . add ( Calendar . DAY_OF_MONTH , 7 ) ; } else { cal . add ( Calendar . DAY_OF_MONTH , 1 ) ; } } return friday ; }"
677,"Calendar getLastFriday ( Calendar cal , int offset ) { int dayofweek ; cal . set ( Calendar . MONTH , cal . get ( Calendar . MONTH ) + offset ) ; cal . set ( Calendar . DAY_OF_MONTH , cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; dayofweek = cal . get ( Calendar . DAY_OF_WEEK ) ; if ( dayofweek < Calendar . FRIDAY ) cal . set ( Calendar . DAY_OF_MONTH , cal . get ( Calendar . DAY_OF_MONTH ) - 7 + Calendar . FRIDAY - dayofweek ) ; else cal . set ( Calendar . DAY_OF_MONTH , cal . get ( Calendar . DAY_OF_MONTH ) + Calendar . FRIDAY - dayofweek ) ; return cal ; }"
678,"String decrypt ( String cipher ) { String [ ] cipher_char_codes = cipher . split ( ""#"" ) ; StringBuilder message = new StringBuilder ( ) ; for ( String code : cipher_char_codes ) { int index = Integer . parseInt ( code ) ; if ( index > 26 ) { char [ ] pair = code . toCharArray ( ) ; for ( int i = 0 ; i < pair . length ; i ++ ) { int x = Integer . parseInt ( """" + code . charAt ( i ) ) ; message . append ( ( char ) ( 'a' + ( ( x - 1 ) % 26 ) ) ) ; } } else { message . append ( ( char ) ( 'a' + ( ( index - 1 ) % 26 ) ) ) ; } } return message . toString ( ) ; }"
679,"String decrypt ( final String s ) { final List < Integer > crypt = new ArrayList < > ( ) ; final String [ ] groups = s . split ( ""#"" ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { final String group = groups [ i ] ; int j = 0 ; if ( ( i == ( groups . length - 1 ) ) && ! s . endsWith ( ""#"" ) ) { j = group . length ( ) ; } if ( group . length ( ) > 2 ) { j = group . length ( ) - 2 ; } for ( int k = 0 ; k < j ; k ++ ) { crypt . add ( Integer . valueOf ( group . substring ( k , k + 1 ) ) ) ; } if ( j < group . length ( ) ) { crypt . add ( Integer . valueOf ( group . substring ( j , group . length ( ) ) ) ) ; } } final StringBuilder n = new StringBuilder ( crypt . size ( ) ) ; for ( final Integer c : crypt ) { final char d = ( char ) ( ( 'a' + c ) - 1 ) ; n . append ( d ) ; } return n . toString ( ) ; }"
680,int count8 ( int n ) { String nString = Integer . toString ( n ) ; boolean isPrevChar8 = false ; int total = 0 ; for ( int i = 0 ; i < nString . length ( ) ; i ++ ) { char nextChar = nString . charAt ( i ) ; if ( nextChar == '8' ) { total += ( isPrevChar8 ? 2 : 1 ) ; isPrevChar8 = true ; } else { isPrevChar8 = false ; } } return total ; }
681,int count8 ( int num ) { int count = 0 ; boolean doubl = false ; while ( true ) { int n = num % 10 ; num = num / 10 ; if ( n == 8 ) { if ( doubl ) { count = count + 2 ; } else { count ++ ; } doubl = true ; } else { doubl = false ; } if ( num == 0 ) break ; } return count ; }
682,"void main ( String [ ] args ) throws InterruptedException { AtomicInteger counter = new AtomicInteger ( ) ; ExecutorService pool = Executors . newFixedThreadPool ( 4 ) ; for ( int i = 0 ; i < 4 ; ++ i ) { pool . execute ( new MyTask ( counter ) ) ; } pool . shutdown ( ) ; pool . awaitTermination ( 1 , TimeUnit . HOURS ) ; }"
683,"void main ( String [ ] args ) throws InterruptedException { BlockingQueue < Object > expensiveObjects = new LinkedBlockingQueue < > ( ) ; expensiveObjects . put ( new Object ( ) ) ; expensiveObjects . put ( new Object ( ) ) ; expensiveObjects . put ( new Object ( ) ) ; expensiveObjects . put ( new Object ( ) ) ; ExecutorService executorService = Executors . newFixedThreadPool ( 4 ) ; for ( int i = 0 ; i < 4 ; i ++ ) { executorService . execute ( new MyRunnable ( expensiveObjects ) ) ; } executorService . shutdown ( ) ; executorService . awaitTermination ( 5 , TimeUnit . SECONDS ) ; System . out . println ( ""Final: "" + outputCount . get ( ) ) ; }"
684,"void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; System . out . print ( ""give us an integer < 4000: "" ) ; System . out . println ( ""the roman numeral version is: "" + toRoman ( in . nextInt ( ) ) ) ; for ( int i = 1 ; i <= 3999 ; i ++ ) { System . out . println ( i + "" === "" + toRoman ( i ) ) ; } }"
685,"void main ( String [ ] args ) { int number = 2345 ; number = Math . min ( 3999 , Math . max ( 1 , number ) ) ; String asRomanNumerals = """" ; String [ ] RN = { ""I"" , ""V"" , ""X"" , ""L"" , ""C"" , ""D"" , ""M"" } ; int i = 0 ; while ( number > 0 ) { switch ( number % 10 ) { case 1 : asRomanNumerals = RN [ i ] + asRomanNumerals ; break ; case 2 : asRomanNumerals = RN [ i ] + RN [ i ] + asRomanNumerals ; break ; case 3 : asRomanNumerals = RN [ i ] + RN [ i ] + RN [ i ] + asRomanNumerals ; break ; case 4 : asRomanNumerals = RN [ i ] + RN [ i + 1 ] + asRomanNumerals ; break ; case 5 : asRomanNumerals = RN [ i + 1 ] + asRomanNumerals ; break ; case 6 : asRomanNumerals = RN [ i + 1 ] + RN [ i ] + asRomanNumerals ; break ; case 7 : asRomanNumerals = RN [ i + 1 ] + RN [ i ] + RN [ i ] + asRomanNumerals ; break ; case 8 : asRomanNumerals = RN [ i + 1 ] + RN [ i ] + RN [ i ] + RN [ i ] + asRomanNumerals ; break ; case 9 : asRomanNumerals = RN [ i ] + RN [ i + 2 ] + asRomanNumerals ; break ; } number = ( int ) number / 10 ; i += 2 ; } System . out . println ( asRomanNumerals ) ; }"
686,"void actionPerformed ( ActionEvent e ) { ImageIcon saveIcon = new ImageIcon ( ""save-icon.png"" ) ; int askSave = JOptionPane . showConfirmDialog ( null , ""Save current image?"" , """" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , saveIcon ) ; if ( askSave == JOptionPane . YES_OPTION ) { saveImage ( ) ; System . exit ( 0 ) ; } else { System . exit ( 0 ) ; } }"
687,"void actionPerformed ( ActionEvent e ) { ImageIcon widthIcon = new ImageIcon ( ""LR-arrows.png"" ) ; String scaleWidth = ( String ) JOptionPane . showInputDialog ( null , ""What should the new width be?"" , """" , JOptionPane . QUESTION_MESSAGE , widthIcon , null , null ) ; ImageIcon heightIcon = new ImageIcon ( ""UD-arrows.png"" ) ; String scaleHeight = ( String ) JOptionPane . showInputDialog ( null , ""What should the new height be?"" , """" , JOptionPane . QUESTION_MESSAGE , widthIcon , null , null ) ; double x = Double . parseDouble ( scaleWidth ) ; double y = Double . parseDouble ( scaleHeight ) ; int newWidth = ( int ) x ; int newHeight = ( int ) y ; frame . setSize ( newWidth , newHeight ) ; scale ( newWidth , newHeight ) ; }"
688,"void deleteRecursive ( File f ) throws Exception { try { if ( f . isDirectory ( ) ) { for ( File c : f . listFiles ( ) ) { deleteRecursive ( c ) ; } } if ( ! f . delete ( ) ) { throw new Exception ( ""Delete command returned false for file: "" + f ) ; } } catch ( Exception e ) { throw new Exception ( ""Failed to delete the folder: "" + f , e ) ; } }"
689,"void deleteRecursive ( File path ) { File [ ] c = path . listFiles ( ) ; System . out . println ( ""Cleaning out folder:"" + path . toString ( ) ) ; for ( File file : c ) { if ( file . isDirectory ( ) ) { System . out . println ( ""Deleting file:"" + file . toString ( ) ) ; deleteRecursive ( file ) ; file . delete ( ) ; } else { file . delete ( ) ; } } path . delete ( ) ; }"
690,"int score ( final String gene1 , final String gene2 ) { final char [ ] a ; final char [ ] b ; final int s ; a = gene1 . toCharArray ( ) ; b = gene2 . toCharArray ( ) ; s = score ( a , b , 0 , 0 ) ; return ( s ) ; }"
691,"int score ( final char [ ] a , final char [ ] b , final int idxA , final int idxB ) { final int value ; if ( idxA >= a . length || idxB >= b . length ) { value = 0 ; } else if ( a [ idxA ] == b [ idxB ] ) { value = 1 + score ( a , b , idxA + 1 , idxB + 1 ) ; } else { final int x ; final int y ; x = score ( a , b , idxA + 1 , idxB ) ; y = score ( a , b , idxB , idxB + 1 ) ; value = max ( x , y ) ; } return ( value ) ; }"
692,"boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; @ SuppressWarnings ( ""unchecked"" ) final CircularList < T > other = ( CircularList < T > ) obj ; if ( other . length != this . length ) { return false ; } Element < T > current = this . first ; Element < T > otherCurrent = other . first ; int offset = 0 ; boolean found = false ; do { found = checkSequence ( current , otherCurrent ) ; if ( ! found ) { offset ++ ; otherCurrent = otherCurrent . next ; } } while ( ! found && offset < length ) ; return found ; }"
693,"boolean equals ( Object object ) { if ( this == object ) { return true ; } if ( object == null ) { return false ; } if ( ! ( object instanceof CircularList < ? > ) ) { return false ; } CircularList < ? > that = ( CircularList < ? > ) object ; Element < ? > first0 = first ; Element < ? > current0 = first0 ; Element < ? > first1 = that . first ; Element < ? > current1 = first1 ; while ( true ) { if ( equalSequence ( current0 , current0 , current1 , current1 ) ) { return true ; } current1 = current1 . next ; if ( current1 == first1 ) { return false ; } } }"
694,"boolean unsignedMultiplyOverflows ( final long a , final long b ) { if ( ( a == 0L ) || ( b == 0L ) ) { return false ; } if ( ( a == 1L ) || ( b == 1L ) ) { return false ; } if ( ( a < 0L ) || ( b < 0L ) ) { return true ; } final boolean unsignedMultiplyOverflows = ( a > ( ( Long . MAX_VALUE / b ) * 2L ) + ( ( ( ( Long . MAX_VALUE % b ) * 2L ) + 1L ) / b ) ) ; return unsignedMultiplyOverflows ; }"
695,"boolean unsignedMultiplyOverflows ( final long a , final long b ) { if ( a == 0 || b == 0 ) { return false ; } final long aHalf = a > > > 1 ; final long bHalf = b > > > 1 ; final byte aLastBit = ( byte ) ( a & 1 ) ; final byte bLastBit = ( byte ) ( b & 1 ) ; if ( aLastBit == 0 ) { return Long . MAX_VALUE / b < aHalf ; } else if ( bLastBit == 0 ) { return Long . MAX_VALUE / a < bHalf ; } else { return ( Long . MAX_VALUE - bHalf ) / b < aHalf ; } }"
696,"void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = Integer . parseInt ( s . nextLine ( ) ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String str = s . nextLine ( ) ; String [ ] tempArray = str . split ( "" "" ) ; for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = Integer . parseInt ( tempArray [ j ] ) ; } } int x = 0 ; int y = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += a [ i ] [ i ] ; } for ( int p = 0 ; p < n ; p ++ ) { int k = a . length - p - 1 ; y += a [ p ] [ a . length - p - 1 ] ; k += - 1 ; } sum = x - y ; System . out . println ( Math . abs ( sum ) ) ; }"
697,void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int leftStartDiagnol = 0 ; int rightStartDiagnol = n ; int leftTotal = 0 ; int rightTotal = 0 ; int a [ ] [ ] = new int [ n ] [ n ] ; for ( int a_i = 0 ; a_i < n ; a_i ++ ) { for ( int a_j = 0 ; a_j < n ; a_j ++ ) { a [ a_i ] [ a_j ] = in . nextInt ( ) ; } } for ( int a_i = 0 ; a_i < n ; a_i ++ ) { boolean leftNotFound = true ; boolean rightNotFound = true ; rightStartDiagnol = -- rightStartDiagnol ; for ( int a_j = 0 ; a_j < n ; a_j ++ ) { if ( leftStartDiagnol == a_j && leftNotFound ) { leftTotal = leftTotal + a [ a_i ] [ a_j ] ; leftNotFound = false ; } if ( rightStartDiagnol == a_j && rightNotFound ) { rightTotal = rightTotal + a [ a_i ] [ a_j ] ; rightNotFound = false ; } } leftStartDiagnol = ++ leftStartDiagnol ; } int data = leftTotal - rightTotal ; System . out . println ( Math . abs ( data ) ) ; }
698,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
699,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Time (s)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; drawRotate ( gg , getWidth ( ) , ( getHeight ( ) + width ) / 2 , 270 , string ) ; }"
700,boolean isPrime ( int num ) { for ( int i = 2 ; i <= num / i ; i ++ ) { if ( num % i == 0 ) { return false ; } } return num > 1 ; }
701,"boolean isPrime ( int n ) { if ( ( n & 1 ) == 0 ) { return n == 2 ; } if ( n < 9 ) { return n > 1 ; } return isStrongProbablePrime ( n , 2 ) && isStrongProbablePrime ( n , 7 ) && isStrongProbablePrime ( n , 61 ) ; }"
702,boolean isBalanced ( String expression ) { if ( ( expression . length ( ) % 2 ) == 1 ) return false ; else { Stack < Character > s = new Stack < > ( ) ; for ( char bracket : expression . toCharArray ( ) ) switch ( bracket ) { case '{' : s . push ( '}' ) ; break ; case '(' : s . push ( ')' ) ; break ; case '[' : s . push ( ']' ) ; break ; default : if ( s . isEmpty ( ) || bracket != s . peek ( ) ) { return false ; } s . pop ( ) ; } return s . isEmpty ( ) ; } }
703,"boolean isBalanced ( String brackets ) { Map < Character , Character > braces = new HashMap < > ( ) ; braces . put ( '(' , ')' ) ; braces . put ( '[' , ']' ) ; braces . put ( '{' , '}' ) ; if ( brackets . length ( ) % 2 != 0 ) { return false ; } Stack < Character > halfBraces = new Stack ( ) ; for ( char ch : brackets . toCharArray ( ) ) { if ( braces . containsKey ( ch ) ) { halfBraces . push ( braces . get ( ch ) ) ; } else if ( halfBraces . isEmpty ( ) || ch != halfBraces . pop ( ) ) { return false ; } } return halfBraces . isEmpty ( ) ; }"
704,"void actionPerformed ( ActionEvent e ) { JFileChooser ch = getFileChooser ( ) ; int result = ch . showSaveDialog ( gui ) ; if ( result == JFileChooser . APPROVE_OPTION ) { try { File f = ch . getSelectedFile ( ) ; ImageIO . write ( BasicPaint . this . canvasImage , ""png"" , f ) ; BasicPaint . this . originalImage = BasicPaint . this . canvasImage ; dirty = false ; } catch ( IOException ioe ) { showError ( ioe ) ; ioe . printStackTrace ( ) ; } } }"
705,"void actionPerformed ( ActionEvent e ) { int x = ( int ) ( Math . random ( ) * getWidth ( ) ) ; int y = ( int ) ( Math . random ( ) * getHeight ( ) ) ; int width = ( int ) ( Math . random ( ) * ( getWidth ( ) / 4 ) ) ; int height = ( int ) ( Math . random ( ) * ( getHeight ( ) / 4 ) ) ; if ( x + width > getWidth ( ) ) { x = getWidth ( ) - width ; } if ( y + height > getHeight ( ) ) { y = getHeight ( ) - height ; } Color color = new Color ( ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) , ( int ) ( Math . random ( ) * 255 ) ) ; lstShapes . add ( new MyRectangle ( x , y , width , height , color ) ) ; repaint ( ) ; }"
706,boolean isPrime ( int n ) { int i ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
707,bool isPrime ( int number ) { if ( number < 2 ) return false ; if ( number == 2 ) return true ; if ( number % 2 == 0 ) return false ; for ( int i = 3 ; ( i * i ) <= number ; i += 2 ) { if ( number % i == 0 ) return false ; } return true ; }
708,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
709,"void transform ( Integer hash , HSSFCellStyle styleOld , XSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( styleOld . getFont ( this . workbookOld ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
710,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( value . isEmpty ( ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! tensName . isEmpty ( ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
711,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
712,boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! Person . class . isAssignableFrom ( obj . getClass ( ) ) ) { return false ; } final Person other = ( Person ) obj ; if ( ( this . name == null ) ? ( other . name != null ) : ! this . name . equals ( other . name ) ) { return false ; } if ( this . age != other . age ) { return false ; } return true ; }
713,boolean equals ( Object other ) { boolean result ; if ( ( other == null ) || ( getClass ( ) != other . getClass ( ) ) ) { result = false ; } else { People otherPeople = ( People ) other ; result = name . equals ( otherPeople . name ) && age == otherPeople . age ; } return result ; }
714,"void main ( String [ ] args ) { int [ ] A = { 9 , 5 , 4 , 3 , 2 , 1 , 34 , 53 } ; int [ ] B = new int [ A . length ] ; int [ ] C = new int [ A . length ] ; int t = 4 ; int j = 0 , k = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { B [ j ] = A [ i ] ; j ++ ; } else { C [ k ] = A [ i ] ; k ++ ; } } for ( int i = 0 ; i < j ; i ++ ) { System . out . println ( ""B = "" + B [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) { System . out . println ( ""C = "" + C [ i ] ) ; } }"
715,"void main ( String [ ] args ) { int [ ] A = { 9 , 5 , 4 , 3 , 2 , 1 , 34 , 53 } ; int t = 4 ; int count = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { count ++ ; } } int [ ] B = new int [ count ] ; int [ ] C = new int [ A . length - count ] ; for ( int i = 0 , j = 0 , k = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { B [ j ] = A [ i ] ; System . out . println ( ""B = "" + B [ j ] ) ; j ++ ; } else { C [ k ] = A [ i ] ; System . out . println ( ""C = "" + C [ k ] ) ; k ++ ; } } }"
716,void removeDuplicates ( char [ ] str ) { if ( str == null ) return ; int len = str . length ; if ( len < 2 ) return ; int tail = 1 ; for ( int i = 1 ; i < len ; ++ i ) { int j ; for ( j = 0 ; j < tail ; ++ j ) { if ( str [ i ] == str [ j ] ) break ; } if ( j == tail ) { str [ tail ] = str [ i ] ; ++ tail ; } } str [ tail ] = 0 ; }
717,"String removeDuplicates ( String s ) { StringBuilder noDupes = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String si = s . substring ( i , i + 1 ) ; if ( noDupes . indexOf ( si ) == - 1 ) { noDupes . append ( si ) ; } } return noDupes . toString ( ) ; }"
718,String toJavaMethodName ( String xmlmethodName ) { StringBuilder nameBuilder = new StringBuilder ( xmlmethodName . length ( ) ) ; boolean capitalizeNextChar = false ; for ( char c : xmlMethodName . toCharArray ( ) ) { if ( c == '-' ) { capitalizeNextChar = true ; continue ; } if ( capitalizeNextChar ) { nameBuilder . append ( Character . toUpperCase ( c ) ) ; } else { nameBuilder . append ( c ) ; } capitalizeNextChar = false ; } return nameBuilder . toString ( ) ; }
719,String toJavaMethodName ( final String nonJavaMethodName ) { final StringBuilder nameBuilder = new StringBuilder ( ) ; boolean capitalizeNextChar = false ; boolean first = true ; for ( int i = 0 ; i < nonJavaMethodName . length ( ) ; i ++ ) { final char c = nonJavaMethodName . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) ) { if ( ! first ) { capitalizeNextChar = true ; } } else { nameBuilder . append ( capitalizeNextChar ? Character . toUpperCase ( c ) : Character . toLowerCase ( c ) ) ; capitalizeNextChar = false ; first = false ; } } return nameBuilder . toString ( ) ; }
720,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
721,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
722,"void type ( String characters ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection stringSelection = new StringSelection ( characters ) ; clipboard . setContents ( stringSelection , clipboardOwner ) ; robot . keyPress ( KeyEvent . VK_CONTROL ) ; robot . keyPress ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_CONTROL ) ; }"
723,void type ( String text ) { char c ; for ( int ii = 0 ; ii < text . length ( ) ; ii ++ ) { c = text . charAt ( ii ) ; if ( c <= 31 || c == 129 ) { pressControlKey ( c ) ; } else { typeAsciiCode ( c ) ; } } }
724,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { CharSequence out = super . filter ( source , start , end , dest , dstart , dend ) ; if ( out != null ) { source = out ; start = 0 ; end = out . length ( ) ; } int len = end - start ; if ( len == 0 ) { return source ; } int dlen = dest . length ( ) ; for ( int i = 0 ; i < dstart ; i ++ ) { if ( dest . charAt ( i ) == '.' ) { return ( dlen - ( i + 1 ) + len > digits ) ? """" : new SpannableStringBuilder ( source , start , end ) ; } } for ( int i = start ; i < end ; ++ i ) { if ( source . charAt ( i ) == '.' ) { if ( ( dlen - dend ) + ( end - ( i + 1 ) ) > digits ) return """" ; else break ; } } return new SpannableStringBuilder ( source , start , end ) ; }"
725,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { int dotPos = - 1 ; int len = dest . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = dest . charAt ( i ) ; if ( c == '.' || c == ',' ) { dotPos = i ; break ; } } if ( dotPos >= 0 ) { if ( source . equals ( ""."" ) || source . equals ( "","" ) ) { return """" ; } if ( dend <= dotPos ) { return null ; } if ( len - dotPos > decimalDigits ) { return """" ; } } return null ; }"
726,"String [ ] tokenizer ( String text , String [ ] delims ) { for ( String delim : delims ) { int i = text . indexOf ( delim ) ; if ( i >= 0 ) { String [ ] tail = tokenizer ( text . substring ( i + delim . length ( ) ) , delims ) ; String [ ] list = new String [ tail . length + 2 ] ; list [ 0 ] = text . substring ( 0 , i ) ; list [ 1 ] = delim ; System . arraycopy ( tail , 0 , list , 2 , tail . length ) ; return list ; } } return new String [ ] { text } ; }"
727,"Object [ ] tokenizer ( String value , String [ ] delimeters ) { List < String > list = new ArrayList < String > ( ) ; for ( String s : delimeters ) { if ( value . contains ( s ) ) { String [ ] strArr = value . split ( ""\\"" + s ) ; for ( String str : strArr ) { list . add ( str ) ; if ( ! list . contains ( s ) ) { list . add ( s ) ; } } } } Object [ ] newValues = list . toArray ( ) ; return newValues ; }"
728,"void main ( String [ ] args ) { String [ ] [ ] arr = new String [ ] [ ] { new String [ ] { ""continents"" , ""abc"" } , new String [ ] { ""name"" , ""test"" } , new String [ ] { ""something"" , ""test something"" } , } ; int indexOfNameArray = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( indexOfNameArray > - 1 && indexOfNameArray < arr . length - 1 ) { String [ ] temp = arr [ i ] ; arr [ i ] = arr [ i - 1 ] ; arr [ i - 1 ] = temp ; indexOfNameArray = i ; } else if ( arr [ i ] [ 0 ] . equals ( ""name"" ) ) { indexOfNameArray = i ; } } for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { System . out . print ( arr [ i ] [ j ] + "", "" ) ; } System . out . println ( ) ; } }"
729,"void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String [ ] [ ] array = new String [ 7 ] [ ] ; array [ 0 ] = new String [ ] { ""continents"" , ""Asia"" , ""Europe"" , ""Africa"" , ""Australia"" , ""South America"" , ""North America"" } ; array [ 1 ] = new String [ ] { ""profession"" , ""teacher"" , ""doctor"" , ""lawyer"" } ; array [ 2 ] = new String [ ] { ""brand"" , ""apple"" , ""samsung"" } ; array [ 3 ] = new String [ ] { ""name"" , ""lisa"" , ""peter"" , ""sam"" , ""jack"" } ; array [ 4 ] = new String [ ] { ""profession"" , ""engineer"" , ""Professor"" , ""Dentist"" , ""Driver"" } ; array [ 5 ] = new String [ ] { ""sex"" , ""value"" , ""male"" , ""female"" } ; array [ 6 ] = new String [ ] { ""exp"" , ""value"" , ""1"" , ""2"" , ""3"" , ""4"" } ; int index = sc . nextInt ( ) ; String [ ] tempReference = array [ index - 1 ] ; for ( int i = index - 1 ; i < array . length - 1 ; i ++ ) { array [ i ] = array [ i + 1 ] ; } array [ array . length - 1 ] = tempReference ; for ( String [ ] tempArray : array ) { for ( String s : tempArray ) { System . out . print ( s + "" "" ) ; } System . out . println ( ) ; } }"
730,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int [ ] seen = new int [ 256 ] ; Arrays . fill ( seen , 0 ) ; s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { seen [ s1 . charAt ( i ) ] = seen [ s1 . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( seen [ s2 . charAt ( i ) ] == 0 ) return false ; seen [ s2 . charAt ( i ) ] = seen [ s2 . charAt ( i ) ] - 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( seen [ i ] != 0 ) return false ; } return true ; }"
731,"boolean isAnagram ( String first , String second ) { String positive = first . toLowerCase ( ) ; String negative = second . toLowerCase ( ) ; if ( positive . length ( ) != negative . length ( ) ) { return false ; } int [ ] counts = new int [ 26 ] ; int diff = 0 ; for ( int i = 0 ; i < positive . length ( ) ; i ++ ) { int pos = ( int ) positive . charAt ( i ) - 97 ; if ( counts [ pos ] >= 0 ) { diff ++ ; } else { diff -- ; } counts [ pos ] ++ ; int neg = ( int ) negative . charAt ( i ) - 97 ; if ( counts [ neg ] <= 0 ) { diff ++ ; } else { diff -- ; } counts [ neg ] -- ; } return diff == 0 ; }"
732,"void main ( String args [ ] ) { System . out . println ( ""Enter the date(dd/mm/yyyy):"" ) ; Scanner scan = new Scanner ( System . in ) ; String Date = scan . nextLine ( ) ; try { boolean dateValid = dateValidate ( Date ) ; if ( dateValid == true ) { SimpleDateFormat df = new SimpleDateFormat ( ""dd/MM/yy"" ) ; java . util . Date date = df . parse ( Date ) ; df . applyPattern ( ""EEE"" ) ; String day = df . format ( date ) ; if ( day . compareTo ( ""Sat"" ) == 0 || day . compareTo ( ""Sun"" ) == 0 ) { System . out . println ( day + "": Weekend"" ) ; } else { System . out . println ( day + "": Weekday"" ) ; } } else { System . out . println ( ""Invalid Date!!!"" ) ; } } catch ( Exception e ) { System . out . println ( ""Invalid Date Formats!!!"" ) ; } }"
733,"void main ( String [ ] args ) throws ParseException , ParseException { anchorDaysMap . put ( Integer . valueOf ( 0 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1700 ) ) ; add ( Integer . valueOf ( 2100 ) ) ; add ( Integer . valueOf ( 2500 ) ) ; } } ) ; anchorDaysMap . put ( Integer . valueOf ( 2 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1600 ) ) ; add ( Integer . valueOf ( 2000 ) ) ; add ( Integer . valueOf ( 2400 ) ) ; } } ) ; anchorDaysMap . put ( Integer . valueOf ( 3 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1500 ) ) ; add ( Integer . valueOf ( 1900 ) ) ; add ( Integer . valueOf ( 2300 ) ) ; } } ) ; anchorDaysMap . put ( Integer . valueOf ( 5 ) , new ArrayList < Integer > ( ) { { add ( Integer . valueOf ( 1800 ) ) ; add ( Integer . valueOf ( 2200 ) ) ; add ( Integer . valueOf ( 2600 ) ) ; } } ) ; doomsdayDate . put ( Integer . valueOf ( 1 ) , Integer . valueOf ( 3 ) ) ; doomsdayDate . put ( Integer . valueOf ( 2 ) , Integer . valueOf ( 14 ) ) ; doomsdayDate . put ( Integer . valueOf ( 3 ) , Integer . valueOf ( 14 ) ) ; doomsdayDate . put ( Integer . valueOf ( 4 ) , Integer . valueOf ( 4 ) ) ; doomsdayDate . put ( Integer . valueOf ( 5 ) , Integer . valueOf ( 9 ) ) ; doomsdayDate . put ( Integer . valueOf ( 6 ) , Integer . valueOf ( 6 ) ) ; doomsdayDate . put ( Integer . valueOf ( 7 ) , Integer . valueOf ( 4 ) ) ; doomsdayDate . put ( Integer . valueOf ( 8 ) , Integer . valueOf ( 8 ) ) ; doomsdayDate . put ( Integer . valueOf ( 9 ) , Integer . valueOf ( 5 ) ) ; doomsdayDate . put ( Integer . valueOf ( 10 ) , Integer . valueOf ( 10 ) ) ; doomsdayDate . put ( Integer . valueOf ( 11 ) , Integer . valueOf ( 7 ) ) ; doomsdayDate . put ( Integer . valueOf ( 12 ) , Integer . valueOf ( 12 ) ) ; long time = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100000 ; i ++ ) { int year = 1583 + new Random ( ) . nextInt ( 500 ) ; int month = 1 + new Random ( ) . nextInt ( 12 ) ; int day = 1 + new Random ( ) . nextInt ( 7 ) ; int twoDigitsYear = ( year % 100 ) ; int century = year - twoDigitsYear ; int adForCentury = getADCentury ( century ) ; int dd = ( ( int ) twoDigitsYear / 12 ) + twoDigitsYear % 12 + ( int ) ( ( twoDigitsYear % 12 ) / 4 ) ; int referenceDay = doomsdayDate . get ( month ) ; int gap = ( day - referenceDay ) % 7 ; int result = ( gap + adForCentury + dd ) % 7 ; if ( result < 0 ) { result *= - 1 ; } String dayDate = weekdays [ ( result + 1 ) % 8 ] ; } System . out . println ( ""time (ms) : "" + ( System . currentTimeMillis ( ) - time ) ) ; time = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100000 ; i ++ ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( new SimpleDateFormat ( ""dd/MM/yyyy"" ) . parse ( ""12/04/1861"" ) ) ; int result2 = c . get ( Calendar . DAY_OF_WEEK ) ; } System . out . println ( ""time (ms) : "" + ( System . currentTimeMillis ( ) - time ) ) ; }"
734,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
735,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
736,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
737,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
738,void actionPerformed ( ActionEvent evt ) { NewComboBox combo = ( NewComboBox ) evt . getSource ( ) ; String selection = combo . getSelectedItem ( ) . toString ( ) ; for ( int i = 0 ; i < comboBoxes . length ; i ++ ) { NewComboBox comboI = comboBoxes [ i ] ; if ( comboI != combo && comboI . getSelectedItem ( ) . equals ( selection ) ) { comboI . setSelectedItem ( combo . getPreviousSelectedItem ( ) ) ; } } }
739,void actionPerformed ( ActionEvent e ) { String item = ( String ) mainComboBox . getSelectedItem ( ) ; Object o = subItems . get ( item ) ; if ( o == null ) { subComboBox . setModel ( new DefaultComboBoxModel ( ) ) ; } else { subComboBox . setModel ( new DefaultComboBoxModel ( ( String [ ] ) o ) ) ; } }
740,"void onPageScrollStateChanged ( int state ) { Log . v ( ""onPageScrollStateChanged"" , String . valueOf ( state ) ) ; if ( state == ViewPager . SCROLL_STATE_IDLE ) { int index = pager . getCurrentItem ( ) ; if ( index == 0 ) pager . setCurrentItem ( adapter . getCount ( ) - 2 , false ) ; else if ( index == adapter . getCount ( ) - 1 ) pager . setCurrentItem ( 1 , false ) ; } }"
741,"void onPageScrollStateChanged ( int state ) { if ( state == ViewPager . SCROLL_STATE_IDLE ) { PagerAdapter pagerAdapter = viewPager . getAdapter ( ) ; if ( pagerAdapter != null ) { int itemCount = pagerAdapter . getCount ( ) ; if ( itemCount < 2 ) { return ; } int index = viewPager . getCurrentItem ( ) ; if ( index == 0 ) { viewPager . setCurrentItem ( itemCount - 2 , false ) ; } else if ( index == itemCount - 1 ) { viewPager . setCurrentItem ( 1 , false ) ; } } } }"
742,"void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter String"" ) ; String s = br . readLine ( ) ; System . out . print ( ""Enter Integer:"" ) ; try { int i = Integer . parseInt ( br . readLine ( ) ) ; } catch ( NumberFormatException nfe ) { System . err . println ( ""Invalid Format!"" ) ; } }"
743,"void main ( final String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( ""Enter some text, or '"" + EXIT_COMMAND + ""' to quit"" ) ; while ( true ) { System . out . print ( ""><![CDATA[ "" ) ; String input = br . readLine ( ) ; System . out . println ( input ) ; if ( input . length ( ) == EXIT_COMMAND . length ( ) && input . toLowerCase ( ) . equals ( EXIT_COMMAND ) ) { System . out . println ( ""Exiting."" ) ; return ; } System . out . println ( ""...response goes here..."" ) ; } }"
744,"void run ( ) { int i = 1 ; while ( i < 50 ) { while ( s . getState ( ) != 3 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 3 ) System . out . println ( ""t1 "" + i ) ; s . setState ( 1 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
745,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tac"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
746,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
747,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
748,void shuffle ( T [ ] ar ) { for ( int i = ar . length - 1 ; i > 0 ; i -- ) { int index = rnd . nextInt ( i + 1 ) ; T a = ar [ index ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } }
749,"void shuffle ( int [ ] array ) { if ( random == null ) random = new Random ( ) ; int count = array . length ; for ( int i = count ; i > 1 ; i -- ) { swap ( array , i - 1 , random . nextInt ( i ) ) ; } }"
750,"void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { HttpServletRequest req = ( HttpServletRequest ) request ; if ( req . getHeader ( ""x-dawson-nonce"" ) == null || req . getHeader ( ""x-dawson-signature"" ) == null ) { HttpServletResponse httpResponse = ( HttpServletResponse ) response ; httpResponse . setContentType ( ""application/json"" ) ; httpResponse . sendError ( HttpServletResponse . SC_BAD_REQUEST , ""Required headers not specified in the request"" ) ; return ; } chain . doFilter ( request , response ) ; }"
751,"void doFilter ( ServletRequest arg0 , ServletResponse response , FilterChain chain ) throws IOException , ServletException { logger . info ( ""checking client id in filter"" ) ; HttpServletRequest request = ( HttpServletRequest ) arg0 ; String clientId = request . getHeader ( ""clientId"" ) ; if ( StringUtils . isNotEmpty ( clientId ) ) { chain . doFilter ( request , response ) ; } else { logger . error ( ""client id missing."" ) ; } }"
752,"void main ( String [ ] args ) { System . out . println ( ""Main Method Started"" ) ; Scanner in = new Scanner ( System . in ) ; System . out . println ( ""Enter the size of the arr"" ) ; int size = in . nextInt ( ) ; System . out . println ( ""Enter the maximum value of the arr"" ) ; int max = in . nextInt ( ) ; int [ ] arr = initializeArr ( max , size ) ; print ( arr ) ; findMinMax ( arr ) ; System . out . println ( ""Main Method Ended"" ) ; }"
753,"void main ( String args [ ] ) { int n , max = Integer . MIN_VALUE , min = Integer . MAX_VALUE ; System . out . println ( ""Enter the number of elements: "" ) ; Scanner sc = new Scanner ( System . in ) ; int [ ] arr = new int [ sc . nextInt ( ) ] ; System . out . println ( ""Enter the elements: "" ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int next = sc . nextInt ( ) ; arr [ i ] = next ; } for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ j ] > max ) max = arr [ j ] ; else if ( arr [ j ] < min ) min = arr [ j ] ; } System . out . println ( ""Highest Value in array: "" + max ) ; System . out . println ( ""Smallest Value in array: "" + min ) ; }"
754,"void addPersonButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String firstName = firstNameTextField . getText ( ) ; String lastName = lastNameTextField . getText ( ) ; String emailAddress = emailTextField . getText ( ) ; if ( isNameValid ( firstName , ""First name"" ) && isNameValid ( lastName , ""Last name"" ) && isEmailValid ( emailAddress , ""Email address"" ) ) { personArrayList . add ( new Person ( firstName , lastName , emailAddress ) ) ; System . out . println ( ""Person added!"" ) ; } }"
755,"void addPersonButtonActionPerformed ( java . awt . event . ActionEvent evt ) { String firstName = firstNameTextField . getText ( ) ; String lastName = lastNameTextField . getText ( ) ; String emailAddress = emailTextField . getText ( ) ; boolean valid = true ; if ( firstName . equals ( """" ) ) { System . out . println ( ""First Name is missing"" ) ; valid = false ; } if ( lastName . equals ( """" ) ) { System . out . println ( ""Last Name is missing"" ) ; valid = false ; } if ( emailAddress . equals ( """" ) ) { System . out . println ( ""E-Mail address is missing"" ) ; valid = false ; } if ( ! Email . isValid ( emailAddress ) ) { System . out . println ( ""E-Mail address is invalid"" ) ; valid = false ; } if ( valid ) { personArrayList . add ( new Person ( firstName , lastName , emailAddress ) ) ; System . out . println ( ""Person added!"" ) ; } }"
756,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String replacement = source . subSequence ( start , end ) . toString ( ) ; String newVal = dest . subSequence ( 0 , dstart ) . toString ( ) + replacement + dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; Matcher matcher = mPattern . matcher ( newVal ) ; if ( matcher . matches ( ) ) return null ; if ( TextUtils . isEmpty ( source ) ) return dest . subSequence ( dstart , dend ) ; else return """" ; }"
757,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { int dotPos = - 1 ; int len = dest . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = dest . charAt ( i ) ; if ( c == '.' || c == ',' ) { dotPos = i ; break ; } } if ( dotPos >= 0 ) { if ( source . equals ( ""."" ) || source . equals ( "","" ) ) { return """" ; } if ( dend <= dotPos ) { return null ; } if ( len - dotPos > decimalDigits ) { return """" ; } } return null ; }"
758,boolean isImmutable ( Object object ) { if ( object instanceof Number ) { if ( object instanceof AtomicInteger ) { } else if ( object instanceof AtomicLong ) { } else { return true ; } } else if ( object instanceof String ) { return true ; } else if ( object instanceof Character ) { return true ; } else if ( object instanceof Class ) { return true ; } Class < ? > objClass = object . getClass ( ) ; if ( ! Modifier . isFinal ( objClass . getModifiers ( ) ) ) { return false ; } Field [ ] objFields = objClass . getDeclaredFields ( ) ; for ( int i = 0 ; i < objFields . length ; i ++ ) { if ( ! Modifier . isFinal ( objFields [ i ] . getModifiers ( ) ) || ! isImmutable ( objFields [ i ] . getType ( ) ) ) { return false ; } } return true ; }
759,boolean isImmutable ( Object obj ) { Class < ? > objClass = obj . getClass ( ) ; Class < ? > superClass = objClass . getSuperclass ( ) ; if ( ! Immutable . class . equals ( superClass ) ) { return false ; } if ( ! Modifier . isFinal ( objClass . getModifiers ( ) ) ) { return false ; } Field [ ] objFields = objClass . getDeclaredFields ( ) ; for ( int i = 0 ; i < objFields . length ; i ++ ) { if ( ! Modifier . isFinal ( objFields [ i ] . getModifiers ( ) ) || ! isValidFieldType ( objFields [ i ] . getType ( ) ) ) { return false ; } } return true ; }
760,"void main ( String ... args ) { final int MAX_VAL = 10000 ; int [ ] currentIndex = { 0 , 0 , 0 , 0 } ; int [ ] remaining = { 50 , 50 , 50 , 50 } ; int [ ] [ ] sequence = new int [ 4 ] [ 50 ] ; while ( keepWorking ( remaining ) ) { int currentMethod = chooseMethod ( remaining ) ; switch ( currentMethod ) { case 0 : sequence [ currentMethod ] [ currentIndex [ currentMethod ] ] = getLL ( MAX_VAL ) ; break ; case 1 : sequence [ currentMethod ] [ currentIndex [ currentMethod ] ] = getAL ( MAX_VAL ) ; break ; case 2 : sequence [ currentMethod ] [ currentIndex [ currentMethod ] ] = getLLIt ( MAX_VAL ) ; break ; default : sequence [ currentMethod ] [ currentIndex [ currentMethod ] ] = getALIt ( MAX_VAL ) ; break ; } remaining [ currentMethod ] -- ; currentIndex [ currentMethod ] ++ ; } for ( int [ ] ar : sequence ) { Arrays . sort ( ar ) ; } System . out . println ( ""Time (us\nLL    \tAL\tLL incr\t AL incr"" ) ; for ( int i = 0 ; i < sequence [ 0 ] . length ; i ++ ) { System . out . println ( sequence [ 0 ] [ i ] + ""\t"" + sequence [ 1 ] [ i ] + ""\t"" + sequence [ 2 ] [ i ] + ""\t"" + sequence [ 3 ] [ i ] ) ; } System . out . println ( ""\nTime normalized to fastest run of a method\nLL\tAL\tLL incr\t AL incr"" ) ; for ( int i = 0 ; i < sequence [ 0 ] . length ; i ++ ) { System . out . print ( i ) ; for ( int j = 0 ; j < sequence . length ; j ++ ) { int a = sequence [ j ] [ i ] / ( sequence [ j ] [ 0 ] / 100 ) ; System . out . print ( ""\t"" + a ) ; } System . out . println ( ) ; } }"
761,"void main ( String ... args ) { final int MAX_VAL = 10000 ; List < Integer > linkedList = new LinkedList < Integer > ( ) ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < MAX_VAL ; i ++ ) { linkedList . add ( i ) ; arrayList . add ( i ) ; } long time = System . nanoTime ( ) ; for ( int i = 0 ; i < MAX_VAL ; i ++ ) { linkedList . add ( MAX_VAL / 2 , i ) ; } System . out . println ( ""LL time:\t"" + ( System . nanoTime ( ) - time ) ) ; time = System . nanoTime ( ) ; for ( int i = 0 ; i < MAX_VAL ; i ++ ) { arrayList . add ( MAX_VAL / 2 , i ) ; } System . out . println ( ""AL time:\t"" + ( System . nanoTime ( ) - time ) ) ; linkedList = new LinkedList < Integer > ( ) ; arrayList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < MAX_VAL ; i ++ ) { linkedList . add ( i ) ; arrayList . add ( i ) ; } time = System . nanoTime ( ) ; ListIterator < Integer > li = linkedList . listIterator ( MAX_VAL / 2 ) ; for ( int i = 0 ; i < MAX_VAL ; i ++ ) { li . add ( i ) ; } System . out . println ( ""LL iterator:\t"" + ( System . nanoTime ( ) - time ) ) ; time = System . nanoTime ( ) ; ListIterator < Integer > ali = arrayList . listIterator ( MAX_VAL / 2 ) ; for ( int i = 0 ; i < MAX_VAL ; i ++ ) { ali . add ( i ) ; } System . out . println ( ""AL iterator:\t"" + ( System . nanoTime ( ) - time ) ) ; }"
762,"void main ( String [ ] args ) { String str = ""abcdabghplhhnfl"" . toLowerCase ( ) ; Integer [ ] ar = new Integer [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = str . charAt ( i ) - 'a' ; if ( ar [ j ] == null ) { ar [ j ] = 1 ; } else { ar [ j ] += 1 ; } } for ( int i = 0 ; i < ar . length ; i ++ ) { if ( ar [ i ] != null && ar [ i ] > 1 ) { char c = ( char ) ( 97 + i ) ; System . out . println ( ""'"" + c + ""' comes "" + ar [ i ] + "" times."" ) ; } } }"
763,"void main ( String [ ] args ) { HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; System . out . println ( ""Enter an String:"" ) ; Scanner sc = new Scanner ( System . in ) ; String s1 = sc . nextLine ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! hm . containsKey ( s1 . charAt ( i ) ) ) { hm . put ( s1 . charAt ( i ) , ( Integer ) 1 ) ; } else { hm . put ( s1 . charAt ( i ) , hm . get ( s1 . charAt ( i ) ) + 1 ) ; } } System . out . println ( ""The Charecters are:"" + hm ) ; }"
764,"void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = Integer . parseInt ( in . nextLine ( ) ) ; int [ ] N = new int [ T ] ; int [ ] A = new int [ T ] ; int [ ] B = new int [ T ] ; double [ ] Probability = new double [ T ] ; for ( int t = 0 ; t < T ; t ++ ) { String [ ] input = in . nextLine ( ) . split ( "" "" ) ; N [ t ] = Integer . parseInt ( input [ 0 ] ) ; A [ t ] = Integer . parseInt ( input [ 1 ] ) ; B [ t ] = Integer . parseInt ( input [ 2 ] ) ; int total , pa = 0 , pb = 0 ; String [ ] faces = in . nextLine ( ) . split ( "" "" ) ; total = faces . length ; for ( String f : faces ) { if ( Integer . parseInt ( f ) == A [ t ] ) { pa ++ ; } if ( Integer . parseInt ( f ) == B [ t ] ) { pb ++ ; } } double pn = ( double ) ( total * total ) ; Probability [ t ] = ( pa * pb ) / pn ; } for ( double d : Probability ) { System . out . println ( d ) ; } }"
765,void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String line = scanner . nextLine ( ) ; int trys = Integer . parseInt ( line . trim ( ) ) ; for ( int i = 0 ; i < trys ; i ++ ) { double probability = processTry ( scanner ) ; System . out . println ( probability ) ; } scanner . close ( ) ; }
766,"void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { jgen . writeStartObject ( ) ; JavaType javaType = provider . constructType ( CustomClass . class ) ; BeanDescription beanDesc = provider . getConfig ( ) . introspect ( javaType ) ; JsonSerializer < Object > serializer = BeanSerializerFactory . instance . findBeanSerializer ( provider , javaType , beanDesc ) ; serializer . unwrappingSerializer ( null ) . serialize ( value , jgen , provider ) ; jgen . writeObjectField ( ""my_extra_field"" , ""some data"" ) ; jgen . writeEndObject ( ) ; }"
767,"void serialize ( final Object bean , final JsonGenerator jgen , final SerializerProvider provider ) throws IOException , JsonGenerationException { jgen . writeStartObject ( ) ; if ( _propertyFilterId != null ) { serializeFieldsFiltered ( bean , jgen , provider ) ; } else { serializeFields ( bean , jgen , provider ) ; } serializerListener . postSerialization ( bean , jgen ) ; jgen . writeEndObject ( ) ; }"
768,"void main ( String [ ] args ) { int n = 7 ; for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( i + j <= n - 4 || j == 0 || i == n - 1 ) System . out . print ( ""*"" ) ; else if ( i - j >= n - 4 ) System . out . print ( ""*"" ) ; else System . out . print ( "" "" ) ; } System . out . println ( ) ; } }"
769,"void main ( String [ ] args ) { int n = 7 ; int mid = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < Math . abs ( mid - i ) + 1 ; j ++ ) { System . out . print ( ""*"" ) ; } System . out . println ( ) ; } }"
770,"void main ( String [ ] args ) throws IOException { String ch ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter the Statement:"" ) ; ch = br . readLine ( ) ; int count = 0 , len = 0 ; do { try { char name [ ] = ch . toCharArray ( ) ; len = name . length ; count = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( ( name [ 0 ] == name [ j ] ) && ( ( name [ 0 ] >= 65 && name [ 0 ] <= 91 ) || ( name [ 0 ] >= 97 && name [ 0 ] <= 123 ) ) ) count ++ ; } if ( count != 0 ) System . out . println ( name [ 0 ] + "" "" + count + "" Times"" ) ; ch = ch . replace ( """" + name [ 0 ] , """" ) ; } catch ( Exception ex ) { } } while ( len != 1 ) ; }"
771,"void main ( String ... a ) { System . out . print ( ""Enter the String"" ) ; Scanner sc = new Scanner ( System . in ) ; String st = sc . nextLine ( ) ; int [ ] ar = new int [ 256 ] ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { ar [ st . charAt ( i ) ] = ar [ st . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { char ch = ( char ) i ; if ( ar [ i ] > 0 ) { if ( ar [ i ] == 1 ) { System . out . print ( ch ) ; } else { System . out . print ( ch + """" + ar [ i ] ) ; } } } }"
772,"void show ( String columnName ) { IndexedColumn ic = hidden . remove ( columnName ) ; if ( ic != null ) { tcm . addColumn ( ic . column ) ; int lastColumn = tcm . getColumnCount ( ) - 1 ; if ( ic . index < lastColumn ) { tcm . moveColumn ( lastColumn , ic . index ) ; } } }"
773,"void show ( String columnName ) { Object o = hiddenColumns . remove ( columnName ) ; if ( o == null ) { return ; } tcm . addColumn ( ( TableColumn ) o ) ; o = hiddenColumns . remove ( "":"" + columnName ) ; if ( o == null ) { return ; } int column = ( ( Integer ) o ) . intValue ( ) ; int lastColumn = tcm . getColumnCount ( ) - 1 ; if ( column < lastColumn ) { tcm . moveColumn ( lastColumn , column ) ; } }"
774,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ! s1 . contains ( """" + s2 . charAt ( i ) ) ) { return false ; } s1 = s1 . replaceFirst ( """" + s2 . charAt ( i ) , """" ) ; s2 = s2 . replaceFirst ( """" + s2 . charAt ( i ) , """" ) ; } return true ; }"
775,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int n = s1 . length ( ) ; int [ ] charMap = new int [ 256 ] ; for ( int i = 0 ; i < n ; i ++ ) { char c1 = s1 . charAt ( i ) ; charMap [ c1 ] ++ ; char c2 = s2 . charAt ( i ) ; charMap [ c2 ] -- ; } for ( int i = 0 ; i < charMap . length ; i ++ ) { if ( charMap [ i ] != 0 ) return false ; } return true ; }"
776,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
777,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , HSSFSheet sheetOld , XSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; XSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( HSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
778,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
779,"HSSFFont transform ( HSSFWorkbook workbookNew , XSSFFont fontOld ) { HSSFFont fontNew = workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }"
780,"void main ( String [ ] args ) throws Exception { AuthMethod auth = new TokenAuthMethod ( API_KEY , API_SECRET ) ; NexmoClient client = new NexmoClient ( auth ) ; TextMessage message = new TextMessage ( FROM_NUMBER , TO_NUMBER , ""Hello from Nexmo!"" ) ; SmsSubmissionResult [ ] responses = client . getSmsClient ( ) . submitMessage ( message ) ; for ( SmsSubmissionResult response : responses ) { System . out . println ( response ) ; } }"
781,"void main ( String args [ ] ) { GSMConnect gsm = new GSMConnect ( comPort ) ; if ( gsm . init ( ) ) { try { System . out . println ( ""Initialization Success"" ) ; gsm . connect ( ) ; Thread . sleep ( 5000 ) ; gsm . checkStatus ( ) ; Thread . sleep ( 5000 ) ; gsm . sendMessage ( ""+91XXXXXXXX"" , ""Trial Success"" ) ; Thread . sleep ( 1000 ) ; gsm . hangup ( ) ; Thread . sleep ( 1000 ) ; gsm . closePort ( ) ; gsm . outCommand ( ) ; System . exit ( 1 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else { System . out . println ( ""Can't init this card"" ) ; } }"
782,"void main ( String [ ] args ) { try { String input = """" ; char c = ( char ) System . in . read ( ) ; while ( c != '\n' ) { input += c ; c = ( char ) System . in . read ( ) ; } System . out . println ( input ) ; } catch ( Exception e ) { System . out . println ( e ) ; } }"
783,"void main ( String [ ] args ) { Scanner kb = new Scanner ( System . in ) ; String name ; int age ; char bloodGroup ; float height ; System . out . println ( ""Enter Your Name"" ) ; name = kb . nextLine ( ) ; System . out . println ( ""Enter Your Age"" ) ; age = kb . nextInt ( ) ; System . out . println ( ""Enter Your BloodGroup : A/B/O only"" ) ; bloodGroup = kb . next ( ) . charAt ( 0 ) ; System . out . println ( ""Enter Your Height in Meters"" ) ; height = kb . nextFloat ( ) ; kb . close ( ) ; System . out . println ( ""Name : "" + name ) ; System . out . println ( ""Age : "" + age ) ; System . out . println ( ""BloodGroup : "" + bloodGroup ) ; System . out . println ( ""Height : "" + height + "" m"" ) ; }"
784,"int evenDigits ( int n ) { int res = 0 ; int mag = 0 ; while ( n > 9 ) { int digit = n % 10 ; n /= 10 ; if ( digit % 2 == 0 ) { res += Math . pow ( 10 , mag ) * digit ; mag ++ ; } } return res ; }"
785,int evenDigits ( int n ) { if ( ( n & 1 ) != 0 ) { return evenDigits ( n / 10 ) ; } if ( n < 10 ) { return n ; } return n % 10 + evenDigits ( n / 10 ) * 10 ; }
786,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
787,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
788,"void main ( String [ ] args ) { String s = ""aaaabbccccdddeee"" ; String s1 = """" ; String s2 = """" ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s1 . indexOf ( s . charAt ( i ) ) < 0 ) { s1 = s1 + s . charAt ( i ) ; } } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s1 . charAt ( i ) == s . charAt ( j ) ) { count ++ ; } } s2 = s2 + s1 . charAt ( i ) + count ; count = 0 ; } System . out . println ( s2 ) ; }"
789,"void main ( String [ ] args ) { String str = ""AAABBBBCC"" ; int length = str . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int count = 1 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == length - 1 ) { sb . append ( str . charAt ( i ) + """" + count ) ; break ; } if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { count ++ ; } else { sb . append ( str . charAt ( i ) + """" + count ) ; count = 1 ; } } System . out . println ( sb . toString ( ) ) ; }"
790,"void run ( ) { try { String line = null ; BufferedReader in = new BufferedReader ( new InputStreamReader ( inStream ) ) ; while ( ( line = in . readLine ( ) ) != null ) { println ( line ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } System . out . println ( ""Exit reading process output"" ) ; }"
791,"void run ( ) { try { int retValue = pro . waitFor ( ) ; println ( ""Command exit with return value "" + retValue ) ; outStream . close ( ) ; outStream = null ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
792,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Distance (m)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; gg . drawString ( string , ( getWidth ( ) - width ) / 2 , 11 ) ; }"
793,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
794,"byte [ ] readBytes ( InputStream inputStream ) throws IOException { byte [ ] b = new byte [ 1024 ] ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; int c ; while ( ( c = inputStream . read ( b ) ) != - 1 ) { os . write ( b , 0 , c ) ; } return os . toByteArray ( ) ; }"
795,"byte [ ] readBytes ( InputStream inputStream ) throws IOException { byte [ ] buffer = new byte [ 32 * 1024 ] ; int bufferSize = 0 ; for ( ; ; ) { int read = inputStream . read ( buffer , bufferSize , buffer . length - bufferSize ) ; if ( read == - 1 ) { return Arrays . copyOf ( buffer , bufferSize ) ; } bufferSize += read ; if ( bufferSize == buffer . length ) { buffer = Arrays . copyOf ( buffer , bufferSize * 2 ) ; } } }"
796,"void main ( String [ ] args ) { CountDownLatch latch = new CountDownLatch ( 1 ) ; System . out . println ( ""Start server"" ) ; ServerModule serverModule = new ServerModule ( latch ) ; serverModule . start ( ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . println ( ""Server is done"" ) ; }"
797,"void main ( String [ ] args ) throws InterruptedException { Thread t = new Thread ( ( ) -> { try { Thread . sleep ( 5000L ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } ) ; System . out . println ( ""Starting Server!"" ) ; t . start ( ) ; t . join ( ) ; System . out . println ( ""Server is done!"" ) ; }"
798,"void main ( String [ ] args ) throws FileNotFoundException , IOException { Path myPath = Paths . get ( ""e:\\"" , ""1.txt"" ) ; List < String > ls ; ls = Files . readAllLines ( myPath , StandardCharsets . US_ASCII ) ; PrintWriter out = new PrintWriter ( ""e:\\2.txt"" ) ; for ( int i = 0 ; i < ls . size ( ) ; i ++ ) { String [ ] temp = ls . get ( i ) . split ( "":"" ) ; if ( temp . length > 1 ) { out . println ( ls . get ( i ) ) ; } } out . close ( ) ; }"
799,"void main ( String [ ] args ) throws FileNotFoundException , IOException { FileInputStream fin = new FileInputStream ( ""line.srt"" ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( fin ) ) ; PrintWriter out = new PrintWriter ( ""newline.srt"" ) ; int i = 0 ; String line = reader . readLine ( ) ; while ( line != null ) { if ( ! line . trim ( ) . equals ( """" ) ) { out . println ( line ) ; } line = reader . readLine ( ) ; } out . close ( ) ; }"
800,"String getContactName ( final String phoneNumber ) { Uri uri ; String [ ] projection ; mBaseUri = Contacts . Phones . CONTENT_FILTER_URL ; projection = new String [ ] { android . provider . Contacts . People . NAME } ; try { Class < ? > c = Class . forName ( ""android.provider.ContactsContract$PhoneLookup"" ) ; mBaseUri = ( Uri ) c . getField ( ""CONTENT_FILTER_URI"" ) . get ( mBaseUri ) ; projection = new String [ ] { ""display_name"" } ; } catch ( Exception e ) { } uri = Uri . withAppendedPath ( mBaseUri , Uri . encode ( phoneNumber ) ) ; Cursor cursor = this . getContentResolver ( ) . query ( uri , projection , null , null , null ) ; String contactName = """" ; if ( cursor . moveToFirst ( ) ) { contactName = cursor . getString ( 0 ) ; } cursor . close ( ) ; cursor = null ; return contactName ; }"
801,"String getContactName ( Context context , String number ) { String name = null ; String [ ] projection = new String [ ] { ContactsContract . PhoneLookup . DISPLAY_NAME , ContactsContract . PhoneLookup . _ID } ; Uri contactUri = Uri . withAppendedPath ( ContactsContract . PhoneLookup . CONTENT_FILTER_URI , Uri . encode ( number ) ) ; Cursor cursor = context . getContentResolver ( ) . query ( contactUri , projection , null , null , null ) ; if ( cursor != null ) { if ( cursor . moveToFirst ( ) ) { name = cursor . getString ( cursor . getColumnIndex ( ContactsContract . PhoneLookup . DISPLAY_NAME ) ) ; Log . v ( TAG , ""Started uploadcontactphoto: Contact Found @ "" + number ) ; Log . v ( TAG , ""Started uploadcontactphoto: Contact name  = "" + name ) ; } else { Log . v ( TAG , ""Contact Not Found @ "" + number ) ; } cursor . close ( ) ; } return name ; }"
802,"int loneSum ( int a , int b , int c ) { if ( a == b && b == c ) { a = 0 ; b = 0 ; c = 0 ; } if ( a == b ) { a = 0 ; b = 0 ; } if ( a == c ) { a = 0 ; c = 0 ; } if ( b == c ) { b = 0 ; c = 0 ; } return a + b + c ; }"
803,"int loneSum ( int a , int b , int c ) { int sum = 0 ; boolean ab = a != b ; boolean ac = a != c ; boolean bc = b != c ; if ( ab && ac ) sum += a ; if ( ab && bc ) sum += b ; if ( bc && ac ) sum += c ; return sum ; }"
804,"void actionPerformed ( ActionEvent e ) { pressed = ! pressed ; if ( pressed ) { for ( JMenuItem item : items ) { item . setText ( item . getText ( ) + "" changed"" ) ; } } else { for ( JMenuItem item : items ) { item . setText ( item . getText ( ) . substring ( 0 , item . getText ( ) . length ( ) - 8 ) ) ; } } }"
805,"void actionPerformed ( ActionEvent e ) { pressed = ! pressed ; if ( pressed ) { for ( JMenuItem item : items ) { item . setText ( item . getText ( ) + "" changed"" ) ; item . setMaximumSize ( new Dimension ( 70 , 50 ) ) ; item . setPreferredSize ( new Dimension ( 70 , 50 ) ) ; item . setMinimumSize ( new Dimension ( 70 , 50 ) ) ; itemPanel . invalidate ( ) ; } } else { for ( JMenuItem item : items ) { item . setText ( item . getText ( ) . substring ( 0 , item . getText ( ) . length ( ) - 8 ) ) ; item . setMaximumSize ( new Dimension ( 130 , 50 ) ) ; item . setPreferredSize ( new Dimension ( 130 , 50 ) ) ; item . setMinimumSize ( new Dimension ( 130 , 50 ) ) ; itemPanel . invalidate ( ) ; } } }"
806,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
807,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
808,void move ( Container container ) { if ( leftRight ) { x += deltaX ; if ( x >= ( Ball . this . getWidth ( ) - canvasWidth / 2 ) ) { leftRight = false ; updateDelta ( ) ; } } else { x += - deltaX ; if ( x <= 0 ) { leftRight = true ; updateDelta ( ) ; } } if ( upDown ) { y += deltaY ; upDown = ! ( y >= ( Ball . this . getHeight ( ) - canvasHeight / 2 ) ) ; if ( y >= ( Ball . this . getHeight ( ) - canvasHeight / 2 ) ) { upDown = false ; updateDelta ( ) ; } } else { y += - deltaY ; if ( y <= 0 ) { upDown = true ; updateDelta ( ) ; } } }
809,void move ( Container container ) { if ( x >= canvasWidth || x <= 0 ) { deltaX = - 1 * deltaX ; } if ( y >= canvasHeight || y <= 0 ) { deltaY = - 1 * deltaY ; } x += deltaX ; y += deltaY ; }
810,"int compare ( int x , int y ) { if ( x & 1 == y & 1 ) { if ( x & 1 == 0 ) { return Integer . compare ( x , y ) ; } else { return Integer . compare ( y , x ) ; } } if ( x & 1 == 0 ) { return - 1 ; } return 1 ; }"
811,"int compare ( Integer o1 , Integer o2 ) { if ( o1 % 2 == 0 ) { if ( o2 % 2 == 0 ) { if ( o1 < o2 ) return - 1 ; else return 1 ; } else { return - 1 ; } } else { if ( o2 % 2 != 0 ) { if ( o1 < o2 ) return 1 ; else return - 1 ; } else { return 1 ; } } }"
812,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( ""How many numbers do you want to enter?"" ) ; int num = input . nextInt ( ) ; int array [ ] = new int [ num ] ; System . out . println ( ""Enter the "" + num + "" numbers now."" ) ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = input . nextInt ( ) ; } System . out . println ( ""These are the numbers you have entered."" ) ; printArray ( array ) ; input . close ( ) ; }"
813,"void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; Scanner stdin = new Scanner ( System . in ) ; do { System . out . println ( ""Current list is "" + list ) ; System . out . println ( ""Add more? (y/n)"" ) ; if ( stdin . next ( ) . startsWith ( ""y"" ) ) { System . out . println ( ""Enter : "" ) ; list . add ( stdin . next ( ) ) ; } else { break ; } } while ( true ) ; stdin . close ( ) ; System . out . println ( ""List is "" + list ) ; String [ ] arr = list . toArray ( new String [ 0 ] ) ; System . out . println ( ""Array is "" + Arrays . toString ( arr ) ) ; }"
814,"void main ( String [ ] args ) { double [ ] [ ] data = { { 97 , 36 , 79 } , { 94 , 74 , 60 } , { 68 , 76 , 58 } , { 64 , 87 , 56 } , { 68 , 27 , 73 } , { 74 , 99 , 42 } , { 7 , 93 , 87 } , { 51 , 69 , 40 } , { 38 , 23 , 33 } , { 57 , 86 , 31 } } ; double [ ] xArr = new double [ data . length ] ; double [ ] yArr = new double [ data . length ] ; double [ ] bubbleSizeArr = new double [ data . length ] ; for ( int i = 0 ; i < data . length ; i ++ ) { xArr [ i ] = data [ i ] [ 0 ] ; yArr [ i ] = data [ i ] [ 1 ] ; bubbleSizeArr [ i ] = data [ i ] [ 2 ] ; } for ( int i = 0 ; i < data . length ; i ++ ) { System . out . printf ( ""%5.2f %5.2f %5.2f%n"" , xArr [ i ] , yArr [ i ] , bubbleSizeArr [ i ] ) ; } }"
815,"void main ( String [ ] args ) { double [ ] [ ] data = { { 97 , 36 , 79 } , { 94 , 74 , 60 } , { 68 , 76 , 58 } , { 64 , 87 , 56 } , { 68 , 27 , 73 } , { 74 , 99 , 42 } , { 7 , 93 , 87 } , { 51 , 69 , 40 } , { 38 , 23 , 33 } , { 57 , 86 , 31 } } ; double data1 [ ] = new double [ data . length ] ; double data2 [ ] = new double [ data . length ] ; double data3 [ ] = new double [ data . length ] ; for ( int x = 0 ; x < data . length ; x ++ ) { for ( int y = 0 ; y < data [ x ] . length ; y ++ ) { if ( y == 0 ) data1 [ x ] = data [ x ] [ y ] ; else if ( y == 1 ) data2 [ x ] = data [ x ] [ y ] ; else if ( y == 2 ) data3 [ x ] = data [ x ] [ y ] ; } } for ( int i = 0 ; i < data1 . length ; i ++ ) { System . out . print ( data1 [ i ] + "" "" ) ; System . out . print ( data2 [ i ] + "" "" ) ; System . out . print ( data3 [ i ] + "" "" ) ; System . out . println ( ) ; } }"
816,"void printTable ( String [ ] countries , int [ ] populations ) { if ( countries . length == 0 || populations . length == 0 || countries . length != populations . length ) { return ; } int longestCountry = Arrays . stream ( countries ) . map ( String :: toString ) . mapToInt ( String :: length ) . max ( ) . getAsInt ( ) ; int longestPop = Arrays . stream ( populations ) . mapToObj ( Integer :: toString ) . mapToInt ( String :: length ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . printf ( ""%-"" + longestCountry + ""s | %"" + longestPop + ""d%n"" , countries [ i ] , populations [ i ] ) ; } }"
817,"void printTable ( String [ ] countries , int [ ] populations ) { if ( countries . length != 0 ) { int longestNameInput = countries [ 0 ] . length ( ) ; int longestPopInput = String . valueOf ( populations [ 0 ] ) . length ( ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { int countLength = countries [ i ] . length ( ) ; int popLength = String . valueOf ( populations [ i ] ) . length ( ) ; if ( countLength > longestNameInput ) longestNameInput = countLength ; if ( popLength > longestPopInput ) longestPopInput = popLength ; } for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . print ( countries [ i ] ) ; for ( int j = 0 ; j < ( longestNameInput - countries [ i ] . length ( ) ) ; j ++ ) System . out . print ( "" "" ) ; System . out . print ( "" | "" ) ; for ( int k = 0 ; k < ( longestPopInput - String . valueOf ( populations [ i ] ) . length ( ) ) ; k ++ ) System . out . print ( "" "" ) ; System . out . println ( populations [ i ] ) ; } } }"
818,int singleNumber ( int [ ] nums ) { Set < Integer > unique = new HashSet < > ( ) ; for ( int num : nums ) { if ( ! unique . add ( num ) ) { unique . remove ( num ) ; } } return unique . iterator ( ) . next ( ) ; }
819,int singleNumber ( int [ ] nums ) { int answer = 0 ; ArrayList al = new ArrayList ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { al . add ( nums [ i ] ) ; } for ( int i = 0 ; i < nums . length ; i ++ ) { int test = nums [ i ] ; if ( al . indexOf ( test ) == al . lastIndexOf ( test ) ) { answer = nums [ i ] ; } } return answer ; }
820,"String join ( Collection s , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; Iterator iter = s . iterator ( ) ; while ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { buffer . append ( delimiter ) ; } } return buffer . toString ( ) ; }"
821,"String join ( String delimiter , String ... inStr ) { StringBuilder sb = new StringBuilder ( ) ; if ( inStr . length > 0 ) { sb . append ( inStr [ 0 ] ) ; for ( int i = 1 ; i < inStr . length ; i ++ ) { sb . append ( delimiter ) ; sb . append ( inStr [ i ] ) ; } } return sb . toString ( ) ; }"
822,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
823,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , Integer hash , XSSFCellStyle styleOld , HSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( workbookOld , workbookNew , styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( workbookNew , ( XSSFFont ) styleOld . getFont ( ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
824,"void main ( String [ ] args ) { int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int mArray [ ] = new int [ 5 ] ; int j = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] > lower ( mArray ) ) { mArray [ lowerPos ( mArray ) ] = array [ i ] ; } } System . out . println ( Arrays . toString ( mArray ) ) ; }"
825,"void main ( String args [ ] ) { int i ; int large [ ] = new int [ 5 ] ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int max = 0 , index ; for ( int j = 0 ; j < 5 ; j ++ ) { max = array [ 0 ] ; index = 0 ; for ( i = 1 ; i < array . length ; i ++ ) { if ( max < array [ i ] ) { max = array [ i ] ; index = i ; } } large [ j ] = max ; array [ index ] = Integer . MIN_VALUE ; System . out . println ( ""Largest "" + j + "" : "" + large [ j ] ) ; } }"
826,void add ( M msg ) { Queue < M > queue = threadQueue . get ( ) ; if ( queue == null ) { queue = new LinkedList < > ( ) ; queues . add ( queue ) ; threadQueue . set ( queue ) ; } queue . add ( msg ) ; notify ( ) ; }
827,"boolean add ( P producer , E item ) { lock . lock ( ) ; try { if ( ! queues . containsKey ( producer ) ) { queues . put ( producer , new PriorityBlockingQueue < > ( ) ) ; } added . signalAll ( ) ; return queues . get ( producer ) . add ( item ) ; } finally { lock . unlock ( ) ; } }"
828,"void main ( String [ ] args ) { String userInput = ""Peter"" ; int length = userInput . length ( ) ; int m , j , i , n = 0 ; for ( m = length % 2 > 0 ? 1 : 2 ; m < length * 2 ; m += 2 ) { i = m < length ? m : length * 2 - m ; for ( j = 0 ; j < length - 1 - i / 2 ; ++ j ) { System . out . print ( "" "" ) ; } for ( j = 0 ; j < i ; ++ j ) { char c = userInput . charAt ( n ++ % length ) ; c = j == 0 ? Character . toUpperCase ( c ) : Character . toLowerCase ( c ) ; System . out . print ( c ) ; } System . out . println ( """" ) ; } }"
829,"void main ( String [ ] args ) { Scanner keyboard = new Scanner ( System . in ) ; String userInput = keyboard . next ( ) ; String concatenated = userInput ; int i , cumSum = 0 ; ArrayList < Integer > helperIndex = new ArrayList < > ( ) ; for ( i = 1 ; i < userInput . length ( ) ; i += 2 ) { helperIndex . add ( i ) ; cumSum += i ; } for ( i = userInput . length ( ) ; i > 0 ; i -= 2 ) { helperIndex . add ( i ) ; cumSum += i ; } int numOfWordRepitition = cumSum / userInput . length ( ) ; for ( i = 0 ; i < numOfWordRepitition ; i ++ ) { concatenated += userInput ; } String substr ; int prev = helperIndex . get ( 0 ) ; int next = helperIndex . get ( 0 ) ; substr = concatenated . substring ( 0 , helperIndex . get ( 0 ) ) ; System . out . println ( Character . toUpperCase ( substr . charAt ( 0 ) ) + substr . substring ( 1 ) ) ; for ( i = 1 ; i < userInput . length ( ) ; i ++ ) { next += helperIndex . get ( i ) ; substr = concatenated . substring ( prev , next ) ; substr = Character . toUpperCase ( substr . charAt ( 0 ) ) + substr . substring ( 1 ) ; System . out . println ( substr ) ; prev = next ; } }"
830,"int findCombinationsCount ( int sum , int vals [ ] ) { if ( sum < 0 ) { return 0 ; } if ( vals == null || vals . length == 0 ) { return 0 ; } int dp [ ] = new int [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < vals . length ; ++ i ) { for ( int j = vals [ i ] ; j <= sum ; ++ j ) { dp [ j ] += dp [ j - vals [ i ] ] ; } } return dp [ sum ] ; }"
831,"int findCombinationsCount ( int amount , int coins [ ] , int checkFromIndex ) { if ( amount == 0 ) return 1 ; else if ( amount < 0 || coins . length == checkFromIndex ) return 0 ; else { int withFirstCoin = findCombinationsCount ( amount - coins [ checkFromIndex ] , coins , checkFromIndex ) ; int withoutFirstCoin = findCombinationsCount ( amount , coins , checkFromIndex + 1 ) ; return withFirstCoin + withoutFirstCoin ; } }"
832,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String formatedSource = source . subSequence ( start , end ) . toString ( ) ; String destPrefix = dest . subSequence ( 0 , dstart ) . toString ( ) ; String destSuffix = dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; String result = destPrefix + formatedSource + destSuffix ; result = result . replace ( "","" , ""."" ) ; Matcher matcher = mPattern . matcher ( result ) ; if ( matcher . matches ( ) ) { return null ; } return """" ; }"
833,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String lsStart = """" ; String lsInsert = """" ; String lsEnd = """" ; String lsText = """" ; Log . d ( ""debug"" , moPattern . toString ( ) ) ; Log . d ( ""debug"" , ""source: "" + source + "", start: "" + start + "", end:"" + end + "", dest: "" + dest + "", dstart: "" + dstart + "", dend: "" + dend ) ; lsText = dest . toString ( ) ; if ( lsText . length ( ) > 0 ) { lsStart = lsText . substring ( 0 , dstart ) ; Log . d ( ""debug"" , ""lsStart : "" + lsStart ) ; if ( source != """" ) { lsInsert = source . toString ( ) ; Log . d ( ""debug"" , ""lsInsert: "" + lsInsert ) ; } lsEnd = lsText . substring ( dend ) ; Log . d ( ""debug"" , ""lsEnd   : "" + lsEnd ) ; lsText = lsStart + lsInsert + lsEnd ; Log . d ( ""debug"" , ""lsText  : "" + lsText ) ; } Matcher loMatcher = moPattern . matcher ( lsText ) ; Log . d ( ""debug"" , ""loMatcher.matches(): "" + loMatcher . matches ( ) + "", lsText: "" + lsText ) ; if ( ! loMatcher . matches ( ) ) { return """" ; } return null ; }"
834,"void main ( String args [ ] ) { ArrayList < String > keys = new ArrayList < > ( ) ; ArrayList < String > values = new ArrayList < > ( ) ; keys . add ( ""1"" ) ; keys . add ( ""1"" ) ; keys . add ( ""1"" ) ; keys . add ( ""2"" ) ; keys . add ( ""2"" ) ; keys . add ( ""3"" ) ; values . add ( ""2016-06-22 07:18:45"" ) ; values . add ( ""2016-06-22 08:18:45"" ) ; values . add ( ""2016-06-22 09:18:45"" ) ; values . add ( ""2016-06-22 03:18:45"" ) ; values . add ( ""2016-06-22 04:18:45"" ) ; values . add ( ""2016-06-22 01:18:45"" ) ; LinkedHashMap < String , String > map = new LinkedHashMap < String , String > ( ) ; for ( int i = 0 ; i < keys . size ( ) ; i ++ ) { map . put ( keys . get ( i ) , values . get ( i ) ) ; } System . out . println ( map ) ; }"
835,"void main ( String [ ] args ) { ArrayList < String > keys = new ArrayList < > ( Arrays . asList ( ""1"" , ""1"" , ""1"" , ""2"" , ""2"" , ""3"" ) ) ; ArrayList < String > values = new ArrayList < > ( Arrays . asList ( ""2016-06-22 07:18:45"" , ""2016-06-22 08:18:45"" , ""2016-06-22 09:18:45"" , ""2016-06-22 03:18:45"" , ""2016-06-22 04:18:45"" , ""2016-06-22 01:18:45"" ) ) ; HashMap < String , String > map = new HashMap < String , String > ( ) ; for ( int i = 0 ; keys . size ( ) == values . size ( ) && i < keys . size ( ) ; i ++ ) { String key = keys . get ( i ) ; String value = values . get ( i ) ; if ( ! map . containsKey ( key ) || dateAsNo ( value ) > dateAsNo ( map . get ( key ) ) ) { map . put ( key , value ) ; } } System . out . println ( map ) ; }"
836,"String join ( String [ ] strings , int startIndex , String separator ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = startIndex ; i < strings . length ; i ++ ) { if ( i != startIndex ) sb . append ( separator ) ; sb . append ( strings [ i ] ) ; } return sb . toString ( ) ; }"
837,"String join ( String separator , String ... values ) { if ( values . length == 0 ) return """" ; char [ ] sep = separator . toCharArray ( ) ; int totalSize = ( values . length - 1 ) * sep . length ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( values [ i ] == null ) values [ i ] = """" ; else totalSize += values [ i ] . length ( ) ; } char [ ] joined = new char [ totalSize ] ; int pos = 0 ; for ( int i = 0 , end = values . length - 1 ; i < end ; i ++ ) { System . arraycopy ( values [ i ] . toCharArray ( ) , 0 , joined , pos , values [ i ] . length ( ) ) ; pos += values [ i ] . length ( ) ; System . arraycopy ( sep , 0 , joined , pos , sep . length ) ; pos += sep . length ; } System . arraycopy ( values [ values . length - 1 ] . toCharArray ( ) , 0 , joined , pos , values [ values . length - 1 ] . length ( ) ) ; return new String ( joined ) ; }"
838,"void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == ItemEvent . SELECTED ) { size = Integer . parseInt ( ( String ) box . getSelectedItem ( ) ) ; for ( i = 1 ; i <= size ; i ++ ) { System . out . print ( "" "" + i ) ; } System . out . println ( ) ; } }"
839,"void itemStateChanged ( ItemEvent e ) { size = Integer . parseInt ( ( String ) box . getSelectedItem ( ) ) ; if ( e . getStateChange ( ) == ItemEvent . SELECTED ) { for ( i = 1 ; i <= size ; i ++ ) { System . out . print ( "" "" + i ) ; } System . out . println ( ) ; } }"
840,"void main ( String [ ] args ) { Map < Example , Number > m = new HashMap < > ( ) ; Example e1 = new Example ( 100 ) ; Example e2 = new Example ( 200 ) ; Example e3 = new Example ( 300 ) ; m . put ( e1 , 10 ) ; m . put ( e2 , 20 ) ; m . put ( e3 , 30 ) ; System . out . println ( m ) ; }"
841,"void main ( String [ ] args ) { HashMap < A , String > map = new HashMap < A , String > ( 4 ) ; map . put ( new A ( ) , ""abc"" ) ; map . put ( new A ( ) , ""def"" ) ; Class clazz = map . getClass ( ) ; Field table = clazz . getDeclaredField ( ""table"" ) ; table . setAccessible ( true ) ; Map . Entry < Integer , String > [ ] realTable = ( Map . Entry < Integer , String > [ ] ) table . get ( map ) ; for ( int i = 0 ; i < realTable . length ; i ++ ) { System . out . println ( String . format ( ""Bucket : %d, Entry: %s"" , i , bucketToString ( realTable [ i ] ) ) ) ; } }"
842,"void main ( String [ ] args ) { JFrame main = new JFrame ( ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . add ( new JLabel ( ""test"" ) , BorderLayout . WEST ) ; p . add ( new JTextField ( ""growable"" ) , BorderLayout . CENTER ) ; p . add ( new JComboBox ( ) , BorderLayout . EAST ) ; main . add ( p ) ; main . pack ( ) ; main . setVisible ( true ) ; }"
843,"void main ( String [ ] args ) { JFrame frame = new JFrame ( ""GridBagLayout Demo"" ) ; frame . setLayout ( new GridBagLayout ( ) ) ; JLabel label = new JLabel ( ""Demo Label"" ) ; JTextField textField = new JTextField ( ""Demo Text"" ) ; JComboBox comboBox = new JComboBox ( new String [ ] { ""hello"" , ""goodbye"" , ""foo"" } ) ; GridBagConstraints cons = new GridBagConstraints ( ) ; cons . insets = new Insets ( 10 , 10 , 10 , 10 ) ; frame . add ( label , cons ) ; cons . gridx = 1 ; cons . weightx = 1 ; cons . weighty = 1 ; cons . insets = new Insets ( 10 , 0 , 10 , 10 ) ; cons . fill = GridBagConstraints . HORIZONTAL ; frame . add ( textField , cons ) ; cons . gridx = 2 ; cons . weightx = 0 ; cons . weighty = 0 ; cons . insets = new Insets ( 10 , 0 , 10 , 10 ) ; cons . fill = GridBagConstraints . NONE ; frame . add ( comboBox , cons ) ; frame . pack ( ) ; frame . setVisible ( true ) ; }"
844,double getSum ( ) { if ( subAccounts != null ) { Double sum = 0.0 ; for ( int i = 0 ; i < subAccounts . size ( ) ; i ++ ) { sum += subAccounts . get ( i ) . getSum ( ) ; } return amount + sum ; } else { return amount ; } }
845,double getSum ( ) { double result = this . amount ; if ( this . subAccounts != null ) { for ( Balance subAccount : this . subAccounts ) { result = result + subAccount . getSum ( ) ; } } return result ; }
846,"void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int number ; int nearNumberZero = 0 ; for ( int i = 1 ; i <= 5 ; i ++ ) { System . out . println ( ""Enter number "" + i ) ; number = scn . nextInt ( ) ; if ( i == 1 || Math . abs ( number ) < Math . abs ( nearNumberZero ) ) nearNumberZero = number ; } System . out . println ( ""The number near zero 0 is - "" + nearNumberZero ) ; scn . close ( ) ; }"
847,"void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; ArrayList < Integer > integers = new ArrayList < > ( ) ; System . out . println ( ""Enter number 1"" ) ; integers . add ( scn . nextInt ( ) ) ; System . out . println ( ""Enter number 2"" ) ; integers . add ( scn . nextInt ( ) ) ; System . out . println ( ""Enter number 3"" ) ; integers . add ( scn . nextInt ( ) ) ; System . out . println ( ""Enter number 4"" ) ; integers . add ( scn . nextInt ( ) ) ; System . out . println ( ""Enter number 5"" ) ; integers . add ( scn . nextInt ( ) ) ; Collections . sort ( integers , Comparator . comparingInt ( Math :: abs ) ) ; System . out . println ( ""The number near zero 0 is"" + integers . get ( 0 ) ) ; }"
848,"void exportDone ( JComponent c , Transferable data , int action ) { if ( ( action == MOVE ) && ( indices != null ) ) { DefaultListModel model = ( DefaultListModel ) source . getModel ( ) ; if ( addCount > 0 ) { for ( int i = 0 ; i < indices . length ; i ++ ) { if ( indices [ i ] > addIndex ) { indices [ i ] += addCount ; } } } for ( int i = indices . length - 1 ; i >= 0 ; i -- ) { model . remove ( indices [ i ] ) ; } } indices = null ; addIndex = - 1 ; addCount = 0 ; }"
849,"void exportDone ( JComponent c , Transferable data , int action ) { if ( ( action == MOVE ) && ( indices != null ) ) { DefaultListModel model = ( DefaultListModel ) source . getModel ( ) ; for ( int i = indices . length - 1 ; i >= 0 ; i -- ) model . remove ( indices [ i ] ) ; } if ( addCount > 0 ) { for ( int i = 0 ; i < indices . length ; i ++ ) { if ( indices [ i ] > addIndex ) { indices [ i ] += addCount ; } } } indices = null ; addIndex = - 1 ; addCount = 0 ; }"
850,"void main ( String args [ ] ) { String result = new String ( removeDupes ( new char [ ] { 'a' , 'b' , 'c' , 'd' , 'a' } ) ) ; assert ""abcd"" . equals ( result ) : ""abcda should return abcd but it returns: "" + result ; result = new String ( removeDupes ( new char [ ] { 'a' , 'a' , 'a' , 'a' } ) ) ; assert ""a"" . equals ( result ) : ""aaaa should return a but it returns: "" + result ; result = new String ( removeDupes ( new char [ ] { 'a' , 'b' , 'c' , 'a' } ) ) ; assert ""abc"" . equals ( result ) : ""abca should return abc but it returns: "" + result ; result = new String ( removeDupes ( new char [ ] { 'a' , 'a' , 'b' , 'b' } ) ) ; assert ""ab"" . equals ( result ) : ""aabb should return ab but it returns: "" + result ; result = new String ( removeDupes ( new char [ ] { 'a' } ) ) ; assert ""a"" . equals ( result ) : ""a should return a but it returns: "" + result ; result = new String ( removeDupes ( new char [ ] { 'a' , 'b' , 'b' , 'a' } ) ) ; assert ""ab"" . equals ( result ) : ""abba should return ab but it returns: "" + result ; char [ ] arr = bigArr ( 5000000 ) ; long startTime = System . nanoTime ( ) ; System . out . println ( ""2: "" + new String ( removeDupes ( arr ) ) ) ; long endTime = System . nanoTime ( ) ; long duration = ( endTime - startTime ) ; System . out . println ( ""Program took: "" + duration + "" nanoseconds"" ) ; System . out . println ( ""Program took: "" + duration / 1000000000 + "" seconds"" ) ; }"
851,"void main ( String [ ] args ) { String s = ""harikrishna"" ; String s2 = """" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { Boolean found = false ; for ( int j = 0 ; j < s2 . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s2 . charAt ( j ) ) { found = true ; break ; } } if ( found == false ) { s2 = s2 . concat ( String . valueOf ( s . charAt ( i ) ) ) ; } } System . out . println ( s2 ) ; }"
852,"void contextDestroyed ( ServletContextEvent sce ) { Context initContext = new InitialContext ( ) ; Context envContext = ( Context ) initContext . lookup ( ""java:/comp/env"" ) ; DataSource datasource = ( DataSource ) envContext . lookup ( ""jdbc/database"" ) ; try { java . sql . Driver mySqlDriver = DriverManager . getDriver ( ""jdbc:mysql://localhost:3306/"" ) ; DriverManager . deregisterDriver ( mySqlDriver ) ; } catch ( SQLException ex ) { logger . info ( ""Could not deregister driver:"" . concat ( ex . getMessage ( ) ) ) ; } dataSource = null ; }"
853,"void contextDestroyed ( ServletContextEvent sce ) { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { Driver driver = drivers . nextElement ( ) ; if ( driver . getClass ( ) . getClassLoader ( ) == cl ) { try { log . info ( ""Deregistering JDBC driver {}"" , driver ) ; DriverManager . deregisterDriver ( driver ) ; } catch ( SQLException ex ) { log . error ( ""Error deregistering JDBC driver {}"" , driver , ex ) ; } } else { log . trace ( ""Not deregistering JDBC driver {} as it does not belong to this webapp's ClassLoader"" , driver ) ; } } }"
854,"ListNode reverse ( ListNode toBeNextNode , ListNode currentNode ) { ListNode currentHead = currentNode ; if ( ( currentNode == null || currentNode . next == null ) && toBeNextNode == null ) return currentHead ; if ( currentNode . next != null ) currentHead = reverse ( currentNode , currentNode . next ) ; currentNode . next = toBeNextNode ; return currentHead ; }"
855,"Node reverse ( Node previous , Node current ) { if ( previous == null ) return null ; if ( previous . equals ( head ) ) previous . setNext ( null ) ; if ( current == null ) { head = previous ; return head ; } else { Node temp = current . getNext ( ) ; current . setNext ( previous ) ; reverse ( current , temp ) ; } return null ; }"
856,"boolean isAnagram ( String leftString , String rightString ) { if ( leftString == null || rightString == null ) { return false ; } else if ( leftString . length ( ) != rightString . length ( ) ) { return false ; } char letters [ ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' } ; Map < Character , Integer > occurrencesMap = new HashMap < > ( ) ; for ( char l : letters ) { occurrencesMap . put ( l , 0 ) ; } for ( int i = 0 ; i < leftString . length ( ) ; i ++ ) { char charFromLeft = leftString . charAt ( i ) ; Integer nrOfCharsInLeft = occurrencesMap . get ( charFromLeft ) ; occurrencesMap . put ( charFromLeft , ++ nrOfCharsInLeft ) ; char charFromRight = rightString . charAt ( i ) ; Integer nrOfCharsInRight = occurrencesMap . get ( charFromRight ) ; occurrencesMap . put ( charFromRight , -- nrOfCharsInRight ) ; } for ( Integer occurrencesNr : occurrencesMap . values ( ) ) { if ( occurrencesNr != 0 ) { return false ; } } return true ; }"
857,"Boolean isAnagram ( String word , String anagram_word ) { if ( word . length ( ) != anagram_word . length ( ) ) { return false ; } char [ ] words_char = word . toCharArray ( ) ; char [ ] anagram_word_char = anagram_word . toCharArray ( ) ; int words_char_num = 1 ; int anagram_word_num = 1 ; Map < Character , Integer > wordPrimeMap = wordPrimeMap ( ) ; for ( int i = 0 ; i < words_char . length ; i ++ ) { words_char_num *= wordPrimeMap . get ( words_char [ i ] ) ; } for ( int i = 0 ; i < anagram_word_char . length ; i ++ ) { anagram_word_num *= wordPrimeMap . get ( anagram_word_char [ i ] ) ; } return anagram_word_num == words_char_num ; }"
858,"void countString ( String str ) { if ( str != null ) { int length = str . length ( ) ; char ch [ ] = str . toCharArray ( ) ; Arrays . sort ( ch ) ; if ( length > 0 ) { char x = ch [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < length ; i ++ ) { if ( ch [ i ] == x ) { count ++ ; } else { System . out . println ( ""Number of Occurrence of '"" + ch [ i - 1 ] + ""' is: "" + count ) ; x = ch [ i ] ; count = 1 ; } } System . out . println ( ""Number of Occurrence of '"" + ch [ length - 1 ] + ""' is: "" + count ) ; } } }"
859,"void countString ( String str , char value ) { String [ ] arr = str . split ( """" ) ; StringBuffer tempString = new StringBuffer ( ) ; for ( String s : arr ) { tempString . append ( s ) ; for ( char ch : s . toCharArray ( ) ) { System . out . println ( ""Number of Occurrence of "" + ch + "" is:"" + tempString . chars ( ) . filter ( i -> i == ch ) . count ( ) ) ; } } if ( ! ( Character . toString ( value ) . isEmpty ( ) ) ) { StringBuffer tempString2 = new StringBuffer ( ) ; for ( String s : arr ) { tempString2 . append ( s ) ; for ( char ch : s . toCharArray ( ) ) { if ( ch == value ) { System . out . println ( ""Number of Occurrence of "" + ch + "" is:"" + tempString2 . chars ( ) . filter ( i -> i == ch ) . count ( ) ) ; } } } } }"
860,"void sort ( int [ ] input , Speed speed ) { SortStrategy strategy = null ; switch ( speed ) { case SLOW : strategy = new SlowBubbleSortStrategy ( ) ; break ; case MEDIUM : strategy = new MediumInsertationSortStrategy ( ) ; break ; case FAST : strategy = new FastQuickSortStrategy ( ) ; break ; default : strategy = new MediumInsertationSortStrategy ( ) ; } strategy . sort ( input ) ; }"
861,"void sort ( int [ ] input ) { for ( int i = 0 ; i < input . length ; i ++ ) { for ( int j = i + 1 ; j < input . length ; j ++ ) { if ( input [ i ] > input [ j ] ) { int tmp = input [ i ] ; input [ i ] = input [ j ] ; input [ j ] = tmp ; } } } System . out . println ( ""Slow sorting is done and the result is :"" ) ; for ( int i : input ) { System . out . print ( i + "","" ) ; } }"
862,String match ( @ PathVariable String matchId ) { String json = matchService . getMatchJson ( matchId ) ; if ( json == null ) { throw new NotFoundException ( ) ; } return json ; }
863,"ResponseEntity < ? > match ( @ PathVariable String matchId , @ RequestBody String body , HttpServletRequest request , HttpServletResponse response ) { Product p ; try { p = service . getProduct ( request . getProductId ( ) ) ; } catch ( Exception ex ) { return new ResponseEntity < String > ( HttpStatus . BAD_REQUEST ) ; } return new ResponseEntity ( p , HttpStatus . OK ) ; }"
864,void shuffleArray ( int [ ] array ) { int index ; Random random = new Random ( ) ; for ( int i = array . length - 1 ; i > 0 ; i -- ) { index = random . nextInt ( i + 1 ) ; if ( index != i ) { array [ index ] ^= array [ i ] ; array [ i ] ^= array [ index ] ; array [ index ] ^= array [ i ] ; } } }
865,void shuffleArray ( int [ ] ar ) { Random rnd = ThreadLocalRandom . current ( ) ; for ( int i = ar . length - 1 ; i > 0 ; i -- ) { int index = rnd . nextInt ( i + 1 ) ; int a = ar [ index ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } }
866,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
867,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
868,"void copyFolder ( File src , File dest ) { if ( src == null || dest == null ) return ; if ( ! src . isDirectory ( ) ) return ; if ( dest . exists ( ) ) { if ( ! dest . isDirectory ( ) ) { return ; } } else { dest . mkdir ( ) ; } if ( src . listFiles ( ) == null || src . listFiles ( ) . length == 0 ) return ; for ( File file : src . listFiles ( ) ) { File fileDest = new File ( dest , file . getName ( ) ) ; if ( file . isDirectory ( ) ) { copyFolder ( file , fileDest ) ; } else { if ( fileDest . exists ( ) ) continue ; try { Files . copy ( file . toPath ( ) , fileDest . toPath ( ) ) ; } catch ( IOException e ) { } } } }"
869,"void copyFolder ( File src , File dest ) throws IOException { try ( Stream < Path > stream = Files . walk ( src . toPath ( ) ) ) { stream . forEachOrdered ( sourcePath -> { try { Files . copy ( sourcePath , src . toPath ( ) . resolve ( dest . toPath ( ) . relativize ( sourcePath ) ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } ) ; } }"
870,"void main ( String [ ] args ) throws Exception { Console console = System . console ( ) ; if ( console == null ) { System . out . println ( ""Unable to fetch console"" ) ; return ; } String line = console . readLine ( ) ; console . printf ( ""I saw this line: %s"" , line ) ; }"
871,"void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter String"" ) ; String s = br . readLine ( ) ; System . out . print ( ""Enter Integer:"" ) ; try { int i = Integer . parseInt ( br . readLine ( ) ) ; } catch ( NumberFormatException nfe ) { System . err . println ( ""Invalid Format!"" ) ; } }"
872,"String shuffle ( String s ) { String shuffledString = """" ; while ( s . length ( ) != 0 ) { int index = ( int ) Math . floor ( Math . random ( ) * s . length ( ) ) ; char c = s . charAt ( index ) ; s = s . substring ( 0 , index ) + s . substring ( index + 1 ) ; shuffledString += c ; } return shuffledString ; }"
873,"String shuffle ( String text ) { if ( text . length ( ) <= 1 ) return text ; int split = text . length ( ) / 2 ; String temp1 = shuffle ( text . substring ( 0 , split ) ) ; String temp2 = shuffle ( text . substring ( split ) ) ; if ( Math . random ( ) > 0.5 ) return temp1 + temp2 ; else return temp2 + temp1 ; }"
874,"boolean isAnagram ( String first , String second ) { String positive = first . toLowerCase ( ) ; String negative = second . toLowerCase ( ) ; if ( positive . length ( ) != negative . length ( ) ) { return false ; } int [ ] counts = new int [ 26 ] ; int diff = 0 ; for ( int i = 0 ; i < positive . length ( ) ; i ++ ) { int pos = ( int ) positive . charAt ( i ) - 97 ; if ( counts [ pos ] >= 0 ) { diff ++ ; } else { diff -- ; } counts [ pos ] ++ ; int neg = ( int ) negative . charAt ( i ) - 97 ; if ( counts [ neg ] <= 0 ) { diff ++ ; } else { diff -- ; } counts [ neg ] -- ; } return diff == 0 ; }"
875,"boolean isAnagram ( String s1 , String s2 ) { StringBuilder sb1 = new StringBuilder ( ) ; StringBuilder sb2 = new StringBuilder ( ) ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; char arr1 [ ] = s1 . toCharArray ( ) ; char arr2 [ ] = s2 . toCharArray ( ) ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( char c : arr1 ) { sb1 . append ( c ) ; } for ( char c : arr2 ) { sb2 . append ( c ) ; } System . out . println ( sb1 . toString ( ) ) ; System . out . println ( sb2 . toString ( ) ) ; if ( sb1 . toString ( ) . equals ( sb2 . toString ( ) ) ) return true ; else return false ; }"
876,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_SHIFT , VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_AT ) ; break ; case '#' : doType ( VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_AMPERSAND ) ; break ; case '*' : doType ( VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
877,void type ( char character ) { handleSpecialCharacter ( character ) ; if ( Character . isLowerCase ( character ) ) { typeCharacter ( Character . toUpperCase ( character ) ) ; } if ( Character . isUpperCase ( character ) ) { typeShiftCharacter ( character ) ; } if ( Character . isDigit ( character ) ) { typeCharacter ( character ) ; } }
878,void makeGrid ( int size ) { this . lines = size ; grid = new Cell [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) for ( int j = 0 ; j < size ; j ++ ) { grid [ i ] [ j ] = new Cell ( ) ; } }
879,void makeGrid ( int size ) { this . lines = size ; grid = new Cell [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { grid [ i ] [ j ] = new Cell ( ) ; } } }
880,void main ( String [ ] args ) { Integer [ ] arr = new Integer [ 1000 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = i ; } Collections . shuffle ( Arrays . asList ( arr ) ) ; System . out . println ( Arrays . toString ( arr ) ) ; }
881,void main ( String [ ] args ) { int [ ] nums = new int [ N ] ; for ( int i = 0 ; i < nums . length ; ++ i ) { nums [ i ] = i ; } Random randomGenerator = new Random ( ) ; int randomIndex ; int randomValue ; for ( int i = 0 ; i < nums . length ; ++ i ) { randomIndex = randomGenerator . nextInt ( nums . length ) ; randomValue = nums [ randomIndex ] ; nums [ randomIndex ] = nums [ i ] ; nums [ i ] = randomValue ; } }
882,boolean isPalindrome ( String original ) { int i = original . length ( ) - 1 ; int j = 0 ; while ( i > j ) { if ( original . charAt ( i ) != original . charAt ( j ) ) { return false ; } i -- ; j ++ ; } return true ; }
883,boolean isPalindrome ( String str ) { str = str . toUpperCase ( ) ; char [ ] strChars = str . toCharArray ( ) ; List < Character > word = new ArrayList < > ( ) ; for ( char c : strChars ) { word . add ( c ) ; } while ( true ) { if ( ( word . size ( ) == 1 ) || ( word . size ( ) == 0 ) ) { return true ; } if ( word . get ( 0 ) == word . get ( word . size ( ) - 1 ) ) { word . remove ( 0 ) ; word . remove ( word . size ( ) - 1 ) ; } else { return false ; } } }
884,"int solution ( int N ) { int tempGap = 0 , gap = 0 ; String binaryString = Integer . toBinaryString ( N ) ; int i = 0 ; while ( i < binaryString . length ( ) ) { if ( binaryString . charAt ( i ) == '1' ) { ++ i ; tempGap = 0 ; while ( i < binaryString . length ( ) && binaryString . charAt ( i ) != '1' ) { ++ i ; tempGap ++ ; } if ( i >= binaryString . length ( ) ) { tempGap = 0 ; } } else { ++ i ; } if ( tempGap > gap ) { gap = tempGap ; } } return gap ; }"
885,"int solution ( int N ) { String binary = Integer . toString ( N , 2 ) ; int largestGap = 0 ; for ( int i = 1 , gap = 0 ; i < binary . length ( ) ; i ++ ) { while ( i < binary . length ( ) && binary . charAt ( i ) == '0' ) { i ++ ; gap ++ ; } if ( gap > largestGap && i < binary . length ( ) ) { largestGap = gap ; } gap = 0 ; } return largestGap ; }"
886,"void main ( String [ ] args ) throws IOException { String ch ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter the Statement:"" ) ; ch = br . readLine ( ) ; int count = 0 , len = 0 ; do { try { char name [ ] = ch . toCharArray ( ) ; len = name . length ; count = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( ( name [ 0 ] == name [ j ] ) && ( ( name [ 0 ] >= 65 && name [ 0 ] <= 91 ) || ( name [ 0 ] >= 97 && name [ 0 ] <= 123 ) ) ) count ++ ; } if ( count != 0 ) System . out . println ( name [ 0 ] + "" "" + count + "" Times"" ) ; ch = ch . replace ( """" + name [ 0 ] , """" ) ; } catch ( Exception ex ) { } } while ( len != 1 ) ; }"
887,"void main ( String [ ] args ) { HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; System . out . println ( ""Enter an String:"" ) ; Scanner sc = new Scanner ( System . in ) ; String s1 = sc . nextLine ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! hm . containsKey ( s1 . charAt ( i ) ) ) { hm . put ( s1 . charAt ( i ) , ( Integer ) 1 ) ; } else { hm . put ( s1 . charAt ( i ) , hm . get ( s1 . charAt ( i ) ) + 1 ) ; } } System . out . println ( ""The Charecters are:"" + hm ) ; }"
888,"String toHexString ( byte [ ] bytes ) { char [ ] hexArray = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] hexChars = new char [ 10000000 ] ; int c = 0 ; int v ; for ( j = 0 ; j < bytes . length ; j ++ ) { v = bytes [ j ] & 0xFF ; hexChars [ c ] = hexArray [ v / 16 ] ; c ++ ; hexChars [ c ] = hexArray [ v % 16 ] ; c ++ ; } return new String ( hexChars , 0 , c ) ; }"
889,String toHexString ( byte bytes [ ] ) { if ( bytes == null ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; for ( int iter = 0 ; iter < bytes . length ; iter ++ ) { byte high = ( byte ) ( ( bytes [ iter ] & 0xf0 ) > > 4 ) ; byte low = ( byte ) ( bytes [ iter ] & 0x0f ) ; sb . append ( nibble2char ( high ) ) ; sb . append ( nibble2char ( low ) ) ; } return sb . toString ( ) ; }
890,"void main ( String [ ] args ) { int n = 0 ; Scanner s = new Scanner ( System . in ) ; System . out . print ( ""Enter an integer number: "" ) ; n = s . nextInt ( ) ; if ( n <= 0 ) System . out . print ( ""Enter numbers greater than 0"" ) ; else { NumberToWord a = new NumberToWord ( ) ; System . out . print ( ""After conversion number in words is :"" ) ; a . pw ( ( n / 1000000000 ) , "" Hundred"" ) ; a . pw ( ( n / 10000000 ) % 100 , "" crore"" ) ; a . pw ( ( ( n / 100000 ) % 100 ) , "" lakh"" ) ; a . pw ( ( ( n / 1000 ) % 100 ) , "" thousand"" ) ; a . pw ( ( ( n / 100 ) % 10 ) , "" hundred"" ) ; a . pw ( ( n % 100 ) , "" "" ) ; } }"
891,"void main ( String [ ] args ) { System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 0 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 9 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 19 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 21 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 28 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 71 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 72 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 80 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 81 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 89 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 90 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 91 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 97 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 101 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 110 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 120 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 200 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 201 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 232 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 999 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2000000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 3000000000L ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2147483647 ) ) ; }"
892,void throwException ( final String key ) throws Throwable { ExceptionMapping exceptionMapping = exceptionMappings . getExceptionMappings ( ) . get ( key ) ; if ( exceptionMapping != null ) { try { Class < Throwable > exceptionClass = ( Class < Throwable > ) Class . forName ( exceptionMapping . getClassName ( ) ) ; try { throw exceptionClass . cast ( exceptionClass . newInstance ( ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } }
893,"void throwException ( String className ) throws CheckedException , UncheckedException { Class < ? > exceptionClass ; try { exceptionClass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } try { if ( CheckedException . class . isAssignableFrom ( exceptionClass ) ) { throw exceptionClass . asSubclass ( CheckedException . class ) . newInstance ( ) ; } else if ( UncheckedException . class . isAssignableFrom ( exceptionClass ) ) { throw exceptionClass . asSubclass ( UncheckedException . class ) . newInstance ( ) ; } else { throw new IllegalArgumentException ( ""Not a valid exception type: "" + exceptionClass . getName ( ) ) ; } } catch ( InstantiationException | IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } }"
894,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; while ( true ) { String response = input . nextLine ( ) ; if ( ! response . equals ( ""redo"" ) ) { break ; } } }"
895,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; double length = 0.39370 ; System . out . println ( ""Welcome to simple convertor."" ) ; boolean cont = true ; while ( cont ) { System . out . println ( ""Pick an option and its corresponding letter to select."" ) ; System . out . println ( ""Farenheight to Celsius: f"" ) ; System . out . println ( ""Celsius to Farenheight: c"" ) ; System . out . println ( ""Inches to Centimeters: i"" ) ; System . out . println ( ""Centimeters to Inches: ce"" ) ; System . out . println ( """" ) ; System . out . println ( ""Make your choice: "" ) ; String choice = input . nextLine ( ) ; if ( choice . equals ( ""f"" ) ) { float farenheight ; System . out . println ( ""Enter temperatue in Fahrenheit: "" ) ; farenheight = input . nextInt ( ) ; farenheight = ( ( farenheight - 32 ) * 5 ) / 9 ; System . out . println ( ""Temperatue in Celsius = "" + farenheight ) ; } else if ( choice . equals ( ""c"" ) ) { float celsius ; System . out . println ( ""Enter temperatue in Celsius: "" ) ; celsius = input . nextInt ( ) ; celsius = ( ( celsius ) * 18 / 10 ) + 32 ; System . out . println ( ""Temperatue in Farenheight = "" + celsius ) ; } else if ( choice . equals ( ""i"" ) ) { double inches ; System . out . println ( ""Enter length in Inches: "" ) ; inches = input . nextInt ( ) ; inches = ( inches / length ) ; System . out . println ( ""Length in Centimeters = "" + inches ) ; } else if ( choice . equals ( ""ce"" ) ) { double centimeters ; System . out . println ( ""Enter length in Centimeters: "" ) ; centimeters = input . nextInt ( ) ; centimeters = ( centimeters * length ) ; System . out . println ( ""Length in Inches is = "" + length ) ; } choice = input . nextLine ( ) ; if ( ""redo"" . equals ( choice ) ) { cont = true ; } else { cont = false ; } } }"
896,"void main ( String [ ] args ) throws Exception { int [ ] [ ] matrix = new int [ 3 ] [ ] ; matrix [ 0 ] = new int [ ] { 1 , 2 , 2 } ; matrix [ 1 ] = new int [ ] { 2 , 2 , 3 } ; matrix [ 2 ] = new int [ ] { 0 , 1 , 2 } ; int resultL2R = 1 ; int resultR2L = 1 ; for ( int i = 0 ; i < matrix . length ; i ++ ) { resultL2R *= matrix [ i ] [ i ] ; resultR2L *= matrix [ i ] [ matrix . length - 1 - i ] ; } System . out . println ( ""left-to-right: "" + resultL2R ) ; System . out . println ( ""right-to-left: "" + resultR2L ) ; }"
897,"void main ( String [ ] args ) { int [ ] [ ] matrix = new int [ ] [ ] { { 1 , 2 , 2 } , { 2 , 2 , 3 } , { 0 , 1 , 2 } } ; int result = 1 ; for ( int i = 0 ; i < matrix . length ; i ++ ) { result = result * matrix [ i ] [ i ] ; } System . out . println ( ""Result: "" + result ) ; }"
898,"boolean isAnagram ( String a , String b ) { a = a . toLowerCase ( ) ; b = b . toLowerCase ( ) ; if ( a . length ( ) != b . length ( ) ) { return false ; } char [ ] chars = a . toCharArray ( ) ; for ( char c : chars ) { int index = b . indexOf ( c ) ; if ( index != - 1 ) { b = b . substring ( 0 , index ) + b . substring ( index + 1 , b . length ( ) ) ; } else { return false ; } } return b . isEmpty ( ) ; }"
899,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; char [ ] c1 = s1 . toCharArray ( ) ; char [ ] c2 = s2 . toCharArray ( ) ; Arrays . sort ( c1 ) ; Arrays . sort ( c2 ) ; String sc1 = new String ( c1 ) ; String sc2 = new String ( c2 ) ; return sc1 . equals ( sc2 ) ; }"
900,"int readNumber ( ) { int x = - 1 ; do { try { System . out . println ( ""Please enter a positive number."" ) ; x = keyboard . nextInt ( ) ; } catch ( InputMismatchException e ) { } } while ( x < 0 ) ; return x ; }"
901,"int readNumber ( ) { int x = - 1 ; while ( x < 0 ) { System . out . println ( ""Please enter a positive number."" ) ; try { x = keyboard . nextInt ( ) ; } catch ( java . util . InputMismatchException e ) { } } return x ; }"
902,"void main ( String [ ] args ) throws IOException { String ch ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter the Statement:"" ) ; ch = br . readLine ( ) ; int count = 0 , len = 0 ; do { try { char name [ ] = ch . toCharArray ( ) ; len = name . length ; count = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( ( name [ 0 ] == name [ j ] ) && ( ( name [ 0 ] >= 65 && name [ 0 ] <= 91 ) || ( name [ 0 ] >= 97 && name [ 0 ] <= 123 ) ) ) count ++ ; } if ( count != 0 ) System . out . println ( name [ 0 ] + "" "" + count + "" Times"" ) ; ch = ch . replace ( """" + name [ 0 ] , """" ) ; } catch ( Exception ex ) { } } while ( len != 1 ) ; }"
903,"void main ( String [ ] args ) { String test = ""The quick brown fox jumped over the lazy dog."" ; int countA = 0 , countO = 0 , countSpace = 0 , countDot = 0 ; for ( int i = 0 ; i < test . length ( ) ; i ++ ) { switch ( test . charAt ( i ) ) { case 'a' : case 'A' : countA ++ ; break ; case 'o' : case 'O' : countO ++ ; break ; case ' ' : countSpace ++ ; break ; case '.' : countDot ++ ; break ; } } System . out . printf ( ""%s%d%n%s%d%n%s%d%n%s%d"" , ""A: "" , countA , ""O: "" , countO , ""Space: "" , countSpace , ""Dot: "" , countDot ) ; }"
904,"void main ( String [ ] args ) { boolean ObjectID = false ; boolean Class = false ; boolean LastChangedBy = false ; boolean Number = false ; boolean StartEffectivity = false ; boolean EndEffectivity = false ; boolean StartSerialNumberEffectivity = false ; boolean EndSerialNumberEffectivity = false ; boolean StartLotNumberEffectivity = false ; boolean EndLotNumberEffectivity = false ; boolean SerialNumberEffectivityCxtPartNumber = false ; boolean LotNumberEffectivityCxtPartNumber = false ; boolean DefaultUnit = false ; boolean Name = false ; boolean PartType = false ; boolean Source = false ; boolean State = false ; boolean IsPhantom = false ; boolean Version = false ; boolean Iteration = false ; boolean PreviousVersion = false ; boolean IsConfigurable = false ; boolean IsCollapsible = false ; boolean TargetID = false ; try { XMLInputFactory factory = XMLInputFactory . newInstance ( ) ; XMLEventReader eventReader = factory . createXMLEventReader ( new FileReader ( ""c:\\staxTestFile.xml"" ) ) ; while ( eventReader . hasNext ( ) ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLStreamConstants . START_ELEMENT : StartElement startElement = event . asStartElement ( ) ; String qName = startElement . getName ( ) . getLocalPart ( ) ; if ( qName . equalsIgnoreCase ( ""Part"" ) ) { System . out . println ( ""Start Element : Part"" ) ; Iterator < Attribute > attributes = startElement . getAttributes ( ) ; } else if ( qName . equalsIgnoreCase ( ""ObjectID"" ) ) { ObjectID = true ; } else if ( qName . equalsIgnoreCase ( ""Class"" ) ) { Class = true ; } else if ( qName . equalsIgnoreCase ( ""LastChangedBy"" ) ) { LastChangedBy = true ; } else if ( qName . equalsIgnoreCase ( ""Number"" ) ) { Number = true ; } else if ( qName . equalsIgnoreCase ( ""StartEffectivity"" ) ) { StartEffectivity = true ; } else if ( qName . equalsIgnoreCase ( ""EndSerialNumberEffectivity"" ) ) { EndSerialNumberEffectivity = true ; } else if ( qName . equalsIgnoreCase ( ""StartSerialNumberEffectivity"" ) ) { StartSerialNumberEffectivity = true ; } else if ( qName . equalsIgnoreCase ( ""EndSerialNumberEffectivity"" ) ) { EndSerialNumberEffectivity = true ; } else if ( qName . equalsIgnoreCase ( ""StartLotNumberEffectivity"" ) ) { StartLotNumberEffectivity = true ; } else if ( qName . equalsIgnoreCase ( ""EndLotNumberEffectivity"" ) ) { EndLotNumberEffectivity = true ; } else if ( qName . equalsIgnoreCase ( ""SerialNumberEffectivityCxtPartNumber"" ) ) { SerialNumberEffectivityCxtPartNumber = true ; } else if ( qName . equalsIgnoreCase ( ""LotNumberEffectivityCxtPartNumber"" ) ) { LotNumberEffectivityCxtPartNumber = true ; } else if ( qName . equalsIgnoreCase ( ""DefaultUnit"" ) ) { DefaultUnit = true ; } else if ( qName . equalsIgnoreCase ( ""Name"" ) ) { Name = true ; } else if ( qName . equalsIgnoreCase ( ""PartType"" ) ) { PartType = true ; } else if ( qName . equalsIgnoreCase ( ""Source"" ) ) { Source = true ; } else if ( qName . equalsIgnoreCase ( ""State"" ) ) { State = true ; } else if ( qName . equalsIgnoreCase ( ""IsPhantom"" ) ) { IsPhantom = true ; } else if ( qName . equalsIgnoreCase ( ""Version"" ) ) { Version = true ; } else if ( qName . equalsIgnoreCase ( ""Iteration"" ) ) { Iteration = true ; } else if ( qName . equalsIgnoreCase ( ""PreviousVersion"" ) ) { PreviousVersion = true ; } else if ( qName . equalsIgnoreCase ( ""IsConfigurable"" ) ) { IsConfigurable = true ; } else if ( qName . equalsIgnoreCase ( ""IsCollapsible"" ) ) { IsCollapsible = true ; } else if ( qName . equalsIgnoreCase ( ""TargetID"" ) ) { TargetID = true ; } break ; case XMLStreamConstants . CHARACTERS : Characters characters = event . asCharacters ( ) ; if ( ObjectID ) { System . out . println ( ""ObjectID: "" + characters . getData ( ) ) ; ObjectID = false ; } if ( Class ) { System . out . println ( ""Class: "" + characters . getData ( ) ) ; Class = false ; } if ( LastChangedBy ) { System . out . println ( ""LastChangedBy "" + characters . getData ( ) ) ; LastChangedBy = false ; } if ( Number ) { System . out . println ( ""Number: "" + characters . getData ( ) ) ; Number = false ; } if ( StartEffectivity ) { System . out . println ( ""StartEffectivity: "" + characters . getData ( ) ) ; StartEffectivity = false ; } if ( EndEffectivity ) { System . out . println ( ""EndEffectivity "" + characters . getData ( ) ) ; EndEffectivity = false ; } if ( StartSerialNumberEffectivity ) { System . out . println ( ""StartSerialNumberEffectivity "" + characters . getData ( ) ) ; StartSerialNumberEffectivity = false ; } if ( EndSerialNumberEffectivity ) { System . out . println ( ""EndSerialNumberEffectivity: "" + characters . getData ( ) ) ; EndSerialNumberEffectivity = false ; } if ( StartLotNumberEffectivity ) { System . out . println ( ""StartLotNumberEffectivity"" + characters . getData ( ) ) ; StartLotNumberEffectivity = false ; } if ( EndLotNumberEffectivity ) { System . out . println ( ""EndLotNumberEffectivity: "" + characters . getData ( ) ) ; EndLotNumberEffectivity = false ; } if ( SerialNumberEffectivityCxtPartNumber ) { System . out . println ( ""SerialNumberEffectivityCxtPartNumber "" + characters . getData ( ) ) ; SerialNumberEffectivityCxtPartNumber = false ; } if ( LotNumberEffectivityCxtPartNumber ) { System . out . println ( ""LotNumberEffectivityCxtPartNumber: "" + characters . getData ( ) ) ; LotNumberEffectivityCxtPartNumber = false ; } if ( DefaultUnit ) { System . out . println ( ""DefaultUnit: "" + characters . getData ( ) ) ; DefaultUnit = false ; } if ( Name ) { System . out . println ( ""Name: "" + characters . getData ( ) ) ; Name = false ; } if ( PartType ) { System . out . println ( ""PartType: "" + characters . getData ( ) ) ; PartType = false ; } if ( Source ) { System . out . println ( ""Source: "" + characters . getData ( ) ) ; Source = false ; } if ( State ) { System . out . println ( ""State: "" + characters . getData ( ) ) ; State = false ; } if ( IsPhantom ) { System . out . println ( ""IsPhantom: "" + characters . getData ( ) ) ; IsPhantom = false ; } if ( Version ) { System . out . println ( ""Version: "" + characters . getData ( ) ) ; Version = false ; } if ( Iteration ) { System . out . println ( ""Iteration: "" + characters . getData ( ) ) ; Iteration = false ; } if ( PreviousVersion ) { System . out . println ( ""PreviousVersion: "" + characters . getData ( ) ) ; PreviousVersion = false ; } if ( IsConfigurable ) { System . out . println ( ""IsConfigurable: "" + characters . getData ( ) ) ; IsConfigurable = false ; } if ( IsCollapsible ) { System . out . println ( ""IsCollapsible: "" + characters . getData ( ) ) ; IsCollapsible = false ; } if ( TargetID ) { System . out . println ( ""TargetID: "" + characters . getData ( ) ) ; TargetID = false ; } break ; case XMLStreamConstants . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( ""Part"" ) ) { System . out . println ( ""End Element : Part"" ) ; System . out . println ( ) ; } break ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
905,"void main ( String [ ] s ) throws VTDException { VTDGen vg = new VTDGen ( ) ; AutoPilot ap = new AutoPilot ( ) ; ap . selectXPath ( ""//part/*[text()]"" ) ; if ( ! vg . parseFile ( ""d:\\xml\\soap.xml"" , false ) ) { System . out . println ( ""invalid xml"" ) ; System . exit ( 0 ) ; } VTDNav vn = vg . getNav ( ) ; ap . bind ( vn ) ; int i = 0 ; while ( ( i = ap . evalXPath ( ) ) != - 1 ) { System . out . println ( "" "" + vn . toRawString ( i ) + "" = "" + vn . toNormalizedString ( vn . getText ( ) ) ) ; } }"
906,"void main ( String [ ] args ) { System . out . println ( ""Enter Number to convert into words"" ) ; Scanner sc = new Scanner ( System . in ) ; long num = sc . nextInt ( ) ; int rem = 0 ; int i = 0 ; while ( num > 0 ) { if ( i == 0 ) { rem = ( int ) ( num % 1000 ) ; printText ( rem ) ; num = num / 1000 ; i ++ ; } else if ( num > 0 ) { rem = ( int ) ( num % 100 ) ; if ( rem > 0 ) text = denom . values ( ) [ i - 1 ] + "" "" + text ; printText ( rem ) ; num = num / 100 ; i ++ ; } } if ( i > 0 ) System . out . println ( text ) ; else System . out . println ( ""Zero"" ) ; }"
907,"void main ( String [ ] args ) { System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 0 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 9 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 19 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 21 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 28 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 71 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 72 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 80 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 81 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 89 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 90 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 91 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 97 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 101 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 110 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 120 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 200 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 201 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 232 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 999 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2000000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 3000000000L ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2147483647 ) ) ; }"
908,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
909,"void transform ( HSSFCell cellOld , XSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( ! this . styleMap . containsKey ( hash ) ) { this . transform ( hash , cellOld . getCellStyle ( ) , this . workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
910,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
911,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
912,"void main ( String [ ] args ) { String s = ""aaaabbccccdddeee"" ; String s1 = """" ; String s2 = """" ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s1 . indexOf ( s . charAt ( i ) ) < 0 ) { s1 = s1 + s . charAt ( i ) ; } } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s1 . charAt ( i ) == s . charAt ( j ) ) { count ++ ; } } s2 = s2 + s1 . charAt ( i ) + count ; count = 0 ; } System . out . println ( s2 ) ; }"
913,"void main ( String [ ] args ) { String output = """" ; Multiset < String > wordsMultiset = HashMultiset . create ( ) ; String [ ] words = ""AAABBBBCC"" . split ( """" ) ; wordsMultiset . addAll ( Arrays . asList ( words ) ) ; for ( Entry < String > string : wordsMultiset . entrySet ( ) ) { if ( ! string . getElement ( ) . isEmpty ( ) ) output += string . getCount ( ) + """" + string . getElement ( ) ; } System . out . println ( output ) ; }"
914,"void mouseReleased ( MouseEvent e ) { target . mouseReleased ( e ) ; if ( pressed != null ) { if ( getDragDistance ( e ) < MAX_CLICK_DISTANCE ) { MouseEvent clickEvent = new MouseEvent ( ( Component ) pressed . getSource ( ) , MouseEvent . MOUSE_CLICKED , e . getWhen ( ) , pressed . getModifiers ( ) , pressed . getX ( ) , pressed . getY ( ) , pressed . getXOnScreen ( ) , pressed . getYOnScreen ( ) , pressed . getClickCount ( ) , pressed . isPopupTrigger ( ) , pressed . getButton ( ) ) ; target . mouseClicked ( clickEvent ) ; } pressed = null ; } }"
915,"void mouseReleased ( int mod , Point loc ) { if ( pressLocation != null && dragLocation != null ) { pressLocation = null ; } else if ( dragLocation != null ) { } else { } pressLocation = null ; dragLocation = null ; }"
916,boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : NavUtils . navigateUpFromSameTask ( this ) ; return true ; default : return super . onOptionsItemSelected ( item ) ; } }
917,"boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : if ( getParentActivityIntent ( ) == null ) { Log . i ( TAG , ""You have forgotten to specify the parentActivityName in the AndroidManifest!"" ) ; onBackPressed ( ) ; } else { NavUtils . navigateUpFromSameTask ( this ) ; } return true ; default : return super . onOptionsItemSelected ( item ) ; } }"
918,"byte [ ] read ( final File file ) { if ( file . isDirectory ( ) ) throw new RuntimeException ( ""Unsupported operation, file "" + file . getAbsolutePath ( ) + "" is a directory"" ) ; if ( file . length ( ) > Integer . MAX_VALUE ) throw new RuntimeException ( ""Unsupported operation, file "" + file . getAbsolutePath ( ) + "" is too big"" ) ; Throwable pending = null ; FileInputStream in = null ; final byte buffer [ ] = new byte [ ( int ) file . length ( ) ] ; try { in = new FileInputStream ( file ) ; in . read ( buffer ) ; } catch ( Exception e ) { pending = new RuntimeException ( ""Exception occured on reading file "" + file . getAbsolutePath ( ) , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { if ( pending == null ) { pending = new RuntimeException ( ""Exception occured on closing file"" + file . getAbsolutePath ( ) , e ) ; } } } if ( pending != null ) { throw new RuntimeException ( pending ) ; } } return buffer ; }"
919,"byte [ ] read ( File file ) throws IOException , FileTooBigException { if ( file . length ( ) > MAX_FILE_SIZE ) { throw new FileTooBigException ( file ) ; } ByteArrayOutputStream ous = null ; InputStream ios = null ; try { byte [ ] buffer = new byte [ 4096 ] ; ous = new ByteArrayOutputStream ( ) ; ios = new FileInputStream ( file ) ; int read = 0 ; while ( ( read = ios . read ( buffer ) ) != - 1 ) { ous . write ( buffer , 0 , read ) ; } } finally { try { if ( ous != null ) ous . close ( ) ; } catch ( IOException e ) { } try { if ( ios != null ) ios . close ( ) ; } catch ( IOException e ) { } } return ous . toByteArray ( ) ; }"
920,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
921,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Time (s)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; drawRotate ( gg , getWidth ( ) , ( getHeight ( ) + width ) / 2 , 270 , string ) ; }"
922,void run ( ) { if ( bar . isDisposed ( ) || bar . getShell ( ) . isDisposed ( ) ) { return ; } synchronized ( lock ) { bar . getShell ( ) . pack ( true ) ; orgSize [ 0 ] = bar . getShell ( ) . getSize ( ) . y ; currentSize [ 0 ] = orgSize [ 0 ] ; } }
923,void run ( ) { synchronized ( lock ) { if ( bar . isDisposed ( ) || bar . getShell ( ) . isDisposed ( ) ) { return ; } currentSize [ 0 ] = bar . getShell ( ) . getSize ( ) . y ; if ( currentSize [ 0 ] != orgSize [ 0 ] ) { return ; } else { bar . getShell ( ) . layout ( true ) ; bar . getShell ( ) . pack ( true ) ; } } }
924,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
925,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
926,"void actionPerformed ( ActionEvent e ) { ImageIcon saveIcon = new ImageIcon ( ""save-icon.png"" ) ; int askSave = JOptionPane . showConfirmDialog ( null , ""Save current image?"" , """" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , saveIcon ) ; if ( askSave == JOptionPane . YES_OPTION ) { saveImage ( ) ; Picture p = new Picture ( ) ; imageLabel . setIcon ( new ImageIcon ( image ) ) ; frame . setSize ( width ( ) , height ( ) ) ; } else { Picture p = new Picture ( ) ; imageLabel . setIcon ( new ImageIcon ( image ) ) ; frame . setSize ( width ( ) , height ( ) ) ; } }"
927,"void actionPerformed ( ActionEvent e ) { ImageIcon widthIcon = new ImageIcon ( ""LR-arrows.png"" ) ; String scaleWidth = ( String ) JOptionPane . showInputDialog ( null , ""What should the new width be?"" , """" , JOptionPane . QUESTION_MESSAGE , widthIcon , null , null ) ; ImageIcon heightIcon = new ImageIcon ( ""UD-arrows.png"" ) ; String scaleHeight = ( String ) JOptionPane . showInputDialog ( null , ""What should the new height be?"" , """" , JOptionPane . QUESTION_MESSAGE , widthIcon , null , null ) ; double x = Double . parseDouble ( scaleWidth ) ; double y = Double . parseDouble ( scaleHeight ) ; int newWidth = ( int ) x ; int newHeight = ( int ) y ; frame . setSize ( newWidth , newHeight ) ; scale ( newWidth , newHeight ) ; }"
928,"int solution ( Integer number ) { String binary = Integer . toBinaryString ( number ) ; String [ ] gaps = binary . split ( ""1"" ) ; String biggestGap = """" ; for ( int i = 0 ; i < ( binary . endsWith ( ""1"" ) ? gaps . length : gaps . length - 1 ) ; i ++ ) { if ( gaps [ i ] . contains ( ""0"" ) && gaps [ i ] . length ( ) > biggestGap . length ( ) ) biggestGap = gaps [ i ] ; } return biggestGap . length ( ) ; }"
929,"int solution ( int N ) { int result = 0 ; while ( N > 0 ) { if ( ( N & 1 ) == 1 ) { int temp = 0 ; while ( ( N >>= 1 ) > 0 && ( ( N & 1 ) != 1 ) ) { temp ++ ; } result = Math . max ( result , temp ) ; } else { N >>= 1 ; } } return result ; }"
930,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
931,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Distance (m)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; gg . drawString ( string , ( getWidth ( ) - width ) / 2 , 11 ) ; }"
932,"void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; Scanner stdin = new Scanner ( System . in ) ; do { System . out . println ( ""Current list is "" + list ) ; System . out . println ( ""Add more? (y/n)"" ) ; if ( stdin . next ( ) . startsWith ( ""y"" ) ) { System . out . println ( ""Enter : "" ) ; list . add ( stdin . next ( ) ) ; } else { break ; } } while ( true ) ; stdin . close ( ) ; System . out . println ( ""List is "" + list ) ; String [ ] arr = list . toArray ( new String [ 0 ] ) ; System . out . println ( ""Array is "" + Arrays . toString ( arr ) ) ; }"
933,"void main ( String [ ] args ) { int arr [ ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 5 ; i ++ ) { System . out . print ( ""Enter number "" + ( i + 1 ) + "": "" ) ; arr [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 5 ; i ++ ) System . out . println ( ""Number "" + ( i + 1 ) + "": "" + arr [ i ] ) ; }"
934,"void onRequestPermissionsResult ( int requestCode , String permissions [ ] , int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( grantResults . length == 0 || grantResults == null ) { } else if ( grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { } else if ( grantResults [ 0 ] == PackageManager . PERMISSION_DENIED ) { } }"
935,"void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { if ( requestCode == mRequestCode ) { if ( grantResults . length > 0 ) { for ( int grantResult : grantResults ) { if ( grantResult != PackageManager . PERMISSION_GRANTED ) { mRequestPermissionListener . onFailed ( ) ; return ; } } mRequestPermissionListener . onSuccess ( ) ; } else { mRequestPermissionListener . onFailed ( ) ; } } }"
936,"void main ( String [ ] args ) { char [ ] chars = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"" . toCharArray ( ) ; final int mid = ( chars . length + 1 ) / 2 ; System . out . println ( ""Mid: "" + mid ) ; System . out . println ( ""Start : "" + new String ( chars ) ) ; if ( ( chars . length % 2 ) == 1 ) { char first = chars [ 0 ] ; for ( int l = 1 , r = mid ; r < chars . length ; l ++ , r ++ ) { chars [ l - 1 ] = chars [ r ] ; chars [ r ] = chars [ l ] ; } chars [ mid - 1 ] = first ; } else { for ( int l = 0 , r = mid ; r < chars . length ; l ++ , r ++ ) { swap ( chars , l , r ) ; } } System . out . println ( ""Pass 1: "" + new String ( chars ) ) ; swap ( chars , 0 , chars . length - 2 ) ; swap ( chars , 1 , chars . length - 1 ) ; System . out . println ( ""Pass 2: "" + new String ( chars ) ) ; swap ( chars , mid - 1 , mid + 1 ) ; swap ( chars , mid - 2 , mid ) ; System . out . println ( ""Pass 3: "" + new String ( chars ) ) ; }"
937,"void main ( String [ ] args ) { System . out . println ( ""Hello World"" ) ; String xyz = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"" ; final int mid = ( xyz . length ( ) + 1 ) / 2 ; String [ ] spstr = { xyz . substring ( 0 , mid ) , xyz . substring ( mid ) } ; String firstMix = spstr [ 1 ] + spstr [ 0 ] ; String [ ] array = firstMix . split ( """" ) ; for ( int i = 1 ; i < 3 ; i ++ ) { String temp = array [ i ] ; array [ i ] = array [ array . length - i ] ; array [ array . length - i ] = temp ; } String str1 = Arrays . toString ( array ) ; str1 = str1 . substring ( 1 , str1 . length ( ) - 1 ) . replaceAll ( "","" , """" ) ; int j = 2 ; for ( int i = ( ( array . length / 2 ) - 2 ) ; i < ( array . length ) / 2 ; i ++ ) { String temp = array [ i ] ; array [ i ] = array [ array . length / 2 + j ] ; array [ array . length / 2 + j ] = temp ; j -- ; } String str2 = Arrays . toString ( array ) ; str2 = str2 . substring ( 1 , str2 . length ( ) - 1 ) . replaceAll ( "","" , """" ) ; System . out . println ( firstMix ) ; System . out . println ( str1 ) ; System . out . println ( str2 ) ; }"
938,boolean isNumber ( String s ) { boolean isNumber = true ; for ( int i = 0 ; i < s . length ( ) && isNumber ; i ++ ) { char c = s . charAt ( i ) ; isNumber = isNumber & ( ( c >= '0' && c <= '9' ) || ( c == '.' ) || ( c == 'e' ) || ( c == 'E' ) || ( c == '' ) ) ; } return isInteger ; }
939,"boolean isNumber ( String str ) { int i = 0 , len = str . length ( ) ; boolean a = false , b = false , c = false , d = false ; if ( i < len && ( str . charAt ( i ) == '+' || str . charAt ( i ) == '-' ) ) i ++ ; while ( i < len && isDigit ( str . charAt ( i ) ) ) { i ++ ; a = true ; } if ( i < len && ( str . charAt ( i ) == '.' ) ) i ++ ; while ( i < len && isDigit ( str . charAt ( i ) ) ) { i ++ ; b = true ; } if ( i < len && ( str . charAt ( i ) == 'e' || str . charAt ( i ) == 'E' ) && ( a || b ) ) { i ++ ; c = true ; } if ( i < len && ( str . charAt ( i ) == '+' || str . charAt ( i ) == '-' ) && c ) i ++ ; while ( i < len && isDigit ( str . charAt ( i ) ) ) { i ++ ; d = true ; } return i == len && ( a || b ) && ( ! c || ( c && d ) ) ; }"
940,"String join ( Collection s , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; Iterator iter = s . iterator ( ) ; while ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { buffer . append ( delimiter ) ; } } return buffer . toString ( ) ; }"
941,"String join ( String [ ] input , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; for ( String value : input ) { sb . append ( value ) ; sb . append ( delimiter ) ; } int length = sb . length ( ) ; if ( length > 0 ) { sb . setLength ( length - delimiter . length ( ) ) ; } return sb . toString ( ) ; }"
942,"void main ( String [ ] args ) { int [ ] A = { 9 , 5 , 4 , 3 , 2 , 1 , 34 , 53 } ; int [ ] B = new int [ A . length ] ; int [ ] C = new int [ A . length ] ; int t = 4 ; int j = 0 , k = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { B [ j ] = A [ i ] ; j ++ ; } else { C [ k ] = A [ i ] ; k ++ ; } } for ( int i = 0 ; i < j ; i ++ ) { System . out . println ( ""B = "" + B [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) { System . out . println ( ""C = "" + C [ i ] ) ; } }"
943,"void main ( String [ ] args ) { int [ ] A = { 9 , 5 , 4 , 3 , 2 , 1 , 34 , 53 } ; int [ ] B = new int [ A . length ] ; int [ ] C = new int [ A . length ] ; int t = 4 ; int countb = 0 ; int countc = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= t ) { B [ countb ++ ] = A [ i ] ; } else { C [ countc ++ ] = A [ i ] ; } } System . out . println ( Arrays . toString ( B ) ) ; System . out . println ( Arrays . toString ( C ) ) ; }"
944,boolean equals ( Object that ) { if ( this == that ) return true ; if ( ! ( that instanceof People ) ) return false ; People thatPeople = ( People ) that ; return this . name . equals ( thatPeople . name ) && this . age == thatPeople . age ; }
945,boolean equals ( Object other ) { boolean result ; if ( ( other == null ) || ( getClass ( ) != other . getClass ( ) ) ) { result = false ; } else { People otherPeople = ( People ) other ; result = name . equals ( otherPeople . name ) && age == otherPeople . age ; } return result ; }
946,"void main ( String [ ] args ) { int first , second ; Scanner myScanner = new Scanner ( System . in ) ; System . out . println ( ""Enter first integer: "" ) ; int numOne ; numOne = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numOne ) ; System . out . println ( ""Enter second integer: "" ) ; int numTwo ; numTwo = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numTwo ) ; Random generator = new Random ( ) ; int num = ( int ) ( Math . random ( ) * numTwo ) ; System . out . println ( ""Random number: "" + ( ( num > numOne ) ? num : numOne + num ) ) ; }"
947,"void main ( String ... aArgs ) { log ( ""Generating 10 random integers in range 1..10."" ) ; int START = 1 ; int END = 10 ; Random randomGenerator = new Random ( ) ; for ( int idx = 1 ; idx <= 10 ; ++ idx ) { showRandomInteger ( START , END , randomGenerator ) ; } log ( ""Done"" ) ; }"
948,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
949,"HSSFFont transform ( HSSFWorkbook workbookNew , XSSFFont fontOld ) { HSSFFont fontNew = workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }"
950,"void tick ( float delta ) { for ( Entity e : entities ) { if ( color == Color . WHITE ) { if ( getSurrounding ( - 32 , - 32 ) != null && getSurrounding ( - 32 , - 32 ) . getColor ( ) == Color . BLACK ) { if ( getSurrounding ( - 32 , - 32 ) . getStrength ( ) < strength ) { getSurrounding ( - 32 , - 32 ) . setStrength ( - 50 ) ; } } } if ( ! inGame . entities . isEmpty ( ) && strength <= 0 ) { inGame . entities . remove ( this ) ; } } }"
951,void tick ( float delta ) { Entity removeEntity = null ; for ( Entity e : entities ) { e . tick ( delta ) ; if ( e . checkStrength ( ) ) { removeEntity = e ; break ; } } if ( removeEntity != null ) { entities . remove ( removeEntity ) ; } player . tick ( delta ) ; }
952,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { CharSequence out = super . filter ( source , start , end , dest , dstart , dend ) ; if ( out != null ) { source = out ; start = 0 ; end = out . length ( ) ; } int len = end - start ; if ( len == 0 ) { return source ; } int dlen = dest . length ( ) ; for ( int i = 0 ; i < dstart ; i ++ ) { if ( dest . charAt ( i ) == '.' ) { return ( dlen - ( i + 1 ) + len > digits ) ? """" : new SpannableStringBuilder ( source , start , end ) ; } } for ( int i = start ; i < end ; ++ i ) { if ( source . charAt ( i ) == '.' ) { if ( ( dlen - dend ) + ( end - ( i + 1 ) ) > digits ) return """" ; else break ; } } return new SpannableStringBuilder ( source , start , end ) ; }"
953,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String lsStart = """" ; String lsInsert = """" ; String lsEnd = """" ; String lsText = """" ; Log . d ( ""debug"" , moPattern . toString ( ) ) ; Log . d ( ""debug"" , ""source: "" + source + "", start: "" + start + "", end:"" + end + "", dest: "" + dest + "", dstart: "" + dstart + "", dend: "" + dend ) ; lsText = dest . toString ( ) ; if ( lsText . length ( ) > 0 ) { lsStart = lsText . substring ( 0 , dstart ) ; Log . d ( ""debug"" , ""lsStart : "" + lsStart ) ; if ( source != """" ) { lsInsert = source . toString ( ) ; Log . d ( ""debug"" , ""lsInsert: "" + lsInsert ) ; } lsEnd = lsText . substring ( dend ) ; Log . d ( ""debug"" , ""lsEnd   : "" + lsEnd ) ; lsText = lsStart + lsInsert + lsEnd ; Log . d ( ""debug"" , ""lsText  : "" + lsText ) ; } Matcher loMatcher = moPattern . matcher ( lsText ) ; Log . d ( ""debug"" , ""loMatcher.matches(): "" + loMatcher . matches ( ) + "", lsText: "" + lsText ) ; if ( ! loMatcher . matches ( ) ) { return """" ; } return null ; }"
954,"void main ( String args [ ] ) { String [ ] arr = { ""foo:1,2,3"" , ""bar:a,b"" , ""baz:5,6,7"" } ; CartesianProductLHM cp = new CartesianProductLHM ( arr ) ; List < List < String > > lls = cp . allUniqueCombinations ( ) ; for ( List < String > ls : lls ) { for ( String s : ls ) System . out . print ( s + ""\t"" ) ; System . out . println ( ) ; } }"
955,"void main ( String [ ] args ) { LinkedHashMap < String , Vector < String > > data = new LinkedHashMap < String , Vector < String > > ( ) ; data . put ( ""foo"" , new Vector < String > ( Arrays . asList ( ""1"" , ""2"" , ""3"" ) ) ) ; data . put ( ""bar"" , new Vector < String > ( Arrays . asList ( ""3"" , ""2"" ) ) ) ; data . put ( ""baz"" , new Vector < String > ( Arrays . asList ( ""5"" , ""6"" , ""7"" ) ) ) ; Foo foo = new Foo ( data ) ; for ( String [ ] combination : foo . allUniqueCombinations ( ) ) { System . out . println ( Arrays . toString ( combination ) ) ; } }"
956,boolean isPerfectSquare ( long number ) { if ( number < 0 ) return false ; if ( number < 2 ) return true ; for ( int i = 0 ; ; i ++ ) { long square = squareTable [ i ] ; if ( square > number ) return false ; while ( number % square == 0 ) { number /= square ; } if ( number == 1 ) return true ; } }
957,boolean isPerfectSquare ( long n ) { if ( n < 0 ) { return false ; } else { switch ( ( byte ) n ) { case - 128 : case - 127 : case - 124 : case - 119 : case - 112 : case - 111 : case - 103 : case - 95 : case - 92 : case - 87 : case - 79 : case - 71 : case - 64 : case - 63 : case - 60 : case - 55 : case - 47 : case - 39 : case - 31 : case - 28 : case - 23 : case - 15 : case - 7 : case 0 : case 1 : case 4 : case 9 : case 16 : case 17 : case 25 : case 33 : case 36 : case 41 : case 49 : case 57 : case 64 : case 65 : case 68 : case 73 : case 81 : case 89 : case 97 : case 100 : case 105 : case 113 : case 121 : long i = ( n * INV3465 ) > > > 52 ; if ( ! good3465 [ ( int ) i ] ) { return false ; } else { long r = round ( Math . sqrt ( n ) ) ; return r * r == n ; } default : return false ; } } }
958,"void type ( CharSequence chars , int ms ) { ms = ms > 0 ? ms : 0 ; for ( int i = 0 , len = chars . length ( ) ; i < len ; i ++ ) { char c = chars . charAt ( i ) ; AWTKeyStroke keyStroke = getKeyStroke ( c ) ; int keyCode = keyStroke . getKeyCode ( ) ; boolean shift = Character . isUpperCase ( c ) || keyStroke . getModifiers ( ) == ( SHIFT_DOWN_MASK + 1 ) ; if ( shift ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; } robot . keyPress ( keyCode ) ; robot . keyRelease ( keyCode ) ; if ( shift ) { robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } if ( ms > 0 ) { robot . delay ( ms ) ; } } }"
959,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_SHIFT , VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_AT ) ; break ; case '#' : doType ( VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_AMPERSAND ) ; break ; case '*' : doType ( VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
960,void shuffle ( ) { int [ ] temp = new int [ TOTALCARDS ] ; for ( int i = 0 ; i < temp . length ; i ++ ) { temp [ i ] = i ; } for ( int i = 0 ; i < temp . length ; i ++ ) { deck . push ( protoDeck [ temp [ i ] ] ) ; } }
961,void shuffle ( int numberOfCards ) { for ( int i = 0 ; i < numberOfCards ; i ++ ) { int j = rand . nextInt ( protoDeck . length - i ) + i ; Card tmp = deck [ i ] ; deck [ i ] = deck [ j ] ; deck [ j ] = tmp ; } }
962,"String sequenceNums ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( ) ; int rangeStart = nums [ 0 ] ; int previous = nums [ 0 ] ; int current ; int expected = previous + 1 ; int size = nums . length ; for ( int i = 1 ; i < size ; i ++ ) { current = nums [ i ] ; expected = previous + 1 ; if ( current != expected ) { addRange ( sb , rangeStart , previous ) ; rangeStart = current ; } previous = current ; } addRange ( sb , rangeStart , nums [ size - 1 ] ) ; return sb . toString ( ) ; }"
963,"String sequenceNums ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( ) ; if ( nums . length == 0 ) return sb . toString ( ) ; int begin = nums [ 0 ] , end = nums [ 0 ] ; for ( int cur : nums ) if ( cur - end <= 1 ) end = cur ; else { appendRange ( sb , begin , end ) ; begin = end = cur ; } appendRange ( sb , begin , end ) ; return sb . substring ( 1 ) ; }"
964,void removeDuplicates ( char [ ] str ) { if ( str == null || str . length < 2 ) { return ; } int tail = 0 ; for ( int i = 0 ; i < str . length ; i ++ ) { boolean found = false ; for ( int j = 0 ; j < i ; j ++ ) { if ( str [ j ] == str [ i ] ) { found = true ; break ; } } if ( found ) { continue ; } str [ tail ] = str [ i ] ; tail ++ ; } str [ tail ] = '\0' ; }
965,void removeDuplicates ( char [ ] str ) { int map = 0 ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( ( map & ( 1 << ( str [ i ] - 'a' ) ) ) > 0 ) str [ i ] = 0 ; else map |= 1 << ( str [ i ] - 'a' ) ; } }
966,"void serialize ( Test value , JsonGenerator jgen , SerializerProvider provider ) throws IOException , JsonProcessingException { jgen . writeStartObject ( ) ; Field [ ] fields = value . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { try { jgen . writeObjectField ( field . getName ( ) , field . get ( value ) ) ; } catch ( IllegalArgumentException | IllegalAccessException e ) { e . printStackTrace ( ) ; } } jgen . writeObjectField ( ""extra_field"" , ""whatever_value"" ) ; jgen . writeEndObject ( ) ; }"
967,"void serialize ( final Object bean , final JsonGenerator jgen , final SerializerProvider provider ) throws IOException , JsonGenerationException { jgen . writeStartObject ( ) ; if ( _propertyFilterId != null ) { serializeFieldsFiltered ( bean , jgen , provider ) ; } else { serializeFields ( bean , jgen , provider ) ; } serializerListener . postSerialization ( bean , jgen ) ; jgen . writeEndObject ( ) ; }"
968,void switchPairs ( ) { ListNode prev = front ; if ( front != null && front . next != null ) { ListNode temp = front ; front = front . next ; temp . next = front . next ; front . next = temp ; prev = temp ; } while ( prev != null && prev . next != null && prev . next . next != null ) { ListNode first_node = prev . next ; ListNode second_node = first_node . next ; first_node . next = second_node . next ; second_node . next = first_node ; prev . next = second_node ; prev = first_node ; } }
969,"ListNode switchPairs ( ) { if ( this == null || this . next == null ) return this ; ListNode top = this . next ; ListNode first = this ; ListNode second = first . next ; do { ListNode third = second . next ; second . next = first ; first . next = third ; first = third ; System . out . println ( ""@@@ "" + this . toString ( ) ) ; if ( first != null ) { second . next . next = first . next ; second = first . next ; } } while ( first != null && second != null ) ; return top ; }"
970,"void countString ( String str , Character character ) { int [ ] counts = new int [ MAX_CHAR ] ; char [ ] chars = str . toCharArray ( ) ; for ( char ch : chars ) { if ( character != null && character != ch ) { continue ; } counts [ ch ] ++ ; } for ( int i = 0 ; i < counts . length ; i ++ ) { if ( counts [ i ] > 0 ) { System . out . println ( ""Character "" + ( char ) i + "" appeared "" + counts [ i ] + "" times"" ) ; } } }"
971,"void countString ( String str ) { if ( str != null ) { int length = str . length ( ) ; char ch [ ] = str . toCharArray ( ) ; Arrays . sort ( ch ) ; if ( length > 0 ) { char x = ch [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < length ; i ++ ) { if ( ch [ i ] == x ) { count ++ ; } else { System . out . println ( ""Number of Occurrence of '"" + ch [ i - 1 ] + ""' is: "" + count ) ; x = ch [ i ] ; count = 1 ; } } System . out . println ( ""Number of Occurrence of '"" + ch [ length - 1 ] + ""' is: "" + count ) ; } } }"
972,"void main ( String args [ ] ) { System . out . println ( ""Enter the date(dd/mm/yyyy):"" ) ; Scanner scan = new Scanner ( System . in ) ; String Date = scan . nextLine ( ) ; try { boolean dateValid = dateValidate ( Date ) ; if ( dateValid == true ) { SimpleDateFormat df = new SimpleDateFormat ( ""dd/MM/yy"" ) ; java . util . Date date = df . parse ( Date ) ; df . applyPattern ( ""EEE"" ) ; String day = df . format ( date ) ; if ( day . compareTo ( ""Sat"" ) == 0 || day . compareTo ( ""Sun"" ) == 0 ) { System . out . println ( day + "": Weekend"" ) ; } else { System . out . println ( day + "": Weekday"" ) ; } } else { System . out . println ( ""Invalid Date!!!"" ) ; } } catch ( Exception e ) { System . out . println ( ""Invalid Date Formats!!!"" ) ; } }"
973,"void main ( String [ ] args ) throws ParseException { String month = ""08"" ; String day = ""05"" ; String year = ""2015"" ; String inputDateStr = String . format ( ""%s/%s/%s"" , day , month , year ) ; Date inputDate = new SimpleDateFormat ( ""dd/MM/yyyy"" ) . parse ( inputDateStr ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( inputDate ) ; String dayOfWeek = calendar . getDisplayName ( Calendar . DAY_OF_WEEK , Calendar . LONG , Locale . US ) . toUpperCase ( ) ; System . out . println ( dayOfWeek ) ; }"
974,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int [ ] seen = new int [ 256 ] ; Arrays . fill ( seen , 0 ) ; s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { seen [ s1 . charAt ( i ) ] = seen [ s1 . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( seen [ s2 . charAt ( i ) ] == 0 ) return false ; seen [ s2 . charAt ( i ) ] = seen [ s2 . charAt ( i ) ] - 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( seen [ i ] != 0 ) return false ; } return true ; }"
975,"Boolean isAnagram ( String word , String anagram_word ) { if ( word . length ( ) != anagram_word . length ( ) ) { return false ; } char [ ] words_char = word . toCharArray ( ) ; char [ ] anagram_word_char = anagram_word . toCharArray ( ) ; int words_char_num = 1 ; int anagram_word_num = 1 ; Map < Character , Integer > wordPrimeMap = wordPrimeMap ( ) ; for ( int i = 0 ; i < words_char . length ; i ++ ) { words_char_num *= wordPrimeMap . get ( words_char [ i ] ) ; } for ( int i = 0 ; i < anagram_word_char . length ; i ++ ) { anagram_word_num *= wordPrimeMap . get ( anagram_word_char [ i ] ) ; } return anagram_word_num == words_char_num ; }"
976,void shuffleArray ( int [ ] array ) { int index ; Random random = new Random ( ) ; for ( int i = array . length - 1 ; i > 0 ; i -- ) { index = random . nextInt ( i + 1 ) ; if ( index != i ) { array [ index ] ^= array [ i ] ; array [ i ] ^= array [ index ] ; array [ index ] ^= array [ i ] ; } } }
977,void shuffleArray ( int [ ] array ) { List < Integer > list = new ArrayList < > ( ) ; for ( int i : array ) { list . add ( i ) ; } Collections . shuffle ( list ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { array [ i ] = list . get ( i ) ; } }
978,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
979,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
980,"void run ( ) { int i = 1 ; while ( i < 50 ) { while ( s . getState ( ) != 3 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 3 ) System . out . println ( ""t1 "" + i ) ; s . setState ( 1 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
981,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""toe"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
982,"void sort ( int [ ] input , Speed speed ) { SortStrategy strategy = null ; switch ( speed ) { case SLOW : strategy = new SlowBubbleSortStrategy ( ) ; break ; case MEDIUM : strategy = new MediumInsertationSortStrategy ( ) ; break ; case FAST : strategy = new FastQuickSortStrategy ( ) ; break ; default : strategy = new MediumInsertationSortStrategy ( ) ; } strategy . sort ( input ) ; }"
983,"void sort ( int [ ] input ) { for ( int i = 0 ; i < input . length - 1 ; i ++ ) { int k = i + 1 ; int nxtVal = input [ k ] ; while ( input [ k - 1 ] > nxtVal ) { input [ k ] = input [ k - 1 ] ; k -- ; if ( k == 0 ) break ; } input [ k ] = nxtVal ; } System . out . println ( ""Medium sorting is done and the result is :"" ) ; for ( int i : input ) { System . out . print ( i + "","" ) ; } }"
984,"Boolean isAnagram ( String word , String anagram_word ) { if ( word . length ( ) != anagram_word . length ( ) ) { return false ; } char [ ] words_char = word . toCharArray ( ) ; char [ ] anagram_word_char = anagram_word . toCharArray ( ) ; int words_char_num = 1 ; int anagram_word_num = 1 ; Map < Character , Integer > wordPrimeMap = wordPrimeMap ( ) ; for ( int i = 0 ; i < words_char . length ; i ++ ) { words_char_num *= wordPrimeMap . get ( words_char [ i ] ) ; } for ( int i = 0 ; i < anagram_word_char . length ; i ++ ) { anagram_word_num *= wordPrimeMap . get ( anagram_word_char [ i ] ) ; } return anagram_word_num == words_char_num ; }"
985,"boolean isAnagram ( String s1 , String s2 ) { StringBuilder sb1 = new StringBuilder ( ) ; StringBuilder sb2 = new StringBuilder ( ) ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; char arr1 [ ] = s1 . toCharArray ( ) ; char arr2 [ ] = s2 . toCharArray ( ) ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( char c : arr1 ) { sb1 . append ( c ) ; } for ( char c : arr2 ) { sb2 . append ( c ) ; } System . out . println ( sb1 . toString ( ) ) ; System . out . println ( sb2 . toString ( ) ) ; if ( sb1 . toString ( ) . equals ( sb2 . toString ( ) ) ) return true ; else return false ; }"
986,"void type ( CharSequence chars , int ms ) { ms = ms > 0 ? ms : 0 ; for ( int i = 0 , len = chars . length ( ) ; i < len ; i ++ ) { char c = chars . charAt ( i ) ; AWTKeyStroke keyStroke = getKeyStroke ( c ) ; int keyCode = keyStroke . getKeyCode ( ) ; boolean shift = Character . isUpperCase ( c ) || keyStroke . getModifiers ( ) == ( SHIFT_DOWN_MASK + 1 ) ; if ( shift ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; } robot . keyPress ( keyCode ) ; robot . keyRelease ( keyCode ) ; if ( shift ) { robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } if ( ms > 0 ) { robot . delay ( ms ) ; } } }"
987,void type ( String text ) { char c ; for ( int ii = 0 ; ii < text . length ( ) ; ii ++ ) { c = text . charAt ( ii ) ; if ( c <= 31 || c == 129 ) { pressControlKey ( c ) ; } else { typeAsciiCode ( c ) ; } } }
988,"String shuffle ( String s ) { String shuffledString = """" ; while ( s . length ( ) != 0 ) { int index = ( int ) Math . floor ( Math . random ( ) * s . length ( ) ) ; char c = s . charAt ( index ) ; s = s . substring ( 0 , index ) + s . substring ( index + 1 ) ; shuffledString += c ; } return shuffledString ; }"
989,String shuffle ( String text ) { char [ ] characters = text . toCharArray ( ) ; for ( int i = 0 ; i < characters . length ; i ++ ) { int randomIndex = ( int ) ( Math . random ( ) * characters . length ) ; char temp = characters [ i ] ; characters [ i ] = characters [ randomIndex ] ; characters [ randomIndex ] = temp ; } return new String ( characters ) ; }
990,"void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Please enter user name : "" ) ; String username = null ; try { username = reader . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( ""You entered : "" + username ) ; Scanner in = new Scanner ( System . in ) ; System . out . print ( ""Please enter user name : "" ) ; username = in . nextLine ( ) ; System . out . println ( ""You entered : "" + username ) ; Console console = System . console ( ) ; username = console . readLine ( ""Please enter user name : "" ) ; System . out . println ( ""You entered : "" + username ) ; }"
991,"void main ( final String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( ""Enter some text, or '"" + EXIT_COMMAND + ""' to quit"" ) ; while ( true ) { System . out . print ( ""><![CDATA[ "" ) ; String input = br . readLine ( ) ; System . out . println ( input ) ; if ( input . length ( ) == EXIT_COMMAND . length ( ) && input . toLowerCase ( ) . equals ( EXIT_COMMAND ) ) { System . out . println ( ""Exiting."" ) ; return ; } System . out . println ( ""...response goes here..."" ) ; } }"
992,"void main ( String [ ] args ) { String text = ""the quick brown fox jumps fox fox over the lazy dog brown"" ; String [ ] keys = text . split ( "" "" ) ; String [ ] uniqueKeys ; int count = 0 ; System . out . println ( text ) ; uniqueKeys = getUniqueKeys ( keys ) ; for ( String key : uniqueKeys ) { if ( null == key ) { break ; } for ( String s : keys ) { if ( key . equals ( s ) ) { count ++ ; } } System . out . println ( ""Count of ["" + key + ""] is : "" + count ) ; count = 0 ; } }"
993,"void main ( String [ ] args ) { String s = ""this is a this is this a this yes this is a this what it may be i do not care about this"" ; String a [ ] = s . split ( "" "" ) ; Map < String , Integer > words = new HashMap < > ( ) ; for ( String str : a ) { if ( words . containsKey ( str ) ) { words . put ( str , 1 + words . get ( str ) ) ; } else { words . put ( str , 1 ) ; } } System . out . println ( words ) ; }"
994,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
995,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
996,"int findMIN ( int [ ] A , int c ) { int first = c ; int id = c ; int x = A [ c ] ; while ( c < A . length ) { if ( x > A [ c ] ) { x = A [ c ] ; id = c ; } c ++ ; } int tmp = A [ first ] ; A [ first ] = A [ id ] ; A [ id ] = tmp ; return x ; }"
997,"int findMIN ( int [ ] A , int c ) { int x = A [ c ] ; int position = c ; while ( c < A . length ) { if ( x > A [ c ] ) { x = A [ c ] ; position = c ; } c ++ ; } return position ; }"
998,"void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String st = br . readLine ( ) ; int len = st . length ( ) ; String [ ] str = new String [ 7 ] ; len = len / 30 ; int i = 0 ; for ( ; i < 7 && i < len ; i ++ ) { str [ i ] = st . substring ( 30 * i , 30 * ( i + 1 ) ) ; System . out . println ( str [ i ] ) ; } if ( i != 7 ) { str [ i ] = st . substring ( 30 * i , st . length ( ) ) ; System . out . println ( str [ i ] ) ; } }"
999,"void main ( String [ ] args ) { String x = ""flskdafsld~fdsakÃ§kÃ§fsda sfdaldsak~Ã§fdskkfadsÃ§lkÃ§fldskÃ§lflÃ§fdskÃ§ldksÃ§lkfdslÃ§akafdslÃ§dsklÃ§fdskÃ§lafdskÃ§kdfsÃ§lkfds~Ã§lkfasdÃ§lÃ§fdls~kÃ§lf~dksÃ§lsakdÃ§lkfÃ§"" ; System . out . println ( ""x length: "" + x . length ( ) ) ; String [ ] lines = Split ( x , 30 , 210 ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { System . out . println ( ""lines["" + i + ""]: (len: "" + lines [ i ] . length ( ) + "") : "" + lines [ i ] ) ; } }"
1000,"void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 } , { 2 , 3 , 4 } , { 3 , 4 , 5 } } ; int multiplier = 1 ; for ( int i = 0 ; i < a . length ; i ++ ) { multiplier = multiplier * a [ i ] [ i ] ; } System . out . println ( multiplier ) ; }"
1001,"void main ( String [ ] args ) throws Exception { int [ ] [ ] matrix = new int [ 3 ] [ ] ; matrix [ 0 ] = new int [ ] { 1 , 2 , 2 } ; matrix [ 1 ] = new int [ ] { 2 , 2 , 3 } ; matrix [ 2 ] = new int [ ] { 0 , 1 , 2 } ; int resultL2R = 1 ; int resultR2L = 1 ; for ( int i = 0 ; i < matrix . length ; i ++ ) { resultL2R *= matrix [ i ] [ i ] ; resultR2L *= matrix [ i ] [ matrix . length - 1 - i ] ; } System . out . println ( ""left-to-right: "" + resultL2R ) ; System . out . println ( ""right-to-left: "" + resultR2L ) ; }"
1002,"void throwException ( final String exClassName ) throws CheckedException , UncheckedException { Class < ? > clazz ; try { clazz = Class . forName ( exClassName ) ; } catch ( ClassNotFoundException cnfe ) { throw new InternalError ( exClassName , cnfe ) ; } if ( CheckedException . class . isAssignableFrom ( clazz ) ) { throw newException ( clazz . asSubclass ( CheckedException . class ) ) ; } else if ( UncheckedException . class . isAssignableFrom ( clazz ) ) { throw newException ( clazz . asSubclass ( UncheckedException . class ) ) ; } else { throw new InternalError ( exClassName + "" is not a valid exception"" ) ; } }"
1003,"void throwException ( String className ) throws CheckedException , UncheckedException { Class < ? > exceptionClass ; try { exceptionClass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } try { if ( CheckedException . class . isAssignableFrom ( exceptionClass ) ) { throw exceptionClass . asSubclass ( CheckedException . class ) . newInstance ( ) ; } else if ( UncheckedException . class . isAssignableFrom ( exceptionClass ) ) { throw exceptionClass . asSubclass ( UncheckedException . class ) . newInstance ( ) ; } else { throw new IllegalArgumentException ( ""Not a valid exception type: "" + exceptionClass . getName ( ) ) ; } } catch ( InstantiationException | IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } }"
1004,"void displayImage ( String strfilename , JLabel label ) { try { BufferedImage image = ImageIO . read ( new File ( strfilename + "".jpg"" ) ) ; ImageIcon icon = new ImageIcon ( image ) ; label . setIcon ( icon ) ; } catch ( IOException | NullPointerException ex ) { ImageIcon icon = new ImageIcon ( ""NOIMAGE.jpg"" ) ; label . setIcon ( icon ) ; } }"
1005,"void displayImage ( String strfilename , JLabel JLlabel ) { BufferedImage image = null ; if ( ! isImageExist ( strfilename ) ) { image = ImageIO . read ( new File ( ""NOIMAGE.jpg"" ) ) ; } else { try { image = ImageIO . read ( new File ( strfilename + "".jpg"" ) ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } ImageIcon icon = new ImageIcon ( image ) ; JLlabel . setIcon ( icon ) ; }"
1006,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1007,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1008,"void main ( String [ ] args ) { char [ ] num1 = ""127"" . toCharArray ( ) ; char [ ] num2 = ""32"" . toCharArray ( ) ; int [ ] intermediate = new int [ num1 . length ] ; for ( int i = 0 ; i < num1 . length ; i ++ ) { for ( int j = 0 ; j < num2 . length ; j ++ ) { int d1 = num1 [ num1 . length - i - 1 ] - '0' ; int d2 = num2 [ num2 . length - j - 1 ] - '0' ; intermediate [ i ] += d1 * d2 * ( int ) Math . pow ( 10 , j ) ; System . out . printf ( ""  %d X %d = %d\n"" , d1 , d2 , intermediate [ i ] ) ; } intermediate [ i ] *= ( int ) Math . pow ( 10 , i ) ; System . out . println ( "" intermediate : "" + intermediate [ i ] ) ; } int sum = 0 ; for ( int i : intermediate ) { sum += i ; } System . out . println ( ""Sum is = "" + sum ) ; }"
1009,"void main ( String [ ] args ) { String number1 = ""108"" ; String number2 = ""84"" ; char [ ] n1 = number1 . toCharArray ( ) ; char [ ] n2 = number2 . toCharArray ( ) ; int result = 0 ; for ( int i = 0 ; i < n1 . length ; i ++ ) { for ( int j = 0 ; j < n2 . length ; j ++ ) { result += ( n1 [ i ] - '0' ) * ( n2 [ j ] - '0' ) * ( int ) Math . pow ( 10 , n1 . length + n2 . length - ( i + j + 2 ) ) ; } } System . out . println ( result ) ; }"
1010,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1011,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , Integer hash , XSSFCellStyle styleOld , HSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( workbookOld , workbookNew , styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( workbookNew , ( XSSFFont ) styleOld . getFont ( ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
1012,"void main ( String ... args ) { processor = new DefaultProcessor ( ) ; long [ ] values = new long [ ] { 0 , 4 , 10 , 12 , 100 , 108 , 299 , 1000 , 1003 , 2040 , 45213 , 100000 , 100005 , 100010 , 202020 , 202022 , 999999 , 1000000 , 1000001 , 10000000 , 10000007 , 99999999 , Long . MAX_VALUE , Long . MIN_VALUE } ; String [ ] strValues = new String [ ] { ""0001.2"" , ""3.141592"" } ; for ( long val : values ) { System . out . println ( val + "" = "" + processor . getName ( val ) ) ; } for ( String strVal : strValues ) { System . out . println ( strVal + "" = "" + processor . getName ( strVal ) ) ; } StringBuilder bigNumber = new StringBuilder ( ) ; for ( int d = 0 ; d < 66 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } bigNumber . append ( ""."" ) ; for ( int d = 0 ; d < 26 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } System . out . println ( bigNumber . toString ( ) + "" = "" + processor . getName ( bigNumber . toString ( ) ) ) ; }"
1013,"void main ( String [ ] args ) { System . out . println ( ""Enter Number to convert into words"" ) ; Scanner sc = new Scanner ( System . in ) ; long num = sc . nextInt ( ) ; int rem = 0 ; int i = 0 ; while ( num > 0 ) { if ( i == 0 ) { rem = ( int ) ( num % 1000 ) ; printText ( rem ) ; num = num / 1000 ; i ++ ; } else if ( num > 0 ) { rem = ( int ) ( num % 100 ) ; if ( rem > 0 ) text = denom . values ( ) [ i - 1 ] + "" "" + text ; printText ( rem ) ; num = num / 100 ; i ++ ; } } if ( i > 0 ) System . out . println ( text ) ; else System . out . println ( ""Zero"" ) ; }"
1014,"void main ( String args [ ] ) { int i ; int large [ ] = new int [ 5 ] ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int max = 0 , index ; for ( int j = 0 ; j < 5 ; j ++ ) { max = array [ 0 ] ; index = 0 ; for ( i = 1 ; i < array . length ; i ++ ) { if ( max < array [ i ] ) { max = array [ i ] ; index = i ; } } large [ j ] = max ; array [ index ] = Integer . MIN_VALUE ; System . out . println ( ""Largest "" + j + "" : "" + large [ j ] ) ; } }"
1015,"void main ( String [ ] args ) { int large [ ] = new int [ 10 ] ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int k = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { large [ k ++ ] = getMax ( 0 , array ) ; } System . out . println ( ""Largest 5 is: "" + Arrays . toString ( Arrays . copyOf ( large , 5 ) ) ) ; }"
1016,"void main ( String [ ] args ) { LinkedList < String > list = new LinkedList < > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String input = StdIn . readString ( ) ; if ( input . equals ( ""print"" ) ) { StdOut . println ( list . toString ( ) ) ; continue ; } if ( input . charAt ( 0 ) == ( '+' ) ) { list . add ( input . substring ( 1 ) ) ; continue ; } if ( input . charAt ( 0 ) == ( '-' ) ) { list . remove ( input . substring ( 1 ) ) ; continue ; } break ; } }"
1017,"void main ( String [ ] args ) { Node root = null ; DataInputStream reader = new DataInputStream ( System . in ) ; int op = 0 ; while ( op != 6 ) { try { System . out . println ( ""Enter Option:\n1:Insert Front 2:Delete Front 3:Insert Rear 4:Delete Rear 5:Display List 6:Exit"" ) ; op = Integer . parseInt ( reader . readLine ( ) ) ; switch ( op ) { case 1 : System . out . println ( ""Enter Value: "" ) ; int val = Integer . parseInt ( reader . readLine ( ) ) ; root = insertNodeFront ( val , root ) ; display ( root ) ; break ; case 2 : root = removeNodeFront ( root ) ; display ( root ) ; break ; case 3 : System . out . println ( ""Enter Value: "" ) ; val = Integer . parseInt ( reader . readLine ( ) ) ; root = insertNodeRear ( val , root ) ; display ( root ) ; break ; case 4 : root = removeNodeRear ( root ) ; display ( root ) ; break ; case 5 : display ( root ) ; break ; default : System . out . println ( ""Invalid Option"" ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } System . out . println ( ""Exited!!!"" ) ; try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
1018,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1019,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , HSSFCell cellOld , XSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( XSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1020,"void filter ( String [ ] words , BufferedReader reader ) throws IOException { String text ; while ( ( text = reader . readLine ( ) ) != null ) { for ( int i = 0 ; i < words . length ; i ++ ) { if ( text . toLowerCase ( ) . contains ( words [ i ] . toLowerCase ( ) ) ) { System . out . println ( text ) ; break ; } } } }"
1021,"void filter ( String [ ] words , String text ) { for ( int i = 0 ; i < words . length ; i ++ ) { if ( text . toLowerCase ( ) . contains ( words [ i ] . toLowerCase ( ) ) ) { System . out . println ( text ) ; break ; } } }"
1022,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; char [ ] c1 = s1 . toCharArray ( ) ; char [ ] c2 = s2 . toCharArray ( ) ; Arrays . sort ( c1 ) ; Arrays . sort ( c2 ) ; String sc1 = new String ( c1 ) ; String sc2 = new String ( c2 ) ; return sc1 . equals ( sc2 ) ; }"
1023,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int n = s1 . length ( ) ; int [ ] charMap = new int [ 256 ] ; for ( int i = 0 ; i < n ; i ++ ) { char c1 = s1 . charAt ( i ) ; charMap [ c1 ] ++ ; char c2 = s2 . charAt ( i ) ; charMap [ c2 ] -- ; } for ( int i = 0 ; i < charMap . length ; i ++ ) { if ( charMap [ i ] != 0 ) return false ; } return true ; }"
1024,"String findFirstCharacter ( String s ) { Set < Integer > singles = new LinkedHashSet < > ( ) , duplicates = new HashSet < > ( ) ; s . codePoints ( ) . forEach ( ch -> { if ( ! duplicates . contains ( ch ) && ! singles . add ( ch ) ) { singles . remove ( ch ) ; duplicates . add ( ch ) ; } } ) ; return ( singles . isEmpty ( ) ? null : new String ( new int [ ] { singles . iterator ( ) . next ( ) } , 0 , 1 ) ) ; }"
1025,"char findFirstCharacter ( String s ) { HashSet < Character > unique = new LinkedHashSet < > ( ) , seen = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( seen . add ( c ) ) unique . add ( c ) ; else unique . remove ( c ) ; } return unique . isEmpty ( ) ? '_' : unique . iterator ( ) . next ( ) ; }"
1026,"void main ( String [ ] args ) { ObjectMapper mapper = new ObjectMapper ( ) ; try { File json = new File ( ""test.json"" ) ; CollectionType tweetListType = mapper . getTypeFactory ( ) . constructCollectionType ( ArrayList . class , Tweet . class ) ; List < Tweet > tweets = mapper . readValue ( json , tweetListType ) ; System . out . println ( ""Java objects created from JSON String:"" ) ; tweets . forEach ( System . out :: println ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }"
1027,"void main ( String [ ] args ) throws Exception { Tweet [ ] tweets ; ObjectMapper mapper = new ObjectMapper ( ) ; try { File json = new File ( ""test.json"" ) ; tweets = mapper . readValue ( json , Tweet [ ] . class ) ; System . out . println ( ""Java object created from JSON String :"" ) ; Arrays . asList ( tweets ) . forEach ( System . out :: println ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }"
1028,String generateRandomPassword ( int length ) { StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { int c = RANDOM . nextInt ( 62 ) ; if ( c <= 9 ) { sb . append ( String . valueOf ( c ) ) ; } else if ( c < 36 ) { sb . append ( ( char ) ( 'a' + c - 10 ) ) ; } else { sb . append ( ( char ) ( 'A' + c - 36 ) ) ; } } return sb . toString ( ) ; }
1029,"String generateRandomPassword ( final int length ) { if ( length < 1 ) { throw new IllegalArgumentException ( ""length must be greater than 0"" ) ; } final char [ ] buf = new char [ length ] ; for ( int idx = 0 ; idx < buf . length ; ++ idx ) { buf [ idx ] = symbols [ RANDOM . nextInt ( symbols . length ) ] ; } return shuffle ( new String ( buf ) ) ; }"
1030,"Command deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { try { JsonObject commandObject = json . getAsJsonObject ( ) ; JsonElement commandTypeElement = commandObject . get ( commandElementName ) ; Class < ? extends Command > commandInstanceClass = commandRegistry . get ( commandTypeElement . getAsString ( ) ) ; Command command = gson . fromJson ( json , commandInstanceClass ) ; return command ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }"
1031,"IAnimal deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { JsonObject jsonObject = json . getAsJsonObject ( ) ; JsonPrimitive prim = ( JsonPrimitive ) jsonObject . get ( CLASSNAME ) ; String className = prim . getAsString ( ) ; Class < ? > klass = null ; try { klass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new JsonParseException ( e . getMessage ( ) ) ; } return context . deserialize ( jsonObject . get ( INSTANCE ) , klass ) ; }"
1032,"void main ( String [ ] args ) { final String USERNAME = ""abc"" ; final String PASSWORD = ""abc"" ; final String host = ""3.98.22.10"" ; final int port = 22 ; HashMap < String , List < String > > result = new HashMap < String , List < String > > ( ) ; exec_linux_cmd ex = new exec_linux_cmd ( ) ; result = ex . exec_cmd ( USERNAME , PASSWORD , host , port , cmd ) ; System . out . println ( ""Result ---> "" + result . get ( ""result"" ) ) ; System . out . println ( ""Error Msg ---> "" + result . get ( ""error"" ) ) ; }"
1033,"void main ( String args [ ] ) throws InterruptedException , IOException { List < String > command = new ArrayList < String > ( ) ; command . add ( args [ 0 ] ) ; ProcessBuilder builder = new ProcessBuilder ( command ) ; Map < String , String > environ = builder . environment ( ) ; final Process process = builder . start ( ) ; InputStream is = process . getInputStream ( ) ; InputStreamReader isr = new InputStreamReader ( is ) ; BufferedReader br = new BufferedReader ( isr ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { System . out . println ( line ) ; } System . out . println ( ""Program terminated!"" ) ; }"
1034,void duplication ( ) { int max = 100 ; int min = 1 ; boolean duplicate = false ; Random rand = new Random ( ) ; int [ ] all = new int [ 20 ] ; for ( int x = 0 ; x < 20 ; x ++ ) { duplicate = false ; int randomNum = rand . nextInt ( ( max - min ) + 1 ) + min ; for ( int i : all ) { if ( i == randomNum ) { duplicate = true ; break ; } } if ( duplicate ) { x -- ; } else { all [ x ] = randomNum ; } } }
1035,void duplication ( ) { int max = 100 ; int min = 1 ; Random rand = new Random ( ) ; int index = 0 ; int [ ] all = new int [ 20 ] ; while ( index < 20 ) { boolean duplicate = false ; int randomNum = rand . nextInt ( ( max - min ) + 1 ) + min ; for ( int i = 0 ; i < all . length ; i ++ ) { if ( all [ i ] == randomNum ) { duplicate = true ; break ; } } if ( ! duplicate ) { all [ index ++ ] = randomNum ; } } }
1036,"void actionPerformed ( ActionEvent e ) { System . out . println ( ) ; System . out . println ( ""Display Dialogs"" ) ; for ( Window window : Window . getWindows ( ) ) { if ( window instanceof JDialog ) { JDialog dialog = ( JDialog ) window ; System . out . println ( ""\t"" + dialog . getTitle ( ) + "" "" + dialog . isDisplayable ( ) ) ; } } }"
1037,"void actionPerformed ( ActionEvent e ) { System . out . println ( ) ; System . out . println ( ""Create Dialog"" ) ; JDialog dialog = new JDialog ( ) ; dialog . getContentPane ( ) . setLayout ( null ) ; for ( int i = 0 ; i < 200 ; i ++ ) { dialog . add ( new JTextField ( ""some text"" ) ) ; } dialog . setTitle ( ""Dialog "" + count ++ ) ; dialog . setLocation ( count * 25 , count * 25 ) ; dialog . setVisible ( true ) ; System . out . println ( ""\tCreated "" + dialog . getTitle ( ) ) ; }"
1038,"String decrypt ( final String msg ) { final Pattern regex = Pattern . compile ( ""((\\d\\d)(#)|(\\d))"" ) ; final Matcher regexMatcher = regex . matcher ( msg ) ; final StringBuffer result = new StringBuffer ( ) ; String c ; while ( regexMatcher . find ( ) ) { if ( regexMatcher . group ( 2 ) == null ) { c = regexMatcher . group ( 1 ) ; } else { c = regexMatcher . group ( 2 ) ; } result . append ( ( char ) ( ( Integer . parseInt ( c ) + 'a' ) - 1 ) ) ; } return result . toString ( ) ; }"
1039,"String decrypt ( final String s ) { final List < Integer > crypt = new ArrayList < > ( ) ; final String [ ] groups = s . split ( ""#"" ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { final String group = groups [ i ] ; int j = 0 ; if ( ( i == ( groups . length - 1 ) ) && ! s . endsWith ( ""#"" ) ) { j = group . length ( ) ; } if ( group . length ( ) > 2 ) { j = group . length ( ) - 2 ; } for ( int k = 0 ; k < j ; k ++ ) { crypt . add ( Integer . valueOf ( group . substring ( k , k + 1 ) ) ) ; } if ( j < group . length ( ) ) { crypt . add ( Integer . valueOf ( group . substring ( j , group . length ( ) ) ) ) ; } } final StringBuilder n = new StringBuilder ( crypt . size ( ) ) ; for ( final Integer c : crypt ) { final char d = ( char ) ( ( 'a' + c ) - 1 ) ; n . append ( d ) ; } return n . toString ( ) ; }"
1040,"void shuffle ( int [ ] array ) { if ( random == null ) random = new Random ( ) ; int count = array . length ; for ( int i = count ; i > 1 ; i -- ) { swap ( array , i - 1 , random . nextInt ( i ) ) ; } }"
1041,void shuffle ( Object [ ] a ) { int n = a . length ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( int ) ( Math . random ( ) * ( n - i ) ) ; Object swap = a [ r ] ; a [ r ] = a [ i ] ; a [ i ] = swap ; } }
1042,"void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > al2 = new ArrayList < Integer > ( ) ; System . out . println ( ""enter the item in list"" ) ; while ( sc . hasNextInt ( ) ) { al2 . add ( sc . nextInt ( ) ) ; } Iterator it1 = al2 . iterator ( ) ; while ( it1 . hasNext ( ) ) { System . out . println ( it1 . next ( ) ) ; } }"
1043,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; System . out . print ( ""Enter integers please "" ) ; System . out . println ( ""(EOF or non-integer to terminate): "" ) ; while ( scan . hasNextInt ( ) ) { list . add ( scan . nextInt ( ) ) ; } Integer [ ] nums = list . toArray ( new Integer [ 0 ] ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { System . out . println ( nums [ i ] ) ; } }"
1044,"void addFolderToZip ( String path , String srcFolder , ZipOutputStream zip ) throws Exception { File folder = new File ( srcFolder ) ; for ( String fileName : folder . list ( ) ) { if ( path . equals ( """" ) ) { addFileToZip ( folder . getName ( ) , srcFolder + ""/"" + fileName , zip ) ; } else { addFileToZip ( path + ""/"" + folder . getName ( ) , srcFolder + ""/"" + fileName , zip ) ; } } }"
1045,"void addFolderToZip ( String path , String srcFolder , ZipOutputStream zip ) throws IOException { File folder = new File ( srcFolder ) ; if ( folder . list ( ) . length == 0 ) { addFileToZip ( path , srcFolder , zip , true ) ; } else { for ( String fileName : folder . list ( ) ) { if ( path . equals ( """" ) ) { addFileToZip ( folder . getName ( ) , srcFolder + ""/"" + fileName , zip , false ) ; } else { addFileToZip ( path + ""/"" + folder . getName ( ) , srcFolder + ""/"" + fileName , zip , false ) ; } } } }"
1046,"void run ( ) { try { String line = null ; BufferedReader inErr = new BufferedReader ( new InputStreamReader ( inErrStream ) ) ; while ( ( line = inErr . readLine ( ) ) != null ) { println ( line ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } System . out . println ( ""Exit reading error stream"" ) ; }"
1047,"void run ( ) { try { int retValue = pro . waitFor ( ) ; println ( ""Command exit with return value "" + retValue ) ; outStream . close ( ) ; outStream = null ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
1048,boolean checkZero ( Class clazz ) { boolean zeroNumericFields = true ; Field [ ] fields = clazz . getDeclaredFields ( ) ; boolean zeroNumericFields = true ; List < Class > numberClasses = new ArrayList < Class > ( ) ; numberClasses . add ( Number . class ) ; numberClasses . add ( Integer . class ) ; numberClasses . add ( Long . class ) ; numberClasses . add ( Double . class ) ; numberClasses . add ( Float . class ) ; if ( fields . length > 0 ) { for ( Field field : fields ) { if ( numberClasses . contains ( field . getType ( ) ) ) { zeroNumericFields = false ; break ; } } } return zeroNumericFields ; }
1049,"boolean checkZero ( Object toCheck ) { final Class < ? > numerics = new Class < ? > [ ] { int . class , double . class , float . class , long . class , short . class , byte . class , Integer . class , Double . class , Float . class , Long . class , Short . class , Byte . class } ; try { Class < ? > clazz = toCheck . getClass ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { Class < ? > type = field . getType ( ) ; boolean isNumeric = false ; for ( Class < ? > numeric : numerics ) { if ( type . equals ( numeric ) ) { isNumeric = true ; break ; } } if ( isNumeric ) { Object value = field . get ( toCheck ) ; if ( value == 0 ) { return true ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; }"
1050,"void main ( String ... argv ) throws Exception { FileChannel fc = new FileInputStream ( argv [ 0 ] ) . getChannel ( ) ; ByteBuffer bb = fc . map ( FileChannel . MapMode . READ_ONLY , 0 , fc . size ( ) ) ; CharBuffer cb = Charset . defaultCharset ( ) . decode ( bb ) ; Pattern p = Pattern . compile ( ""[^ \t\r\n\f.,!?:;\""()']+"" ) ; Map < String , Integer > counts = new TreeMap < String , Integer > ( ) ; Matcher m = p . matcher ( cb ) ; while ( m . find ( ) ) { String word = m . group ( ) ; Integer count = counts . get ( word ) ; count = ( count == null ) ? 1 : count + 1 ; counts . put ( word , count ) ; } fc . close ( ) ; for ( Map . Entry < String , Integer > e : counts . entrySet ( ) ) { System . out . printf ( ""%s: %d%n"" , e . getKey ( ) , e . getValue ( ) ) ; } }"
1051,"void main ( String args [ ] ) { Map < String , Integer > tm = new TreeMap < String , Integer > ( ) ; try { FileInputStream fis = new FileInputStream ( ""Test.txt"" ) ; DataInputStream in = new DataInputStream ( fis ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; int countValue = 1 ; while ( ( line = br . readLine ( ) ) != null ) { line = line . replaceAll ( ""[-+.^:;,()\""\\[\\]]"" , """" ) ; StringTokenizer st = new StringTokenizer ( line , "" "" ) ; while ( st . hasMoreTokens ( ) ) { String nextElement = ( String ) st . nextElement ( ) ; if ( tm . size ( ) > 0 && tm . containsKey ( nextElement ) ) { int val = 0 ; if ( tm . get ( nextElement ) != null ) { val = ( Integer ) tm . get ( nextElement ) ; val = val + 1 ; } tm . put ( nextElement , val ) ; } else { tm . put ( nextElement , 1 ) ; } } } for ( Map . Entry < String , Integer > entry : tm . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + "" : "" + entry . getValue ( ) ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
1052,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
1053,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
1054,"boolean contains ( String a , String b ) { int diff = a . length ( ) - b . length ( ) ; while ( a . length ( ) > 0 ) { b = b . replace ( a . substring ( 0 , 1 ) , """" ) ; a = a . replace ( a . substring ( 0 , 1 ) , """" ) ; if ( diff != a . length ( ) - b . length ( ) ) return false ; } return true ; }"
1055,"boolean contains ( String a , String b ) { boolean status = true ; Map < String , Integer > mapA = new HashMap < > ( ) ; Map < String , Integer > mapB = new HashMap < > ( ) ; for ( char i : a . toCharArray ( ) ) { Integer val = mapA . get ( """" + i ) ; if ( val != null ) { mapA . put ( """" + i , val + 1 ) ; } else { mapA . put ( """" + i , 1 ) ; } } for ( char i : b . toCharArray ( ) ) { Integer val = mapB . get ( """" + i ) ; if ( val != null ) { mapB . put ( """" + i , val + 1 ) ; } else { mapB . put ( """" + i , 1 ) ; } } for ( Map . Entry < String , Integer > entry : mapA . entrySet ( ) ) { if ( mapB . get ( entry . getKey ( ) ) == null || entry . getValue ( ) > mapB . get ( entry . getKey ( ) ) ) { status = false ; } } return status ; }"
1056,"boolean isBalanced ( String brackets ) { Map < Character , Character > braces = new HashMap < > ( ) ; braces . put ( '(' , ')' ) ; braces . put ( '[' , ']' ) ; braces . put ( '{' , '}' ) ; if ( brackets . length ( ) % 2 != 0 ) { return false ; } Stack < Character > halfBraces = new Stack ( ) ; for ( char ch : brackets . toCharArray ( ) ) { if ( braces . containsKey ( ch ) ) { halfBraces . push ( braces . get ( ch ) ) ; } else if ( halfBraces . isEmpty ( ) || ch != halfBraces . pop ( ) ) { return false ; } } return halfBraces . isEmpty ( ) ; }"
1057,boolean isBalanced ( String str ) { boolean result = false ; if ( str . length ( ) < 2 ) return false ; Stack < Character > stack = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ! parenthesesMapRight . containsKey ( ch ) && ! parenthesesMapLeft . containsKey ( ch ) ) { continue ; } if ( parenthesesMapLeft . containsKey ( ch ) ) { stack . push ( ch ) ; } else { if ( ! stack . isEmpty ( ) && stack . pop ( ) == parenthesesMapRight . get ( ch ) . charValue ( ) ) { result = true ; } else { return false ; } } } if ( ! stack . isEmpty ( ) ) return result = false ; return result ; }
1058,"void main ( String [ ] args ) { String sent1 = ""Mary and Meera are my classmates."" ; String sent2 = ""Meera and Mary are my classmates."" ; String sent3 = ""Alice and Bobe are not my classmates."" ; String sent4 = ""Some totally different sentence."" ; System . out . println ( ""Distance between \n'"" + sent1 + ""' \nand '"" + sent2 + ""': \n"" + computeDistance ( sent1 , sent2 ) ) ; System . out . println ( ""Distance between \n'"" + sent1 + ""' \nand '"" + sent3 + ""': \n"" + computeDistance ( sent1 , sent3 ) ) ; System . out . println ( ""Distance between \n'"" + sent1 + ""' \nand '"" + sent4 + ""': \n"" + computeDistance ( sent1 , sent4 ) ) ; }"
1059,"void main ( String [ ] args ) { try { ArrayList < String > sentences = null ; sentences = new ArrayList < String > ( ) ; sentences . add ( ""Mary and Meera are my classmates."" ) ; sentences . add ( ""Mary and Meera are my classmates."" ) ; sentences . add ( ""Meera and Mary are my classmates."" ) ; sentences . add ( ""Alice and Bobe are not my classmates."" ) ; sentences . add ( ""Some totally different sentence."" ) ; wordAnalyser ( sentences ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
1060,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( value . isEmpty ( ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! tensName . isEmpty ( ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1061,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1062,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1063,"void transform ( HSSFCell cellOld , XSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( ! this . styleMap . containsKey ( hash ) ) { this . transform ( hash , cellOld . getCellStyle ( ) , this . workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1064,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] answer = new int [ P . length ] ; char [ ] chars = S . toCharArray ( ) ; int [ ] [ ] cumulativeAnswers = new int [ 4 ] [ chars . length + 1 ] ; for ( int iii = 0 ; iii < chars . length ; iii ++ ) { if ( iii > 0 ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { cumulativeAnswers [ zzz ] [ iii + 1 ] = cumulativeAnswers [ zzz ] [ iii ] ; } } switch ( chars [ iii ] ) { case 'A' : cumulativeAnswers [ 0 ] [ iii + 1 ] ++ ; break ; case 'C' : cumulativeAnswers [ 1 ] [ iii + 1 ] ++ ; break ; case 'G' : cumulativeAnswers [ 2 ] [ iii + 1 ] ++ ; break ; case 'T' : cumulativeAnswers [ 3 ] [ iii + 1 ] ++ ; break ; } } for ( int iii = 0 ; iii < P . length ; iii ++ ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { if ( ( cumulativeAnswers [ zzz ] [ Q [ iii ] + 1 ] - cumulativeAnswers [ zzz ] [ P [ iii ] ] ) > 0 ) { answer [ iii ] = zzz + 1 ; break ; } } } return answer ; }"
1065,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] result = new int [ P . length ] ; int [ ] factor1 = new int [ S . length ( ) ] ; int [ ] factor2 = new int [ S . length ( ) ] ; int [ ] factor3 = new int [ S . length ( ) ] ; int [ ] factor4 = new int [ S . length ( ) ] ; int factor1Sum = 0 ; int factor2Sum = 0 ; int factor3Sum = 0 ; int factor4Sum = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : factor1Sum ++ ; break ; case 'C' : factor2Sum ++ ; break ; case 'G' : factor3Sum ++ ; break ; case 'T' : factor4Sum ++ ; break ; default : break ; } factor1 [ i ] = factor1Sum ; factor2 [ i ] = factor2Sum ; factor3 [ i ] = factor3Sum ; factor4 [ i ] = factor4Sum ; } for ( int i = 0 ; i < P . length ; i ++ ) { int start = P [ i ] ; int end = Q [ i ] ; if ( start == 0 ) { if ( factor1 [ end ] > 0 ) { result [ i ] = 1 ; } else if ( factor2 [ end ] > 0 ) { result [ i ] = 2 ; } else if ( factor3 [ end ] > 0 ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } else { if ( factor1 [ end ] > factor1 [ start - 1 ] ) { result [ i ] = 1 ; } else if ( factor2 [ end ] > factor2 [ start - 1 ] ) { result [ i ] = 2 ; } else if ( factor3 [ end ] > factor3 [ start - 1 ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } } return result ; }"
1066,"void main ( String [ ] args ) { int size = 10 ; double skew = 2.0 ; ZipfGenerator z0 = new ZipfGenerator ( size , skew ) ; FastZipfGenerator z1 = new FastZipfGenerator ( size , skew ) ; long before = 0 ; long after = 0 ; int n = 5000000 ; before = System . nanoTime ( ) ; Map < Integer , Integer > counts0 = computeCounts ( z0 , size , n ) ; after = System . nanoTime ( ) ; System . out . println ( counts0 + "", duration "" + ( after - before ) / 1e6 ) ; before = System . nanoTime ( ) ; Map < Integer , Integer > counts1 = computeCounts ( z1 , size , n ) ; after = System . nanoTime ( ) ; System . out . println ( counts1 + "", duration "" + ( after - before ) / 1e6 ) ; }"
1067,"void main ( String [ ] args ) { if ( args . length != 2 ) { System . out . println ( ""usage: ./zipf size skew"" ) ; System . exit ( - 1 ) ; } ZipfGenerator zipf = new ZipfGenerator ( Integer . valueOf ( args [ 0 ] ) , Double . valueOf ( args [ 1 ] ) ) ; for ( int i = 1 ; i <= 10 ; i ++ ) { System . out . println ( i + "" "" + zipf . getProbability ( i ) ) ; } int hist [ ] = new int [ 12 ] ; for ( int i = 0 ; i < 12 ; i ++ ) { hist [ i ] = 0 ; } System . out . println ( ""Testing the probability distribution:"" ) ; int sum = 0 ; for ( int i = 1 ; i <= 1000000 ; i ++ ) { hist [ zipf . next ( ) ] ++ ; } for ( int i = 0 ; i < 12 ; i ++ ) System . out . println ( i + "" "" + hist [ i ] / 1000000.0 ) ; }"
1068,void run ( ) { while ( true ) { String output = task ( ) ; if ( output != null ) { int count = counter . getAndIncrement ( ) ; System . out . println ( output ) ; if ( count >= 100 ) { break ; } } } }
1069,"void run ( ) { while ( true ) { try { Object expensiveObject = expensiveObjects . take ( ) ; String output = task ( ) ; expensiveObjects . put ( expensiveObject ) ; if ( output != null ) { int counter = outputCount . getAndIncrement ( ) ; System . out . println ( counter ) ; if ( counter >= 100 ) { break ; } } } catch ( InterruptedException e ) { System . out . println ( ""Error!"" ) ; } } }"
1070,boolean isPalindrome ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < ( n / 2 ) ; ++ i ) { if ( s . charAt ( i ) != s . charAt ( n - i - 1 ) ) { return false ; } } return true ; }
1071,boolean isPalindrome ( String str ) { str = str . toUpperCase ( ) ; char [ ] strChars = str . toCharArray ( ) ; List < Character > word = new ArrayList < > ( ) ; for ( char c : strChars ) { word . add ( c ) ; } while ( true ) { if ( ( word . size ( ) == 1 ) || ( word . size ( ) == 0 ) ) { return true ; } if ( word . get ( 0 ) == word . get ( word . size ( ) - 1 ) ) { word . remove ( 0 ) ; word . remove ( word . size ( ) - 1 ) ; } else { return false ; } } }
1072,"void type ( String characters ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection stringSelection = new StringSelection ( characters ) ; clipboard . setContents ( stringSelection , clipboardOwner ) ; robot . keyPress ( KeyEvent . VK_CONTROL ) ; robot . keyPress ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_CONTROL ) ; }"
1073,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_SHIFT , VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_AT ) ; break ; case '#' : doType ( VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_AMPERSAND ) ; break ; case '*' : doType ( VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
1074,"int compare ( String s1 , String s2 ) { String [ ] s1NameNumPair = s1 . split ( "" "" ) ; String [ ] s2NameNumPair = s2 . split ( "" "" ) ; if ( s1NameNumPair [ 0 ] . compareTo ( s2NameNumPair [ 0 ] ) > 1 ) { return 1 ; } else if ( s1NameNumPair [ 0 ] . compareTo ( s2NameNumPair [ 0 ] ) < 0 ) { return - 1 ; } else { Double n1 = Double . parseDouble ( s1NameNumPair [ 1 ] ) ; Double n2 = Double . parseDouble ( s2NameNumPair [ 1 ] ) ; if ( n1 > n2 ) { return 1 ; } else if ( n1 < n2 ) { return - 1 ; } else { return 0 ; } } }"
1075,"int compare ( String s1 , String s2 ) { String [ ] s1NameNumPair = s1 . split ( "" "" ) ; String [ ] s2NameNumPair = s2 . split ( "" "" ) ; int diff = s1NameNumPair [ 0 ] . compareTo ( s2NameNumPair [ 0 ] ) ; if ( 0 == diff ) { Double n1 = Double . parseDouble ( s1NameNumPair [ 1 ] ) ; Double n2 = Double . parseDouble ( s2NameNumPair [ 1 ] ) ; return n1 . compareTo ( n2 ) ; } return diff ; }"
1076,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
1077,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
1078,"void countString ( String str ) { if ( str != null ) { int length = str . length ( ) ; char ch [ ] = str . toCharArray ( ) ; Arrays . sort ( ch ) ; if ( length > 0 ) { char x = ch [ 0 ] ; int count = 1 ; for ( int i = 1 ; i < length ; i ++ ) { if ( ch [ i ] == x ) { count ++ ; } else { System . out . println ( ""Number of Occurrence of '"" + ch [ i - 1 ] + ""' is: "" + count ) ; x = ch [ i ] ; count = 1 ; } } System . out . println ( ""Number of Occurrence of '"" + ch [ length - 1 ] + ""' is: "" + count ) ; } } }"
1079,"void countString ( String str , char searchKey ) { String count = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == searchKey ) count += str . charAt ( i ) + ""\n"" ; } System . out . println ( count + ""\nNumber of Occurrence of "" + searchKey + "" is "" + count . length ( ) + "" in string "" + str ) ; }"
1080,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; Shape outer = new Rectangle ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; Shape inner = new Rectangle ( 0 , 0 , 50 , 50 ) ; Area area = new Area ( outer ) ; area . subtract ( new Area ( inner ) ) ; g2d . setColor ( getBackground ( ) ) ; g2d . fill ( area ) ; g2d . dispose ( ) ; }"
1081,"void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Graphics2D imgG2 = img . createGraphics ( ) ; imgG2 . setBackground ( new Color ( 0 , 0 , 0 , 0 ) ) ; imgG2 . setColor ( Color . red ) ; imgG2 . fillRect ( 0 , 0 , 100 , 100 ) ; imgG2 . clearRect ( 0 , 0 , 50 , 50 ) ; imgG2 . dispose ( ) ; g2 . drawImage ( img , 0 , 0 , null ) ; g2 . dispose ( ) ; super . paintComponent ( g ) ; }"
1082,"void draw ( Graphics2D g ) { float arrowRatio = 0.5f ; float arrowLength = 80.0f ; BasicStroke stroke = ( BasicStroke ) g . getStroke ( ) ; float endX = 350.0f ; float veeX ; switch ( stroke . getLineJoin ( ) ) { case BasicStroke . JOIN_BEVEL : veeX = endX - stroke . getLineWidth ( ) * 0.25f ; break ; default : case BasicStroke . JOIN_MITER : veeX = endX - stroke . getLineWidth ( ) * 0.5f / arrowRatio ; break ; case BasicStroke . JOIN_ROUND : veeX = endX - stroke . getLineWidth ( ) * 0.5f ; break ; } Path2D . Float path = new Path2D . Float ( ) ; path . moveTo ( veeX - arrowLength , - arrowRatio * arrowLength ) ; path . lineTo ( veeX , 0.0f ) ; path . lineTo ( veeX - arrowLength , arrowRatio * arrowLength ) ; g . setColor ( Color . BLUE ) ; g . draw ( path ) ; g . setColor ( Color . YELLOW ) ; g . draw ( new Line2D . Float ( 50.0f , 0.0f , veeX , 0.0f ) ) ; g . setColor ( Color . RED ) ; g . draw ( new Line2D . Float ( 50.0f , 0.0f , veeX - stroke . getLineWidth ( ) * 0.25f , 0.0f ) ) ; }"
1083,"void draw ( Graphics2D g ) { float arrowRatio = 0.5f ; float arrowLength = 80.0f ; BasicStroke stroke = ( BasicStroke ) g . getStroke ( ) ; float endX = 350.0f ; float veeX = endX - stroke . getLineWidth ( ) * 0.5f / arrowRatio ; Path2D . Float path = new Path2D . Float ( ) ; float waisting = 0.5f ; float waistX = endX - arrowLength * 0.5f ; float waistY = arrowRatio * arrowLength * 0.5f * waisting ; float arrowWidth = arrowRatio * arrowLength ; path . moveTo ( veeX - arrowLength , - arrowWidth ) ; path . quadTo ( waistX , - waistY , endX , 0.0f ) ; path . quadTo ( waistX , waistY , veeX - arrowLength , arrowWidth ) ; path . lineTo ( veeX - arrowLength * 0.75f , 0.0f ) ; path . lineTo ( veeX - arrowLength , - arrowWidth ) ; g . setColor ( Color . BLUE ) ; g . fill ( path ) ; g . setColor ( Color . RED ) ; g . draw ( new Line2D . Float ( 50.0f , 0.0f , veeX - arrowLength * 0.5f , 0.0f ) ) ; }"
1084,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
1085,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
1086,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
1087,"void run ( ) { int i = 1 ; while ( i < 50 ) { while ( s . getState ( ) != 3 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 3 ) System . out . println ( ""t1 "" + i ) ; s . setState ( 1 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
1088,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( value . isEmpty ( ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! tensName . isEmpty ( ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1089,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1090,"void main ( String args [ ] ) { int [ ] arr = new int [ 10 ] ; Scanner in = new Scanner ( System . in ) ; int i , min = 0 , max = 0 ; for ( i = 0 ; i <= arr . length ; i ++ ) { System . out . print ( ""Enter any number: "" ) ; arr [ i ] = in . nextInt ( ) ; } min = arr [ 0 ] ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; } if ( arr [ i ] < min ) { min = arr [ i ] ; } } System . out . println ( ""Maximum is: "" + max ) ; System . out . println ( ""Minimum is: "" + min ) ; }"
1091,"void main ( String args [ ] ) { int n , max = Integer . MIN_VALUE , min = Integer . MAX_VALUE ; System . out . println ( ""Enter the number of elements: "" ) ; Scanner sc = new Scanner ( System . in ) ; int [ ] arr = new int [ sc . nextInt ( ) ] ; System . out . println ( ""Enter the elements: "" ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int next = sc . nextInt ( ) ; arr [ i ] = next ; } for ( int j = 0 ; j < arr . length ; j ++ ) { if ( arr [ j ] > max ) max = arr [ j ] ; else if ( arr [ j ] < min ) min = arr [ j ] ; } System . out . println ( ""Highest Value in array: "" + max ) ; System . out . println ( ""Smallest Value in array: "" + min ) ; }"
1092,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
1093,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
1094,"int score ( char [ ] a , char [ ] b , int i , int j ) { if ( i == a . length || j == b . length ) { return 0 ; } else if ( a [ i ] == b [ j ] ) { return 1 + score ( a , b , i + 1 , j + 1 ) ; } else { return max ( score ( a , b , i + 1 , j ) , score ( a , b , i , j + 1 ) ) ; } }"
1095,"int score ( final String gene1 , final String gene2 ) { final char [ ] a ; final char [ ] b ; final int s ; a = gene1 . toCharArray ( ) ; b = gene2 . toCharArray ( ) ; s = score ( a , b , 0 , 0 ) ; return ( s ) ; }"
1096,"void main ( String [ ] args ) { String str = ""abcdabghplhhnfl"" . toLowerCase ( ) ; Integer [ ] ar = new Integer [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = str . charAt ( i ) - 'a' ; if ( ar [ j ] == null ) { ar [ j ] = 1 ; } else { ar [ j ] += 1 ; } } for ( int i = 0 ; i < ar . length ; i ++ ) { if ( ar [ i ] != null && ar [ i ] > 1 ) { char c = ( char ) ( 97 + i ) ; System . out . println ( ""'"" + c + ""' comes "" + ar [ i ] + "" times."" ) ; } } }"
1097,"void main ( String [ ] args ) { String name = ""AnuvratAnuvra"" ; char [ ] arr = name . toCharArray ( ) ; HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char val : arr ) { map . put ( val , map . containsKey ( val ) ? map . get ( val ) + 1 : 1 ) ; } for ( Entry < Character , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { Character key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; System . out . println ( key + "":"" + value ) ; } } }"
1098,String removeAdjacentDuplicates ( String s ) { StringBuilder resultBuilder = new StringBuilder ( ) ; char previous = s . charAt ( 0 ) ; resultBuilder . append ( previous ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { char current = s . charAt ( i ) ; if ( previous != current ) { resultBuilder . append ( current ) ; previous = current ; } } return resultBuilder . toString ( ) ; }
1099,"String removeAdjacentDuplicates ( String input ) { if ( input . length ( ) <= 1 ) { return input ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( input . charAt ( 0 ) ) ; IntStream . range ( 1 , input . length ( ) ) . mapToObj ( i -> input . charAt ( i ) != input . charAt ( i - 1 ) ? input . charAt ( i ) : """" ) . forEach ( sb :: append ) ; return sb . toString ( ) ; }"
1100,"int findCombinationsCount ( int sum , int vals [ ] ) { if ( sum < 0 ) { return 0 ; } if ( vals == null || vals . length == 0 ) { return 0 ; } int dp [ ] = new int [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < vals . length ; ++ i ) { for ( int j = vals [ i ] ; j <= sum ; ++ j ) { dp [ j ] += dp [ j - vals [ i ] ] ; } } return dp [ sum ] ; }"
1101,"int findCombinationsCount ( int amount , int coins [ ] ) { if ( coins . length == 1 ) { return amount % coins [ 0 ] == 0 ? 1 : 0 ; } else { int total = 0 ; int [ ] subCoins = arrayOfCoinsExceptTheFirstOne ( coins ) ; for ( int i = 0 ; i * coins [ 0 ] <= amount ; ++ i ) { total += findCombinationsCount ( amount - i * coins [ 0 ] , subCoins ) ; } return total ; } }"
1102,int [ ] removeDuplicates ( int [ ] arr ) { HashSet < Integer > set = new HashSet < > ( ) ; final int len = arr . length ; for ( int i = 0 ; i < len ; i ++ ) { set . add ( arr [ i ] ) ; } int [ ] whitelist = new int [ set . size ( ) ] ; int i = 0 ; for ( Iterator < Integer > it = set . iterator ( ) ; it . hasNext ( ) ; ) { whitelist [ i ++ ] = it . next ( ) ; } return whitelist ; }
1103,"int [ ] removeDuplicates ( int [ ] arr ) { int end = arr . length ; for ( int i = 0 ; i < end ; i ++ ) { for ( int j = i + 1 ; j < end ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { arr [ j ] = arr [ end - 1 ] ; end -- ; j -- ; } } } int [ ] whitelist = new int [ end ] ; System . arraycopy ( arr , 0 , whitelist , 0 , end ) ; return whitelist ; }"
1104,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String lsStart = """" ; String lsInsert = """" ; String lsEnd = """" ; String lsText = """" ; Log . d ( ""debug"" , moPattern . toString ( ) ) ; Log . d ( ""debug"" , ""source: "" + source + "", start: "" + start + "", end:"" + end + "", dest: "" + dest + "", dstart: "" + dstart + "", dend: "" + dend ) ; lsText = dest . toString ( ) ; if ( lsText . length ( ) > 0 ) { lsStart = lsText . substring ( 0 , dstart ) ; Log . d ( ""debug"" , ""lsStart : "" + lsStart ) ; if ( source != """" ) { lsInsert = source . toString ( ) ; Log . d ( ""debug"" , ""lsInsert: "" + lsInsert ) ; } lsEnd = lsText . substring ( dend ) ; Log . d ( ""debug"" , ""lsEnd   : "" + lsEnd ) ; lsText = lsStart + lsInsert + lsEnd ; Log . d ( ""debug"" , ""lsText  : "" + lsText ) ; } Matcher loMatcher = moPattern . matcher ( lsText ) ; Log . d ( ""debug"" , ""loMatcher.matches(): "" + loMatcher . matches ( ) + "", lsText: "" + lsText ) ; if ( ! loMatcher . matches ( ) ) { return """" ; } return null ; }"
1105,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { int dotPos = - 1 ; int len = dest . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = dest . charAt ( i ) ; if ( c == '.' || c == ',' ) { dotPos = i ; break ; } } if ( dotPos >= 0 ) { if ( source . equals ( ""."" ) || source . equals ( "","" ) ) { return """" ; } if ( dend <= dotPos ) { return null ; } if ( len - dotPos > decimalDigits ) { return """" ; } } return null ; }"
1106,"void main ( String [ ] args ) { String str = ""abcdabghplhhnfl"" . toLowerCase ( ) ; Integer [ ] ar = new Integer [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = str . charAt ( i ) - 'a' ; if ( ar [ j ] == null ) { ar [ j ] = 1 ; } else { ar [ j ] += 1 ; } } for ( int i = 0 ; i < ar . length ; i ++ ) { if ( ar [ i ] != null && ar [ i ] > 1 ) { char c = ( char ) ( 97 + i ) ; System . out . println ( ""'"" + c + ""' comes "" + ar [ i ] + "" times."" ) ; } } }"
1107,"void main ( String [ ] args ) { String test = ""The quick brown fox jumped over the lazy dog."" ; int countA = 0 , countO = 0 , countSpace = 0 , countDot = 0 ; for ( int i = 0 ; i < test . length ( ) ; i ++ ) { switch ( test . charAt ( i ) ) { case 'a' : case 'A' : countA ++ ; break ; case 'o' : case 'O' : countO ++ ; break ; case ' ' : countSpace ++ ; break ; case '.' : countDot ++ ; break ; } } System . out . printf ( ""%s%d%n%s%d%n%s%d%n%s%d"" , ""A: "" , countA , ""O: "" , countO , ""Space: "" , countSpace , ""Dot: "" , countDot ) ; }"
1108,int solution ( int [ ] A ) { final Set perm = new HashSet ( ) ; final int size = A . length ; for ( int number : A ) { if ( number > size ) return 0 ; perm . add ( number ) ; } if ( perm . size ( ) == A . length ) return 1 ; else return 0 ; }
1109,int solution ( int [ ] A ) { int [ ] mark = new int [ A . length + 1 ] ; int counter = 0 ; for ( int i = 0 ; i < A . length ; ++ i ) { int value = A [ i ] ; if ( value >= mark . length ) { return NOT_PERMUTATION ; } if ( mark [ value ] == 0 ) { mark [ value ] = 1 ; ++ counter ; } else { return NOT_PERMUTATION ; } } return counter == A . length ? PERMUTATION : NOT_PERMUTATION ; }
1110,"void dispatchEvent ( Event event ) { checkNotNull ( event ) ; CancellableEvent cancellableEvent = null ; boolean cancellable ; if ( cancellable = event instanceof CancellableEvent ) { cancellableEvent = ( CancellableEvent ) event ; checkArgument ( cancellableEvent . isCancelled ( ) ) ; } for ( EventPriority priority : EventPriority . values ( ) ) { Map < Method , EventListener > internalMapping = getRegistry ( ) . getMethodMap ( event . getClass ( ) , priority , true ) ; if ( internalMapping != null ) { for ( Entry < Method , EventListener > entry : internalMapping . entrySet ( ) ) { invokeEntry ( entry , event ) ; } } } for ( EventPriority priority : EventPriority . values ( ) ) { Map < Method , EventListener > internalMapping = getRegistry ( ) . getMethodMap ( event . getClass ( ) , priority , false ) ; if ( internalMapping != null ) { for ( Entry < Method , EventListener > entry : internalMapping . entrySet ( ) ) { invokeEntry ( entry , event ) ; if ( cancellable && cancellableEvent . isCancelled ( ) ) { return ; } } } } }"
1111,"void dispatchEvent ( Event event ) { checkNotNull ( event ) ; CancellableEvent cancellableEvent = null ; boolean cancellable ; if ( cancellable = event instanceof CancellableEvent ) { cancellableEvent = ( CancellableEvent ) event ; checkArgument ( cancellableEvent . isCancelled ( ) ) ; } fireEvents ( false , event , cancellableEvent , cancellable ) ; fireEvents ( true , event , cancellableEvent , cancellable ) ; }"
1112,"void start ( final Stage primaryStage ) { Group rootGroup = new Group ( ) ; Label label = new Label ( ""Demo Text"" ) ; try { final Font f = Font . loadFont ( new FileInputStream ( new File ( ""./myFonts/TRON.TTF"" ) ) , 12 ) ; label . setFont ( f ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } rootGroup . getChildren ( ) . add ( label ) ; Scene scene = new Scene ( rootGroup , 640 , 480 , Color . WHITE ) ; primaryStage . setScene ( scene ) ; primaryStage . show ( ) ; }"
1113,"void start ( Stage stage ) { stage . setTitle ( ""TRON Synopsis"" ) ; Font . loadFont ( CustomFontApp . class . getResource ( ""TRON.TTF"" ) . toExternalForm ( ) , 10 ) ; Label title = new Label ( ""TRON"" ) ; title . getStyleClass ( ) . add ( ""title"" ) ; Label caption = new Label ( ""A sci-fi flick set in an alternate reality."" ) ; caption . getStyleClass ( ) . add ( ""caption"" ) ; caption . setMaxWidth ( 220 ) ; caption . setWrapText ( true ) ; caption . setTextAlignment ( TextAlignment . CENTER ) ; VBox layout = new VBox ( 10 ) ; layout . setStyle ( ""-fx-padding: 20px; -fx-background-color: silver"" ) ; layout . setAlignment ( Pos . CENTER ) ; layout . getChildren ( ) . setAll ( title , new ImageView ( new Image ( ""http://ia.media-imdb.com/images/M/MV5BMTY5NjM2MjAwOV5BMl5BanBnXkFtZTYwMTgyMzA5.V1.SY317.jpg"" ) ) , caption ) ; final Scene scene = new Scene ( layout ) ; scene . getStylesheets ( ) . add ( getClass ( ) . getResource ( ""custom-font-styles.css"" ) . toExternalForm ( ) ) ; stage . setScene ( scene ) ; stage . show ( ) ; }"
1114,"void paintComponent ( Graphics g ) { int width = this . getWidth ( ) ; int height = this . getHeight ( ) ; if ( activeRedraw ) { if ( repaintBuffer1 ) { Graphics g1 = buffer1 . getGraphics ( ) ; g1 . clearRect ( 0 , 0 , width , height ) ; g1 . setColor ( Color . green ) ; g1 . drawRect ( 0 , 0 , width - 1 , height - 1 ) ; g . drawImage ( buffer1 , 0 , 0 , null ) ; repaintBuffer1 = false ; } double time = 2 * Math . PI * ( System . currentTimeMillis ( ) % 5000 ) / 5000. ; g . setColor ( Color . RED ) ; if ( rect != null ) { g . drawImage ( buffer1 , rect . x , rect . y , rect . x + rect . width , rect . y + rect . height , rect . x , rect . y , rect . x + rect . width , rect . y + rect . height , this ) ; } rect = new Rectangle ( ( int ) ( Math . sin ( time ) * width / 3 + width / 2 - 20 ) , ( int ) ( Math . cos ( time ) * height / 3 + height / 2 ) - 20 , 40 , 40 ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; activeRedraw = false ; } }"
1115,"void paintComponent ( Graphics g ) { long start = System . nanoTime ( ) ; super . paintComponent ( g ) ; int w = this . getWidth ( ) ; int h = this . getHeight ( ) ; g . drawImage ( background , 0 , 0 , this ) ; double theta = 2 * Math . PI * index ++ / 64 ; g . setColor ( Color . blue ) ; rect . setRect ( ( int ) ( Math . sin ( theta ) * w / 3 + w / 2 - RADIUS ) , ( int ) ( Math . cos ( theta ) * h / 3 + h / 2 - RADIUS ) , 2 * RADIUS , 2 * RADIUS ) ; g . fillOval ( rect . x , rect . y , rect . width , rect . height ) ; g . setColor ( Color . white ) ; if ( frameCount == FRAMES ) { averageTime = totalTime / FRAMES ; totalTime = 0 ; frameCount = 0 ; } else { totalTime += System . nanoTime ( ) - start ; frameCount ++ ; } String s = String . format ( ""%1$5.3f"" , averageTime / 1000000d ) ; g . drawString ( s , 5 , 16 ) ; }"
1116,"int binarySearch ( int [ ] a , int x , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( a [ mid ] == x ) return mid ; else if ( a [ mid ] < x ) return binarySearch ( a , x , mid + 1 , high ) ; else return binarySearch ( a , x , low , mid - 1 ) ; }"
1117,"int binarySearch ( int intToSearch , int [ ] sortedArray ) { int lower = 0 ; int upper = sortedArray . length - 1 ; while ( lower <= upper ) { int mid = lower + ( upper - lower ) / 2 ; if ( intToSearch < sortedArray [ mid ] ) upper = mid - 1 ; else if ( intToSearch > sortedArray [ mid ] ) lower = mid + 1 ; else return mid ; } return - 1 ; }"
1118,"void main ( String [ ] args ) { String [ ] list1 = { ""a"" , ""b"" , ""c"" , } ; TimeUnit [ ] list2 = TimeUnit . values ( ) ; int [ ] list3 = new int [ ] { 1 , 2 , 3 , 4 } ; int [ ] lengths = new int [ ] { list1 . length , list2 . length , list3 . length } ; for ( int [ ] indices : new CartesianProduct ( lengths ) ) { System . out . println ( Arrays . toString ( indices ) + "" "" + list1 [ indices [ 0 ] ] + "", "" + list2 [ indices [ 1 ] ] + "", "" + list3 [ indices [ 2 ] ] ) ; } }"
1119,"void main ( String [ ] args ) { List < Object > lc = Arrays . asList ( new Object [ ] { 'A' , 'B' , 'C' , 'D' } ) ; List < Object > lC = Arrays . asList ( new Object [ ] { 'a' , 'b' , 'c' } ) ; List < Object > li = Arrays . asList ( new Object [ ] { 1 , 2 , 3 , 4 } ) ; List < List < Object > > llo = new ArrayList < List < Object > > ( ) ; llo . add ( lc ) ; llo . add ( lC ) ; llo . add ( li ) ; CartesianIterable < Object > ci = new CartesianIterable < Object > ( llo ) ; for ( List < Object > lo : ci ) show ( lo ) ; }"
1120,"void main ( String args [ ] ) { int [ ] arr = new int [ 10 ] ; Scanner in = new Scanner ( System . in ) ; int i , min = 0 , max = 0 ; for ( i = 0 ; i <= arr . length ; i ++ ) { System . out . print ( ""Enter any number: "" ) ; arr [ i ] = in . nextInt ( ) ; } min = arr [ 0 ] ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; } if ( arr [ i ] < min ) { min = arr [ i ] ; } } System . out . println ( ""Maximum is: "" + max ) ; System . out . println ( ""Minimum is: "" + min ) ; }"
1121,"void main ( String [ ] args ) { System . out . println ( ""Main Method Started"" ) ; Scanner in = new Scanner ( System . in ) ; System . out . println ( ""Enter the size of the arr"" ) ; int size = in . nextInt ( ) ; System . out . println ( ""Enter the maximum value of the arr"" ) ; int max = in . nextInt ( ) ; int [ ] arr = initializeArr ( max , size ) ; print ( arr ) ; findMinMax ( arr ) ; System . out . println ( ""Main Method Ended"" ) ; }"
1122,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
1123,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
1124,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( value . isEmpty ( ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! tensName . isEmpty ( ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1125,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
1126,"void draw ( Graphics2D g , int width , int height ) { g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( Color . WHITE ) ; g . fillRect ( 0 , 0 , width , height ) ; for ( Arrow arrow : arrows ) { g . setColor ( Color . ORANGE ) ; g . fillRect ( 350 , 20 , 20 , 280 ) ; g . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_BEVEL ) ) ; g . translate ( 0 , 60 ) ; arrow . draw ( g ) ; g . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER ) ) ; g . translate ( 0 , 100 ) ; arrow . draw ( g ) ; g . setStroke ( new BasicStroke ( 20.0f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_ROUND ) ) ; g . translate ( 0 , 100 ) ; arrow . draw ( g ) ; g . translate ( 400 , - 260 ) ; } }"
1127,"void draw ( Graphics2D g ) { float arrowRatio = 0.5f ; float arrowLength = 80.0f ; BasicStroke stroke = ( BasicStroke ) g . getStroke ( ) ; float endX = 350.0f ; float veeX = endX - stroke . getLineWidth ( ) * 0.5f / arrowRatio ; Path2D . Float path = new Path2D . Float ( ) ; float waisting = 0.5f ; float waistX = endX - arrowLength * 0.5f ; float waistY = arrowRatio * arrowLength * 0.5f * waisting ; float arrowWidth = arrowRatio * arrowLength ; path . moveTo ( veeX - arrowLength , - arrowWidth ) ; path . quadTo ( waistX , - waistY , endX , 0.0f ) ; path . quadTo ( waistX , waistY , veeX - arrowLength , arrowWidth ) ; path . lineTo ( veeX - arrowLength * 0.75f , 0.0f ) ; path . lineTo ( veeX - arrowLength , - arrowWidth ) ; g . setColor ( Color . BLUE ) ; g . fill ( path ) ; g . setColor ( Color . RED ) ; g . draw ( new Line2D . Float ( 50.0f , 0.0f , veeX - arrowLength * 0.5f , 0.0f ) ) ; }"
1128,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
1129,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
1130,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
1131,"void run ( ) { int i = 2 ; while ( i < 50 ) { while ( s . getState ( ) != 1 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 1 ) System . out . println ( ""t2 "" + i ) ; s . setState ( 2 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
1132,"void contextDestroyed ( ServletContextEvent servletContextEvent ) { if ( this . driver != null ) { try { DriverManager . deregisterDriver ( driver ) ; LOG . info ( String . format ( ""deregistering jdbc driver: %s"" , driver ) ) ; } catch ( SQLException e ) { LOG . warn ( String . format ( ""Error deregistering driver %s"" , driver ) , e ) ; } this . driver = null ; } else { LOG . warn ( ""No driver to deregister"" ) ; } }"
1133,"void contextDestroyed ( ServletContextEvent sce ) { Context initContext = new InitialContext ( ) ; Context envContext = ( Context ) initContext . lookup ( ""java:/comp/env"" ) ; DataSource datasource = ( DataSource ) envContext . lookup ( ""jdbc/database"" ) ; try { java . sql . Driver mySqlDriver = DriverManager . getDriver ( ""jdbc:mysql://localhost:3306/"" ) ; DriverManager . deregisterDriver ( mySqlDriver ) ; } catch ( SQLException ex ) { logger . info ( ""Could not deregister driver:"" . concat ( ex . getMessage ( ) ) ) ; } dataSource = null ; }"
1134,"void countString ( String str , char value ) { String [ ] arr = str . split ( """" ) ; StringBuffer tempString = new StringBuffer ( ) ; for ( String s : arr ) { tempString . append ( s ) ; for ( char ch : s . toCharArray ( ) ) { System . out . println ( ""Number of Occurrence of "" + ch + "" is:"" + tempString . chars ( ) . filter ( i -> i == ch ) . count ( ) ) ; } } if ( ! ( Character . toString ( value ) . isEmpty ( ) ) ) { StringBuffer tempString2 = new StringBuffer ( ) ; for ( String s : arr ) { tempString2 . append ( s ) ; for ( char ch : s . toCharArray ( ) ) { if ( ch == value ) { System . out . println ( ""Number of Occurrence of "" + ch + "" is:"" + tempString2 . chars ( ) . filter ( i -> i == ch ) . count ( ) ) ; } } } } }"
1135,"void countString ( String str , char searchKey ) { String count = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == searchKey ) count += str . charAt ( i ) + ""\n"" ; } System . out . println ( count + ""\nNumber of Occurrence of "" + searchKey + "" is "" + count . length ( ) + "" in string "" + str ) ; }"
1136,"V get ( K1 key1 , K2 key2 ) { if ( ! mapOfMap . containsKey ( key1 ) ) { key1 = null ; } if ( ! mapOfMap . get ( key1 ) . containsKey ( key2 ) ) { key2 = null ; } return mapOfMap . get ( key1 ) . get ( key2 ) ; }"
1137,"V get ( K ... keys ) { if ( keys == null ) { return value ; } if ( expectedNumberOfKeys == - 1 ) { return null ; } if ( expectedNumberOfKeys == 0 ) { return value ; } if ( expectedNumberOfKeys != keys . length ) { throw new IllegalArgumentException ( ""Expecting "" + expectedNumberOfKeys + "" keys.  Was "" + keys . length ) ; } Map < K , Map > currentMap = topMap ; for ( int i = 0 ; i < keys . length - 1 ; i ++ ) { currentMap = ( Map ) getDefault ( currentMap , keys [ i ] ) ; } V result = ( V ) getDefault ( currentMap , keys [ keys . length - 1 ] ) ; return result ; }"
1138,"void type ( String characters ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection stringSelection = new StringSelection ( characters ) ; clipboard . setContents ( stringSelection , clipboardOwner ) ; robot . keyPress ( KeyEvent . VK_CONTROL ) ; robot . keyPress ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_CONTROL ) ; }"
1139,void type ( char character ) { handleSpecialCharacter ( character ) ; if ( Character . isLowerCase ( character ) ) { typeCharacter ( Character . toUpperCase ( character ) ) ; } if ( Character . isUpperCase ( character ) ) { typeShiftCharacter ( character ) ; } if ( Character . isDigit ( character ) ) { typeCharacter ( character ) ; } }
1140,"void main ( String [ ] args ) throws InterruptedException { while ( makeMore ) { new Leakee ( 0 ) . check ( ) ; } while ( true ) { Thread . sleep ( 1000 ) ; System . out . println ( ""memory="" + Runtime . getRuntime ( ) . freeMemory ( ) + "" / "" + Runtime . getRuntime ( ) . totalMemory ( ) ) ; } }"
1141,"void main ( String [ ] args ) throws IOException { ZipOutputStream zos = new ZipOutputStream ( new FileOutputStream ( new File ( ""big.jar"" ) ) ) ; zos . putNextEntry ( new ZipEntry ( ""resource.txt"" ) ) ; zos . write ( ""not too much in here"" . getBytes ( ) ) ; zos . closeEntry ( ) ; zos . putNextEntry ( new ZipEntry ( ""largeFile.out"" ) ) ; for ( int i = 0 ; i < 10000000 ; i ++ ) { zos . write ( ( int ) ( Math . round ( Math . random ( ) * 100 ) + 20 ) ) ; } zos . closeEntry ( ) ; zos . close ( ) ; }"
1142,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
1143,"int solution ( int X , int [ ] A ) { Set < Integer > leaves = new HashSet < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { leaves . add ( A [ i ] ) ; if ( leaves . contains ( X ) && leaves . size ( ) == X ) return i ; } return - 1 ; }"
1144,"void main ( String [ ] args ) throws InterruptedException { CountDownLatch theLatch = new CountDownLatch ( 100 ) ; List < String > output = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; SecureRandom random = new SecureRandom ( ) ; ExecutorService service = Executors . newCachedThreadPool ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { service . execute ( new CountDownTask ( theLatch , output , random ) ) ; } theLatch . await ( 1 , TimeUnit . MINUTES ) ; service . shutdown ( ) ; System . out . println ( output . size ( ) ) ; }"
1145,"void main ( String [ ] args ) throws InterruptedException { BlockingQueue < Object > expensiveObjects = new LinkedBlockingQueue < > ( ) ; expensiveObjects . put ( new Object ( ) ) ; expensiveObjects . put ( new Object ( ) ) ; expensiveObjects . put ( new Object ( ) ) ; expensiveObjects . put ( new Object ( ) ) ; ExecutorService executorService = Executors . newFixedThreadPool ( 4 ) ; for ( int i = 0 ; i < 4 ; i ++ ) { executorService . execute ( new MyRunnable ( expensiveObjects ) ) ; } executorService . shutdown ( ) ; executorService . awaitTermination ( 5 , TimeUnit . SECONDS ) ; System . out . println ( ""Final: "" + outputCount . get ( ) ) ; }"
1146,"void main ( String [ ] args ) throws TwilioRestException { TwilioRestClient client = new TwilioRestClient ( ACCOUNT_SID , AUTH_TOKEN ) ; List < NameValuePair > params = new ArrayList < NameValuePair > ( ) ; params . add ( new BasicNameValuePair ( ""Body"" , ""Test Twilio message"" ) ) ; params . add ( new BasicNameValuePair ( ""To"" , ""+14159352345"" ) ) ; params . add ( new BasicNameValuePair ( ""From"" , ""+14158141829"" ) ) ; MessageFactory messageFactory = client . getAccount ( ) . getMessageFactory ( ) ; Message message = messageFactory . create ( params ) ; System . out . println ( message . getSid ( ) ) ; }"
1147,"void main ( String [ ] args ) throws Exception { AuthMethod auth = new TokenAuthMethod ( API_KEY , API_SECRET ) ; NexmoClient client = new NexmoClient ( auth ) ; TextMessage message = new TextMessage ( FROM_NUMBER , TO_NUMBER , ""Hello from Nexmo!"" ) ; SmsSubmissionResult [ ] responses = client . getSmsClient ( ) . submitMessage ( message ) ; for ( SmsSubmissionResult response : responses ) { System . out . println ( response ) ; } }"
1148,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( value . isEmpty ( ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! tensName . isEmpty ( ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1149,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
1150,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1151,"void transform ( HSSFRow rowOld , XSSFRow rowNew ) { XSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; if ( rowOld . getRowStyle ( ) != null ) { Integer hash = rowOld . getRowStyle ( ) . hashCode ( ) ; if ( ! this . styleMap . containsKey ( hash ) ) this . transform ( hash , rowOld . getRowStyle ( ) , this . workbookNew . createCellStyle ( ) ) ; rowNew . setRowStyle ( this . styleMap . get ( hash ) ) ; } for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( ( HSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1152,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] answer = new int [ P . length ] ; char [ ] chars = S . toCharArray ( ) ; int [ ] [ ] cumulativeAnswers = new int [ 4 ] [ chars . length + 1 ] ; for ( int iii = 0 ; iii < chars . length ; iii ++ ) { if ( iii > 0 ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { cumulativeAnswers [ zzz ] [ iii + 1 ] = cumulativeAnswers [ zzz ] [ iii ] ; } } switch ( chars [ iii ] ) { case 'A' : cumulativeAnswers [ 0 ] [ iii + 1 ] ++ ; break ; case 'C' : cumulativeAnswers [ 1 ] [ iii + 1 ] ++ ; break ; case 'G' : cumulativeAnswers [ 2 ] [ iii + 1 ] ++ ; break ; case 'T' : cumulativeAnswers [ 3 ] [ iii + 1 ] ++ ; break ; } } for ( int iii = 0 ; iii < P . length ; iii ++ ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { if ( ( cumulativeAnswers [ zzz ] [ Q [ iii ] + 1 ] - cumulativeAnswers [ zzz ] [ P [ iii ] ] ) > 0 ) { answer [ iii ] = zzz + 1 ; break ; } } } return answer ; }"
1153,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int N = S . length ( ) ; int M = P . length ; int [ ] result = new int [ M ] ; lastOccurrencesMap = new int [ 3 ] [ N ] ; int lastA = - 1 ; int lastC = - 1 ; int lastG = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { char c = S . charAt ( i ) ; if ( c == 'A' ) { lastA = i ; } else if ( c == 'C' ) { lastC = i ; } else if ( c == 'G' ) { lastG = i ; } lastOccurrencesMap [ 0 ] [ i ] = lastA ; lastOccurrencesMap [ 1 ] [ i ] = lastC ; lastOccurrencesMap [ 2 ] [ i ] = lastG ; } for ( int i = 0 ; i < M ; i ++ ) { int startIndex = P [ i ] ; int endIndex = Q [ i ] ; int minimum = 4 ; for ( int n = 0 ; n < 3 ; n ++ ) { int lastOccurence = getLastNucleotideOccurrence ( startIndex , endIndex , n ) ; if ( lastOccurence != 0 ) { minimum = n + 1 ; break ; } } result [ i ] = minimum ; } return result ; }"
1154,"void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode == RESULT_OK ) { switch ( requestCode ) { case SELECT_IMAGE : String imagePath = getPath ( data . getData ( ) ) ; Savingimagepath ( imagePath ) ; img . setImageDrawable ( Drawable . createFromPath ( imagePath ) ) ; break ; } } }"
1155,"void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( requestCode == IMAGE_CAPTURE && resultCode == Activity . RESULT_OK ) { DBHelper dbHelper = new DBHelper ( this ) ; SQLiteDatabase sql = dbHelper . getWritableDatabase ( ) ; sql . execSQL ( ""insert statement for inserting path to database"" ) ; sql . close ( ) ; dbHelper . close ( ) ; } }"
1156,"String readFileAsString ( String filePath ) throws IOException { StringBuffer fileData = new StringBuffer ( ) ; BufferedReader reader = new BufferedReader ( new FileReader ( filePath ) ) ; char [ ] buf = new char [ 1024 ] ; int numRead = 0 ; while ( ( numRead = reader . read ( buf ) ) != - 1 ) { String readData = String . valueOf ( buf , 0 , numRead ) ; fileData . append ( readData ) ; } reader . close ( ) ; return fileData . toString ( ) ; }"
1157,"String readFileAsString ( String fileName , String charsetName ) throws java . io . IOException { java . io . InputStream is = new java . io . FileInputStream ( fileName ) ; try { final int bufsize = 4096 ; int available = is . available ( ) ; byte [ ] data = new byte [ available < bufsize ? bufsize : available ] ; int used = 0 ; while ( true ) { if ( data . length - used < bufsize ) { byte [ ] newData = new byte [ data . length << 1 ] ; System . arraycopy ( data , 0 , newData , 0 , used ) ; data = newData ; } int got = is . read ( data , used , data . length - used ) ; if ( got <= 0 ) break ; used += got ; } return charsetName != null ? new String ( data , 0 , used , charsetName ) : new String ( data , 0 , used ) ; } finally { is . close ( ) ; } }"
1158,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
1159,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
1160,"boolean contains ( String a , String b ) { String temp = b ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { temp = temp . replaceFirst ( Pattern . quote ( a . substring ( i , i + 1 ) ) , """" ) ; if ( b . length ( ) - temp . length ( ) != i + 1 ) return false ; } return true ; }"
1161,"boolean contains ( String a , String b ) { boolean status = true ; Map < String , Integer > mapA = new HashMap < > ( ) ; Map < String , Integer > mapB = new HashMap < > ( ) ; for ( char i : a . toCharArray ( ) ) { Integer val = mapA . get ( """" + i ) ; if ( val != null ) { mapA . put ( """" + i , val + 1 ) ; } else { mapA . put ( """" + i , 1 ) ; } } for ( char i : b . toCharArray ( ) ) { Integer val = mapB . get ( """" + i ) ; if ( val != null ) { mapB . put ( """" + i , val + 1 ) ; } else { mapB . put ( """" + i , 1 ) ; } } for ( Map . Entry < String , Integer > entry : mapA . entrySet ( ) ) { if ( mapB . get ( entry . getKey ( ) ) == null || entry . getValue ( ) > mapB . get ( entry . getKey ( ) ) ) { status = false ; } } return status ; }"
1162,"boolean isBalanced ( String strExpression ) { Map < Character , Character > bracketPair = new HashMap < Character , Character > ( ) ; bracketPair . put ( '(' , ')' ) ; bracketPair . put ( '[' , ']' ) ; bracketPair . put ( '{' , '}' ) ; Stack < Character > stk = new Stack < Character > ( ) ; for ( int i = 0 ; i < strExpression . length ( ) ; i ++ ) { if ( bracketPair . containsKey ( strExpression . charAt ( i ) ) ) stk . push ( strExpression . charAt ( i ) ) ; else if ( bracketPair . containsValue ( strExpression . charAt ( i ) ) ) if ( stk . isEmpty ( ) || bracketPair . get ( stk . pop ( ) ) != strExpression . charAt ( i ) ) return false ; } if ( stk . isEmpty ( ) ) return true ; else return false ; }"
1163,boolean isBalanced ( String str ) { boolean result = false ; if ( str . length ( ) < 2 ) return false ; Stack < Character > stack = new Stack < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ! parenthesesMapRight . containsKey ( ch ) && ! parenthesesMapLeft . containsKey ( ch ) ) { continue ; } if ( parenthesesMapLeft . containsKey ( ch ) ) { stack . push ( ch ) ; } else { if ( ! stack . isEmpty ( ) && stack . pop ( ) == parenthesesMapRight . get ( ch ) . charValue ( ) ) { result = true ; } else { return false ; } } } if ( ! stack . isEmpty ( ) ) return result = false ; return result ; }
1164,"void invoke ( Request request , Response response ) throws IOException , ServletException { getNext ( ) . invoke ( request , response ) ; Session session = null ; try { session = request . getSessionInternal ( ) ; } catch ( Throwable e ) { log . error ( getInfo ( ) + "": Unable to perform replication request."" , e ) ; } String context = request . getContext ( ) . getName ( ) ; String task = request . getPathInfo ( ) ; if ( task == null ) { task = request . getRequestURI ( ) ; } if ( session != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( getInfo ( ) + "": [session="" + session . getId ( ) + "", instanceof="" + session . getClass ( ) . getName ( ) + "", context="" + context + "", request="" + task + ""]"" ) ; } List < String > cycledNames = new LinkedList < String > ( ) ; HttpSession deltaSession = ( HttpSession ) session ; for ( Enumeration < String > names = deltaSession . getAttributeNames ( ) ; names . hasMoreElements ( ) ; ) { String name = names . nextElement ( ) ; deltaSession . setAttribute ( name , deltaSession . getAttribute ( name ) ) ; cycledNames . add ( name ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( getInfo ( ) + "": [session="" + session . getId ( ) + "", context="" + context + "", request="" + task + ""] cycled atrributes="" + cycledNames + """" ) ; } } else { String id = request . getRequestedSessionId ( ) ; log . warn ( getInfo ( ) + "": [session="" + id + "", context="" + context + "", request="" + task + ""] Session not available, unable to send session over cluster."" ) ; } }"
1165,"void invoke ( Request request , Response response ) throws IOException , ServletException { getNext ( ) . invoke ( request , response ) ; Session session = null ; try { session = request . getSessionInternal ( ) ; } catch ( Throwable e ) { log . error ( getInfo ( ) + "": Unable to perform replication request."" , e ) ; } String context = request . getContext ( ) . getName ( ) ; String task = request . getPathInfo ( ) ; if ( task == null ) { task = request . getRequestURI ( ) ; } if ( session != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( getInfo ( ) + "": [session="" + session . getId ( ) + "", instanceof="" + session . getClass ( ) . getName ( ) + "", context="" + context + "", request="" + task + ""]"" ) ; } if ( session instanceof ReplicatedSession ) { ( ( ReplicatedSession ) session ) . setIsDirty ( true ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( getInfo ( ) + "": [session="" + session . getId ( ) + "", context="" + context + "", request="" + task + ""] maked DIRTY"" ) ; } } else { List cycledNames = new LinkedList ( ) ; HttpSession deltaSession = ( HttpSession ) session ; for ( Enumeration < String > names = deltaSession . getAttributeNames ( ) ; names . hasMoreElements ( ) ; ) { String name = names . nextElement ( ) ; deltaSession . setAttribute ( name , deltaSession . getAttribute ( name ) ) ; cycledNames . add ( name ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( getInfo ( ) + "": [session="" + session . getId ( ) + "", context="" + context + "", request="" + task + ""] cycled atrributes="" + cycledNames + """" ) ; } } } else { String id = request . getRequestedSessionId ( ) ; log . warn ( getInfo ( ) + "": [session="" + id + "", context="" + context + "", request="" + task + ""] Session not available, unable to send session over cluster."" ) ; } }"
1166,"boolean isPermutation ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int checker = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { checker ^= s1 . charAt ( i ) ^ s2 . charAt ( i ) ; } return checker == 0 ; }"
1167,"boolean isPermutation ( String str1 , String str2 ) { char [ ] x = str1 . toCharArray ( ) ; char [ ] y = str2 . toCharArray ( ) ; Arrays . sort ( x ) ; Arrays . sort ( y ) ; if ( Arrays . equals ( x , y ) ) return true ; return false ; }"
1168,void shuffle ( T [ ] ar ) { for ( int i = ar . length - 1 ; i > 0 ; i -- ) { int index = rnd . nextInt ( i + 1 ) ; T a = ar [ index ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } }
1169,void shuffle ( Object [ ] a ) { int n = a . length ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( int ) ( Math . random ( ) * ( n - i ) ) ; Object swap = a [ r ] ; a [ r ] = a [ i ] ; a [ i ] = swap ; } }
1170,"boolean isExpectedPassword ( char [ ] password , byte [ ] salt , byte [ ] expectedHash ) { byte [ ] pwdHash = hash ( password , salt ) ; Arrays . fill ( password , Character . MIN_VALUE ) ; if ( pwdHash . length != expectedHash . length ) return false ; for ( int i = 0 ; i < pwdHash . length ; i ++ ) { if ( pwdHash [ i ] != expectedHash [ i ] ) return false ; } return true ; }"
1171,"boolean isExpectedPassword ( final String password , final byte [ ] salt , final byte [ ] hash ) { Validate . notNull ( password , ""Password must not be null"" ) ; Validate . notNull ( salt , ""Salt must not be null"" ) ; Validate . notNull ( hash , ""Hash must not be null"" ) ; try { final byte [ ] passwordBytes = password . getBytes ( ""UTF-8"" ) ; final byte [ ] all = ArrayUtils . addAll ( passwordBytes , salt ) ; SHA3 . DigestSHA3 md = new SHA3 . Digest512 ( ) ; md . update ( all ) ; final byte [ ] digest = md . digest ( ) ; return Arrays . equals ( digest , hash ) ; } catch ( UnsupportedEncodingException e ) { final String message = String . format ( ""Caught UnsupportedEncodingException e: <%s>"" , e . getMessage ( ) ) ; LOGGER . error ( message ) ; } return false ; }"
1172,"Command deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { try { JsonObject commandObject = json . getAsJsonObject ( ) ; JsonElement commandTypeElement = commandObject . get ( commandElementName ) ; Class < ? extends Command > commandInstanceClass = commandRegistry . get ( commandTypeElement . getAsString ( ) ) ; Command command = gson . fromJson ( json , commandInstanceClass ) ; return command ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }"
1173,"IAnimal deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { JsonObject jsonObject = json . getAsJsonObject ( ) ; JsonPrimitive prim = ( JsonPrimitive ) jsonObject . get ( CLASSNAME ) ; String className = prim . getAsString ( ) ; Class < ? > klass = null ; try { klass = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; throw new JsonParseException ( e . getMessage ( ) ) ; } return context . deserialize ( jsonObject . get ( INSTANCE ) , klass ) ; }"
1174,"void expandAllNodes ( JTree tree , int startingIndex , int rowCount ) { for ( int i = startingIndex ; i < rowCount ; ++ i ) { tree . expandRow ( i ) ; } if ( tree . getRowCount ( ) != rowCount ) { expandAllNodes ( tree , rowCount , tree . getRowCount ( ) ) ; } }"
1175,void expandAllNodes ( JTree tree ) { int j = tree . getRowCount ( ) ; int i = 0 ; while ( i < j ) { tree . expandRow ( i ) ; i += 1 ; j = tree . getRowCount ( ) ; } }
1176,"void main ( String [ ] args ) { String pass = ""admin"" ; int maxTry = 3 ; boolean success = false ; Scanner input = new Scanner ( System . in ) ; System . out . print ( ""Insert the admin pass: "" ) ; String test = input . nextLine ( ) ; while ( maxTry > 0 ) { maxTry -- ; if ( ! pass . equals ( test ) ) { System . out . print ( ""You have "" + maxTry + "" try(es): "" ) ; test = input . nextLine ( ) ; } else { success = true ; break ; } } if ( success ) { System . out . println ( ""Access granted"" ) ; } else { System . out . println ( ""Access denied"" ) ; } }"
1177,"void main ( String [ ] args ) { String pass = ""admin"" ; Scanner input = new Scanner ( System . in ) ; System . out . print ( ""Insert the admin pass: "" ) ; String test = input . nextLine ( ) ; if ( pass . equals ( test ) ) { System . out . print ( ""Access granted"" ) ; } else { for ( int i = 1 ; i < 3 ; i ++ ) { System . out . print ( ""You have "" + i + "" try(es): "" ) ; test = input . nextLine ( ) ; if ( pass . equals ( test ) ) { System . out . print ( ""Access granted"" ) ; break ; } else if ( i == 2 ) { System . out . print ( ""Access denied"" ) ; } } } }"
1178,"void refund ( float balance ) { System . out . println ( ""You have selected the refund option:"" ) ; for ( int counter = ( int ) balance ; counter >= 10 ; counter -= 10 ) { System . out . println ( ""Balance: Â£"" + balance ) ; balance -= 10 ; } for ( int counter = ( int ) balance ; counter > 0 ; counter -= 1 ) { System . out . println ( ""Balance: Â£"" + balance ) ; balance -= 1 ; } System . out . println ( ""Balance: Â£"" + balance ) ; }"
1179,"void refund ( int balance ) { while ( balance >= 10 ) { System . out . println ( ""Balance: Â£"" + balance ) ; balance -= 10 ; } while ( balance >= 0 ) { System . out . println ( ""Balance: Â£"" + balance ) ; balance -= 1 ; } }"
1180,int singleNumber ( int [ ] nums ) { int temp = 0 ; int answer = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { boolean flag = true ; temp = nums [ i ] ; for ( int j = 0 ; j < nums . length ; j ++ ) { if ( temp == nums [ j ] ) { if ( i != j ) { flag = false ; break ; } } } if ( flag == true ) { answer = temp ; } } return answer ; }
1181,int singleNumber ( int [ ] nums ) { Set < Integer > unique = new HashSet < > ( ) ; for ( int num : nums ) { if ( ! unique . add ( num ) ) { unique . remove ( num ) ; } } return unique . iterator ( ) . next ( ) ; }
1182,"void main ( String [ ] args ) { List < char [ ] > list = new ArrayList < char [ ] > ( ) ; list . add ( ""hello"" . toCharArray ( ) ) ; list . add ( ""world !"" . toCharArray ( ) ) ; char [ ] [ ] xss = list . toArray ( new char [ 0 ] [ 0 ] ) ; for ( char [ ] xs : xss ) { System . out . println ( Arrays . toString ( xs ) ) ; } }"
1183,"void main ( String ... args ) throws Exception { List < char [ ] > myArray = new ArrayList < char [ ] > ( ) ; myArray . add ( ""string1"" . toCharArray ( ) ) ; myArray . add ( ""string2"" . toCharArray ( ) ) ; myArray . add ( ""string3"" . toCharArray ( ) ) ; char [ ] [ ] charArray2D = myArray . toArray ( new char [ 0 ] [ 0 ] ) ; System . out . println ( charArray2D . length ) ; StringBuilder s = new StringBuilder ( ) ; for ( char [ ] c : myArray ) { s . append ( String . copyValueOf ( c ) ) ; } char [ ] charArray1D = s . toString ( ) . toCharArray ( ) ; System . out . println ( charArray1D . length ) ; }"
1184,"String longestSequenceOfChar ( String str ) { String result = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int j = i ; while ( j < str . length ( ) && str . charAt ( j ) == str . charAt ( i ) ) { j ++ ; } if ( j - i > result . length ( ) ) { result = str . substring ( i , j ) ; } } return result ; }"
1185,"String longestSequenceOfChar ( String str ) { String interimresult = """" ; String result = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; interimresult += ch ; for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { char ch1 = str . charAt ( j ) ; if ( ch != ch1 ) { break ; } interimresult += ch ; } if ( interimresult . length ( ) > result . length ( ) ) result = interimresult ; interimresult = """" ; } return result ; }"
1186,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1187,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1188,"void main ( String ... args ) { processor = new DefaultProcessor ( ) ; long [ ] values = new long [ ] { 0 , 4 , 10 , 12 , 100 , 108 , 299 , 1000 , 1003 , 2040 , 45213 , 100000 , 100005 , 100010 , 202020 , 202022 , 999999 , 1000000 , 1000001 , 10000000 , 10000007 , 99999999 , Long . MAX_VALUE , Long . MIN_VALUE } ; String [ ] strValues = new String [ ] { ""0001.2"" , ""3.141592"" } ; for ( long val : values ) { System . out . println ( val + "" = "" + processor . getName ( val ) ) ; } for ( String strVal : strValues ) { System . out . println ( strVal + "" = "" + processor . getName ( strVal ) ) ; } StringBuilder bigNumber = new StringBuilder ( ) ; for ( int d = 0 ; d < 66 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } bigNumber . append ( ""."" ) ; for ( int d = 0 ; d < 26 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } System . out . println ( bigNumber . toString ( ) + "" = "" + processor . getName ( bigNumber . toString ( ) ) ) ; }"
1189,"void main ( String [ ] args ) { int n = 0 ; Scanner s = new Scanner ( System . in ) ; System . out . print ( ""Enter an integer number: "" ) ; n = s . nextInt ( ) ; if ( n <= 0 ) System . out . print ( ""Enter numbers greater than 0"" ) ; else { NumberToWord a = new NumberToWord ( ) ; System . out . print ( ""After conversion number in words is :"" ) ; a . pw ( ( n / 1000000000 ) , "" Hundred"" ) ; a . pw ( ( n / 10000000 ) % 100 , "" crore"" ) ; a . pw ( ( ( n / 100000 ) % 100 ) , "" lakh"" ) ; a . pw ( ( ( n / 1000 ) % 100 ) , "" thousand"" ) ; a . pw ( ( ( n / 100 ) % 10 ) , "" hundred"" ) ; a . pw ( ( n % 100 ) , "" "" ) ; } }"
1190,"void main ( String args [ ] ) { int i ; int large [ ] = new int [ 5 ] ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 , 43 , 56 } ; int max = 0 , index ; for ( int j = 0 ; j < 5 ; j ++ ) { max = array [ 0 ] ; index = 0 ; for ( i = 1 ; i < array . length ; i ++ ) { if ( max < array [ i ] ) { max = array [ i ] ; index = i ; } } large [ j ] = max ; array [ index ] = Integer . MIN_VALUE ; System . out . println ( ""Largest "" + j + "" : "" + large [ j ] ) ; } }"
1191,"void main ( String args [ ] ) { int i ; int largestSize = 4 ; int array [ ] = { 33 , 55 , 13 , 46 , 87 , 42 , 10 , 34 } ; int large [ ] = Arrays . copyOf ( array , largestSize ) ; int smallest = large [ 0 ] ; int smallestIndex = 0 ; for ( int j = 1 ; j < large . length ; ++ j ) { if ( smallest > large [ j ] ) { smallest = large [ j ] ; smallestIndex = j ; } } for ( i = large . length ; i < array . length ; i ++ ) { if ( smallest < array [ i ] ) { large [ smallestIndex ] = array [ i ] ; smallest = large [ 0 ] ; smallestIndex = 0 ; for ( int j = 1 ; j < large . length ; ++ j ) { if ( smallest > large [ j ] ) { smallest = large [ j ] ; smallestIndex = j ; } } } } for ( int j = 0 ; j < large . length ; j ++ ) { System . out . println ( ""Largest 5 : "" + large [ j ] ) ; } System . out . println ( ) ; System . out . println ( ""Largest is: "" + getHighest ( large ) ) ; }"
1192,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1193,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , Integer hash , HSSFCellStyle styleOld , XSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( workbookOld , workbookNew , styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( workbookNew , styleOld . getFont ( workbookOld ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
1194,"void filter ( String [ ] words , BufferedReader reader ) throws IOException { String text ; while ( ( text = reader . readLine ( ) ) != null ) { for ( int i = 0 ; i < words . length ; i ++ ) { if ( text . toLowerCase ( ) . contains ( words [ i ] . toLowerCase ( ) ) ) { System . out . println ( text ) ; break ; } } } }"
1195,"void filter ( String [ ] words , String text ) { for ( int i = 0 ; i < words . length ; i ++ ) { if ( text . toLowerCase ( ) . contains ( words [ i ] . toLowerCase ( ) ) ) { System . out . println ( text ) ; break ; } } }"
1196,"void main ( String [ ] args ) { WSObject wsObject = new WSObject ( new Foo ( new Bar ( new Baz ( 241 ) ) ) ) ; WSObject wsObjectNull = new WSObject ( new Foo ( null ) ) ; GetterResult < Integer > intResult = getterChain ( wsObject , WSObject :: getFoo , Foo :: getBar , Bar :: getBar , Baz :: getInt ) ; GetterResult < Integer > intResult2 = getterChain ( wsObjectNull , WSObject :: getFoo , Foo :: getBar , Bar :: getBar , Baz :: getInt ) ; System . out . println ( intResult . result ) ; System . out . println ( intResult . lastIndex ) ; System . out . println ( ) ; System . out . println ( intResult2 . result ) ; System . out . println ( intResult2 . lastIndex ) ; }"
1197,void main ( String [ ] args ) { Address address = new Address ( ) ; address . setSomeCrap ( null ) ; Person person = new Person ( ) ; person . setAddress ( address ) ; long startTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { try { System . out . println ( person . getAddress ( ) . getSomeCrap ( ) . getCrap ( ) ) ; } catch ( NullPointerException npe ) { } } long endTime = System . currentTimeMillis ( ) ; System . out . println ( ( endTime - startTime ) / 1000F ) ; long startTime1 = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { if ( person != null ) { Address address1 = person . getAddress ( ) ; if ( address1 != null ) { SomeCrap someCrap2 = address1 . getSomeCrap ( ) ; if ( someCrap2 != null ) { System . out . println ( someCrap2 . getCrap ( ) ) ; } } } } long endTime1 = System . currentTimeMillis ( ) ; System . out . println ( ( endTime1 - startTime1 ) / 1000F ) ; }
1198,"void main ( String [ ] args ) { System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 0 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 9 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 19 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 21 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 28 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 71 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 72 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 80 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 81 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 89 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 90 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 91 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 97 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 101 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 110 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 120 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 200 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 201 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 232 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 999 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 1001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 10001 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 100000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2000000 ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 3000000000L ) ) ; System . out . println ( ""*** "" + FrenchNumberToWords . convert ( 2147483647 ) ) ; }"
1199,"void main ( String ... args ) { processor = new DefaultProcessor ( ) ; long [ ] values = new long [ ] { 0 , 4 , 10 , 12 , 100 , 108 , 299 , 1000 , 1003 , 2040 , 45213 , 100000 , 100005 , 100010 , 202020 , 202022 , 999999 , 1000000 , 1000001 , 10000000 , 10000007 , 99999999 , Long . MAX_VALUE , Long . MIN_VALUE } ; String [ ] strValues = new String [ ] { ""0"" , ""1.30"" , ""0001.00"" , ""3.141592"" } ; for ( long val : values ) { System . out . println ( val + "" = "" + processor . getName ( val ) ) ; } for ( String strVal : strValues ) { System . out . println ( strVal + "" = "" + processor . getName ( strVal ) ) ; } StringBuilder bigNumber = new StringBuilder ( ) ; for ( int d = 0 ; d < 66 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } bigNumber . append ( ""."" ) ; for ( int d = 0 ; d < 26 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } System . out . println ( bigNumber . toString ( ) + "" = "" + processor . getName ( bigNumber . toString ( ) ) ) ; }"
1200,"String deriveCurveName ( org . bouncycastle . jce . spec . ECParameterSpec ecParameterSpec ) throws GeneralSecurityException { for ( @ SuppressWarnings ( ""rawtypes"" ) Enumeration names = ECNamedCurveTable . getNames ( ) ; names . hasMoreElements ( ) ; ) { final String name = ( String ) names . nextElement ( ) ; final X9ECParameters params = ECNamedCurveTable . getByName ( name ) ; if ( params . getN ( ) . equals ( ecParameterSpec . getN ( ) ) && params . getH ( ) . equals ( ecParameterSpec . getH ( ) ) && params . getCurve ( ) . equals ( ecParameterSpec . getCurve ( ) ) && params . getG ( ) . equals ( ecParameterSpec . getG ( ) ) ) { return name ; } } throw new GeneralSecurityException ( ""Could not find name for curve"" ) ; }"
1201,"String deriveCurveName ( PublicKey publicKey ) throws GeneralSecurityException { if ( publicKey instanceof java . security . interfaces . ECPublicKey ) { final java . security . interfaces . ECPublicKey pk = ( java . security . interfaces . ECPublicKey ) publicKey ; final ECParameterSpec params = pk . getParams ( ) ; return deriveCurveName ( EC5Util . convertSpec ( params , false ) ) ; } else if ( publicKey instanceof org . bouncycastle . jce . interfaces . ECPublicKey ) { final org . bouncycastle . jce . interfaces . ECPublicKey pk = ( org . bouncycastle . jce . interfaces . ECPublicKey ) publicKey ; return deriveCurveName ( pk . getParameters ( ) ) ; } else throw new IllegalArgumentException ( ""Can only be used with instances of ECPublicKey (either jce or bc implementation)"" ) ; }"
1202,"int findMIN ( int [ ] A , int c ) { int x = A [ c ] ; int min_index = c ; for ( int i = c ; i < A . length ; i ++ ) { if ( x > A [ i ] ) { x = A [ i ] ; min_index = i ; } } A [ min_index ] = A [ c ] ; A [ c ] = A [ min_index ] ; return x ; }"
1203,"int findMIN ( int [ ] A , int c ) { int x = A [ c ] ; int position = c ; while ( c < A . length ) { if ( x > A [ c ] ) { x = A [ c ] ; position = c ; } c ++ ; } return position ; }"
1204,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int numOfItems = 20 , maxItems = 0 ; String arrayOfNames [ ] = new String [ numOfItems ] ; String Temp = """" ; for ( int i = 0 ; i < arrayOfNames . length ; i ++ ) { System . out . print ( ""Enter Item "" + ( i + 1 ) + "" : "" ) ; Temp = scan . nextLine ( ) ; if ( Temp . equals ( arrayOfNames [ 0 ] ) ) { maxItems = i ; break ; } else { arrayOfNames [ i ] = Temp ; } } for ( int i = 0 ; i < maxItems ; i ++ ) { System . out . print ( ""Item # "" + ( i + 1 ) + "" : "" ) ; System . out . print ( arrayOfNames [ i ] + ""\n"" ) ; } }"
1205,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int numOfItems = 0 ; System . out . print ( ""Enter How Many Items: "" ) ; try { numOfItems = Integer . parseInt ( scan . nextLine ( ) . trim ( ) ) ; } catch ( NumberFormatException e ) { System . out . print ( ""Number of items you entered is invalid!"" ) ; System . exit ( 0 ) ; } Grocery grocery = new Grocery ( numOfItems ) ; for ( int i = 0 ; i < numOfItems ; i ++ ) { System . out . print ( ""Enter Item "" + ( i + 1 ) + "" : "" ) ; if ( ! grocery . addItem ( scan . nextLine ( ) ) ) { System . out . println ( ""First Item Duplicate Detected!"" ) ; System . exit ( 0 ) ; } } scan . close ( ) ; System . out . println ( grocery . toString ( ) ) ; }"
1206,"Boolean isAnagram ( String word , String anagram_word ) { if ( word . length ( ) != anagram_word . length ( ) ) { return false ; } char [ ] words_char = word . toCharArray ( ) ; char [ ] anagram_word_char = anagram_word . toCharArray ( ) ; int words_char_num = 1 ; int anagram_word_num = 1 ; Map < Character , Integer > wordPrimeMap = wordPrimeMap ( ) ; for ( int i = 0 ; i < words_char . length ; i ++ ) { words_char_num *= wordPrimeMap . get ( words_char [ i ] ) ; } for ( int i = 0 ; i < anagram_word_char . length ; i ++ ) { anagram_word_num *= wordPrimeMap . get ( anagram_word_char [ i ] ) ; } return anagram_word_num == words_char_num ; }"
1207,"boolean isAnagram ( String first , String second ) { String positive = first . toLowerCase ( ) ; String negative = second . toLowerCase ( ) ; if ( positive . length ( ) != negative . length ( ) ) { return false ; } int [ ] counts = new int [ 26 ] ; int diff = 0 ; for ( int i = 0 ; i < positive . length ( ) ; i ++ ) { int pos = ( int ) positive . charAt ( i ) - 97 ; if ( counts [ pos ] >= 0 ) { diff ++ ; } else { diff -- ; } counts [ pos ] ++ ; int neg = ( int ) negative . charAt ( i ) - 97 ; if ( counts [ neg ] <= 0 ) { diff ++ ; } else { diff -- ; } counts [ neg ] -- ; } return diff == 0 ; }"
1208,"void type ( CharSequence chars , int ms ) { ms = ms > 0 ? ms : 0 ; for ( int i = 0 , len = chars . length ( ) ; i < len ; i ++ ) { char c = chars . charAt ( i ) ; AWTKeyStroke keyStroke = getKeyStroke ( c ) ; int keyCode = keyStroke . getKeyCode ( ) ; boolean shift = Character . isUpperCase ( c ) || keyStroke . getModifiers ( ) == ( SHIFT_DOWN_MASK + 1 ) ; if ( shift ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; } robot . keyPress ( keyCode ) ; robot . keyRelease ( keyCode ) ; if ( shift ) { robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } if ( ms > 0 ) { robot . delay ( ms ) ; } } }"
1209,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_SHIFT , VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_SHIFT , VK_AT ) ; break ; case '#' : doType ( VK_SHIFT , VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_SHIFT , VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_SHIFT , VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_SHIFT , VK_AMPERSAND ) ; break ; case '*' : doType ( VK_SHIFT , VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_SHIFT , VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_SHIFT , VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_SHIFT , VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_SHIFT , VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; case '\b' : doType ( VK_BACK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
1210,void shuffle ( String input ) { List < Character > characters = new ArrayList < Character > ( ) ; for ( char c : input . toCharArray ( ) ) { characters . add ( c ) ; } StringBuilder output = new StringBuilder ( input . length ( ) ) ; while ( characters . size ( ) != 0 ) { int randPicker = ( int ) ( Math . random ( ) * characters . size ( ) ) ; output . append ( characters . remove ( randPicker ) ) ; } System . out . println ( output . toString ( ) ) ; }
1211,"String shuffle ( String text ) { if ( text . length ( ) <= 1 ) return text ; int split = text . length ( ) / 2 ; String temp1 = shuffle ( text . substring ( 0 , split ) ) ; String temp2 = shuffle ( text . substring ( split ) ) ; if ( Math . random ( ) > 0.5 ) return temp1 + temp2 ; else return temp2 + temp1 ; }"
1212,"void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Please enter user name : "" ) ; String username = null ; try { username = reader . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } System . out . println ( ""You entered : "" + username ) ; Scanner in = new Scanner ( System . in ) ; System . out . print ( ""Please enter user name : "" ) ; username = in . nextLine ( ) ; System . out . println ( ""You entered : "" + username ) ; Console console = System . console ( ) ; username = console . readLine ( ""Please enter user name : "" ) ; System . out . println ( ""You entered : "" + username ) ; }"
1213,"void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter String"" ) ; String s = br . readLine ( ) ; System . out . print ( ""Enter Integer:"" ) ; try { int i = Integer . parseInt ( br . readLine ( ) ) ; } catch ( NumberFormatException nfe ) { System . err . println ( ""Invalid Format!"" ) ; } }"
1214,"BufferedImage scale ( BufferedImage imageToScale , int dWidth , int dHeight ) { BufferedImage scaledImage = null ; if ( imageToScale != null ) { scaledImage = new BufferedImage ( dWidth , dHeight , imageToScale . getType ( ) ) ; Graphics2D graphics2D = scaledImage . createGraphics ( ) ; graphics2D . drawImage ( imageToScale , 0 , 0 , dWidth , dHeight , null ) ; graphics2D . dispose ( ) ; } return scaledImage ; }"
1215,"BufferedImage scale ( BufferedImage sbi , int imageType , int dWidth , int dHeight , double fWidth , double fHeight ) { BufferedImage dbi = null ; if ( sbi != null ) { dbi = new BufferedImage ( dWidth , dHeight , imageType ) ; Graphics2D g = dbi . createGraphics ( ) ; AffineTransform at = AffineTransform . getScaleInstance ( fWidth , fHeight ) ; g . drawRenderedImage ( sbi , at ) ; } return dbi ; }"
1216,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
1217,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1218,"void main ( String args [ ] ) { int [ ] solutionArray = { 1 , 2 , 3 , 4 , 5 , 6 , 16 , 15 , 14 , 13 , 12 , 11 } ; shuffleArray ( solutionArray ) ; for ( int i = 0 ; i < solutionArray . length ; i ++ ) { System . out . print ( solutionArray [ i ] + "" "" ) ; } System . out . println ( ) ; }"
1219,void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; ArrayList < Integer > l = new ArrayList < Integer > ( 10 ) ; for ( int i = 0 ; i < 10 ; i ++ ) l . add ( sc . nextInt ( ) ) ; Collections . shuffle ( l ) ; for ( int j = 0 ; j < 10 ; j ++ ) System . out . println ( l . get ( j ) ) ; }
1220,"String interleave ( String you , String me ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < Math . max ( you . length ( ) , me . length ( ) ) ; i ++ ) { if ( i < you . length ( ) ) { result . append ( you . charAt ( i ) ) ; } if ( i < me . length ( ) ) { result . append ( me . charAt ( i ) ) ; } } return result . toString ( ) ; }"
1221,"String interleave ( String you , String me ) { char [ ] a = you . toCharArray ( ) ; char [ ] b = me . toCharArray ( ) ; StringBuilder out = new StringBuilder ( ) ; int maxLength = Math . max ( a . length , b . length ) ; for ( int i = 0 ; i < maxLength ; i ++ ) { if ( i < a . length ) out . append ( a [ i ] ) ; if ( i < b . length ) out . append ( b [ i ] ) ; } return out . toString ( ) ; }"
1222,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
1223,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
1224,"void run ( ) { int i = 2 ; while ( i < 50 ) { while ( s . getState ( ) != 1 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 1 ) System . out . println ( ""t2 "" + i ) ; s . setState ( 2 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
1225,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tic"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
1226,"void sort ( int [ ] input , Speed speed ) { SortStrategy strategy = null ; switch ( speed ) { case SLOW : strategy = new SlowBubbleSortStrategy ( ) ; break ; case MEDIUM : strategy = new MediumInsertationSortStrategy ( ) ; break ; case FAST : strategy = new FastQuickSortStrategy ( ) ; break ; default : strategy = new MediumInsertationSortStrategy ( ) ; } strategy . sort ( input ) ; }"
1227,"void sort ( int [ ] input , int startIndx , int endIndx ) { int endIndexOrig = endIndx ; int startIndexOrig = startIndx ; if ( startIndx >= endIndx ) return ; int pavitVal = input [ endIndx ] ; while ( startIndx <= endIndx ) { while ( input [ startIndx ] < pavitVal ) startIndx ++ ; while ( input [ endIndx ] > pavitVal ) endIndx -- ; if ( startIndx <= endIndx ) { int tmp = input [ startIndx ] ; input [ startIndx ] = input [ endIndx ] ; input [ endIndx ] = tmp ; startIndx ++ ; endIndx -- ; } } sort ( input , startIndexOrig , endIndx ) ; sort ( input , startIndx , endIndexOrig ) ; }"
1228,"void countString ( String str , Character character ) { int [ ] counts = new int [ MAX_CHAR ] ; char [ ] chars = str . toCharArray ( ) ; for ( char ch : chars ) { if ( character != null && character != ch ) { continue ; } counts [ ch ] ++ ; } for ( int i = 0 ; i < counts . length ; i ++ ) { if ( counts [ i ] > 0 ) { System . out . println ( ""Character "" + ( char ) i + "" appeared "" + counts [ i ] + "" times"" ) ; } } }"
1229,"void countString ( String str , char value ) { String [ ] arr = str . split ( """" ) ; StringBuffer tempString = new StringBuffer ( ) ; for ( String s : arr ) { tempString . append ( s ) ; for ( char ch : s . toCharArray ( ) ) { System . out . println ( ""Number of Occurrence of "" + ch + "" is:"" + tempString . chars ( ) . filter ( i -> i == ch ) . count ( ) ) ; } } if ( ! ( Character . toString ( value ) . isEmpty ( ) ) ) { StringBuffer tempString2 = new StringBuffer ( ) ; for ( String s : arr ) { tempString2 . append ( s ) ; for ( char ch : s . toCharArray ( ) ) { if ( ch == value ) { System . out . println ( ""Number of Occurrence of "" + ch + "" is:"" + tempString2 . chars ( ) . filter ( i -> i == ch ) . count ( ) ) ; } } } } }"
1230,"String camelCaser ( String str ) { char [ ] strChr = str . toCharArray ( ) ; strChr [ 0 ] = Character . toUpperCase ( strChr [ 0 ] ) ; for ( int i = 0 ; i < strChr . length ; i ++ ) if ( strChr [ i ] == '_' ) strChr [ i + 1 ] = Character . toUpperCase ( strChr [ i + 1 ] ) ; String reply = new String ( strChr ) ; reply = reply . replace ( ""_"" , """" ) ; return reply ; }"
1231,"String camelCaser ( String str ) { String [ ] words = str . split ( ""_"" ) ; String res = """" ; for ( String word : words ) { if ( ! word . isEmpty ( ) ) { res += Character . toUpperCase ( word . charAt ( 0 ) ) ; if ( word . length ( ) > 1 ) { res += word . substring ( 1 ) ; } } } return res ; }"
1232,"boolean isAnagram ( String leftString , String rightString ) { if ( leftString == null || rightString == null ) { return false ; } else if ( leftString . length ( ) != rightString . length ( ) ) { return false ; } char letters [ ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' } ; Map < Character , Integer > occurrencesMap = new HashMap < > ( ) ; for ( char l : letters ) { occurrencesMap . put ( l , 0 ) ; } for ( int i = 0 ; i < leftString . length ( ) ; i ++ ) { char charFromLeft = leftString . charAt ( i ) ; Integer nrOfCharsInLeft = occurrencesMap . get ( charFromLeft ) ; occurrencesMap . put ( charFromLeft , ++ nrOfCharsInLeft ) ; char charFromRight = rightString . charAt ( i ) ; Integer nrOfCharsInRight = occurrencesMap . get ( charFromRight ) ; occurrencesMap . put ( charFromRight , -- nrOfCharsInRight ) ; } for ( Integer occurrencesNr : occurrencesMap . values ( ) ) { if ( occurrencesNr != 0 ) { return false ; } } return true ; }"
1233,"boolean isAnagram ( String s1 , String s2 ) { StringBuilder sb1 = new StringBuilder ( ) ; StringBuilder sb2 = new StringBuilder ( ) ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; char arr1 [ ] = s1 . toCharArray ( ) ; char arr2 [ ] = s2 . toCharArray ( ) ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( char c : arr1 ) { sb1 . append ( c ) ; } for ( char c : arr2 ) { sb2 . append ( c ) ; } System . out . println ( sb1 . toString ( ) ) ; System . out . println ( sb2 . toString ( ) ) ; if ( sb1 . toString ( ) . equals ( sb2 . toString ( ) ) ) return true ; else return false ; }"
1234,Node getTrueParent ( ) { for ( Edge e : this . edges ) { if ( e . getNode2 ( ) == this && ( ! e . isPseudo ( ) ) ) { Node parent = e . getNode1 ( ) ; return parent ; } } return null ; }
1235,Node getTrueParent ( ) { if ( getEdges ( ) != null && ! getEdges ( ) . isEmpty ( ) ) { for ( Edge e : getEdges ( ) ) { if ( e != null && e . getNode2 ( ) == this && ! e . isPseudo ( ) ) { return e . getNode1 ( ) ; } } } return null ; }
1236,"void run ( ) { int i = 2 ; while ( i < 50 ) { while ( s . getState ( ) != 1 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 1 ) System . out . println ( ""t2 "" + i ) ; s . setState ( 2 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
1237,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tac"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
1238,"void main ( String [ ] args ) { double numIterations = 10 ; long exceptionPlusCatchTime = 0 , excepTime = 0 , strTime = 0 , throwTime = 0 ; for ( int i = 0 ; i < numIterations ; i ++ ) { exceptionPlusCatchTime += exceptionPlusCatchBlock ( ) ; excepTime += createException ( ) ; throwTime += catchBlock ( ) ; strTime += createString ( ) ; } System . out . println ( ""new Exception + throw/catch = "" + exceptionPlusCatchTime / numIterations ) ; System . out . println ( ""new Exception only          = "" + excepTime / numIterations ) ; System . out . println ( ""throw/catch only            = "" + throwTime / numIterations ) ; System . out . println ( ""new String (benchmark)      = "" + strTime / numIterations ) ; }"
1239,"void main ( String [ ] args ) { long throwCatchTime = 0 , newExceptionTime = 0 , newObjectTime = 0 , noStackExceptionTime = 0 ; for ( int i = 0 ; i < 30 ; i ++ ) { throwCatchTime += throwCatchLoop ( ) ; newExceptionTime += newExceptionLoop ( ) ; newObjectTime += newObjectLoop ( ) ; noStackExceptionTime += newNoStackExceptionLoop ( ) ; } System . out . println ( ""throwCatchTime = "" + throwCatchTime / 30 ) ; System . out . println ( ""newExceptionTime = "" + newExceptionTime / 30 ) ; System . out . println ( ""newStringTime = "" + newObjectTime / 30 ) ; System . out . println ( ""noStackExceptionTime = "" + noStackExceptionTime / 30 ) ; }"
1240,void switchPairs ( ) { if ( front == null || front . next == null ) return ; ListNode current = front . next ; front . next = current . next ; current . next = front ; front = current ; current = current . next ; while ( current . next != null && current . next . next != null ) { ListNode temp = current . next . next ; current . next . next = temp . next ; temp . next = current . next ; current . next = temp ; current = temp . next ; } }
1241,"ListNode switchPairs ( ) { if ( this == null || this . next == null ) return this ; ListNode top = this . next ; ListNode first = this ; ListNode second = first . next ; do { ListNode third = second . next ; second . next = first ; first . next = third ; first = third ; System . out . println ( ""@@@ "" + this . toString ( ) ) ; if ( first != null ) { second . next . next = first . next ; second = first . next ; } } while ( first != null && second != null ) ; return top ; }"
1242,"boolean isBetween ( int currentMonth , int currentDay , int monthFrom , int dayFrom , int monthUntil , int dayUntil ) { int currentYear = 2000 ; LocalDate dateFrom = LocalDate . of ( currentYear , monthFrom , dayFrom ) ; LocalDate dateUntil = LocalDate . of ( currentYear , monthUntil , dayUntil ) ; if ( dateFrom . isAfter ( dateUntil ) ) { dateUntil = dateUntil . plusYears ( 1 ) ; } LocalDate currentDateThisYear = LocalDate . of ( currentYear , currentMonth , currentDay ) ; LocalDate currentDateNextYear = currentDateThisYear . plusYears ( 1 ) ; if ( ! ( currentDateThisYear . isBefore ( dateFrom ) || currentDateThisYear . isAfter ( dateUntil ) ) ) { return true ; } else if ( ! ( currentDateNextYear . isBefore ( dateFrom ) || currentDateNextYear . isAfter ( dateUntil ) ) ) { return true ; } return false ; }"
1243,"boolean isBetween ( int currentMonth , int currentDay , int fromMonth , int fromDay , int untilMonth , int untilDay ) { MonthDay current = MonthDay . of ( currentMonth , currentDay ) ; MonthDay from = MonthDay . of ( fromMonth , fromDay ) ; MonthDay until = MonthDay . of ( untilMonth , untilDay ) ; if ( from . compareTo ( until ) <= 0 ) { return from . compareTo ( current ) <= 0 && current . compareTo ( until ) <= 0 ; } else { return current . compareTo ( until ) <= 0 || current . compareTo ( from ) >= 0 ; } }"
1244,"int sum ( ) { sum = 0 ; final IntPredicate positive = v -> v > 0 ; final Index positiveIndex = new Index ( positive ) ; final Index negativeIndex = new Index ( positive . negate ( ) ) ; while ( positiveIndex . index < array . length || negativeIndex . index < array . length ) { sum += sum < 0 ? sum ( positiveIndex , negativeIndex ) : sum ( negativeIndex , positiveIndex ) ; } return sum ; }"
1245,"int sum ( @ NotNull Index mainIndex , @ NotNull Index secondaryIndex ) { int localSum = 0 ; while ( mainIndex . index < array . length && secondaryIndex . sign . test ( array [ mainIndex . index ] ) ) { mainIndex . index ++ ; } if ( mainIndex . index < array . length ) { localSum += array [ mainIndex . index ++ ] ; } else { for ( ; secondaryIndex . index < array . length ; secondaryIndex . index ++ ) { if ( secondaryIndex . sign . test ( array [ secondaryIndex . index ] ) ) { localSum += array [ secondaryIndex . index ] ; } } } return localSum ; }"
1246,"String sequenceNums ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( ) ; int rangeStart = nums [ 0 ] ; int previous = nums [ 0 ] ; int current ; int expected = previous + 1 ; int size = nums . length ; for ( int i = 1 ; i < size ; i ++ ) { current = nums [ i ] ; expected = previous + 1 ; if ( current != expected ) { addRange ( sb , rangeStart , previous ) ; rangeStart = current ; } previous = current ; } addRange ( sb , rangeStart , nums [ size - 1 ] ) ; return sb . toString ( ) ; }"
1247,"String sequenceNums ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( ) ; int rangeStart = nums [ 0 ] ; int previous = nums [ 0 ] ; int current ; int expected = previous + 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { current = nums [ i ] ; expected = previous + 1 ; if ( current != expected || i == ( nums . length - 1 ) ) { if ( current == rangeStart ) { sb . append ( previous + "","" ) ; } else { if ( rangeStart != previous ) { if ( i == nums . length - 1 ) sb . append ( rangeStart + ""-"" + current ) ; else sb . append ( rangeStart + ""-"" + previous + "","" ) ; } else { if ( i == nums . length - 1 ) sb . append ( rangeStart + "","" + current ) ; else sb . append ( rangeStart + "","" ) ; } } rangeStart = current ; } previous = current ; } if ( sb . charAt ( sb . length ( ) - 1 ) == ',' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }"
1248,void removeDuplicates ( char [ ] str ) { if ( str == null || str . length < 2 ) { return ; } int tail = 0 ; for ( int i = 0 ; i < str . length ; i ++ ) { boolean found = false ; for ( int j = 0 ; j < i ; j ++ ) { if ( str [ j ] == str [ i ] ) { found = true ; break ; } } if ( found ) { continue ; } str [ tail ] = str [ i ] ; tail ++ ; } str [ tail ] = '\0' ; }
1249,"String removeDuplicates ( String s ) { StringBuilder noDupes = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String si = s . substring ( i , i + 1 ) ; if ( noDupes . indexOf ( si ) == - 1 ) { noDupes . append ( si ) ; } } return noDupes . toString ( ) ; }"
1250,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { CharSequence out = super . filter ( source , start , end , dest , dstart , dend ) ; if ( out != null ) { source = out ; start = 0 ; end = out . length ( ) ; } int len = end - start ; if ( len == 0 ) { return source ; } int dlen = dest . length ( ) ; for ( int i = 0 ; i < dstart ; i ++ ) { if ( dest . charAt ( i ) == '.' ) { return ( dlen - ( i + 1 ) + len > digits ) ? """" : new SpannableStringBuilder ( source , start , end ) ; } } for ( int i = start ; i < end ; ++ i ) { if ( source . charAt ( i ) == '.' ) { if ( ( dlen - dend ) + ( end - ( i + 1 ) ) > digits ) return """" ; else break ; } } return new SpannableStringBuilder ( source , start , end ) ; }"
1251,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String replacement = source . subSequence ( start , end ) . toString ( ) ; String newVal = dest . subSequence ( 0 , dstart ) . toString ( ) + replacement + dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; Matcher matcher = mPattern . matcher ( newVal ) ; if ( matcher . matches ( ) ) return null ; if ( TextUtils . isEmpty ( source ) ) return dest . subSequence ( dstart , dend ) ; else return """" ; }"
1252,"boolean isAvailable ( String link ) { boolean available = false ; URL url = null ; try { url = new URL ( link ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } HttpURLConnection connection = null ; try { connection = ( HttpURLConnection ) url . openConnection ( ) ; } catch ( IOException e1 ) { } connection . setRequestProperty ( ""Connection"" , ""close"" ) ; connection . setConnectTimeout ( 100000 ) ; try { connection . connect ( ) ; } catch ( IOException e ) { } try { if ( connection . getResponseCode ( ) == 200 ) { available = true ; } else available = false ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return available ; }"
1253,"void isAvailable ( ) { URL url = new URL ( ""URL HERE"" ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestProperty ( ""Connection"" , ""close"" ) ; connection . setConnectTimeout ( 10000 ) ; connection . connect ( ) ; if ( connection . getResponseCode ( ) == 200 ) { return true ; } else return false ; }"
1254,"void main ( String [ ] args ) { int [ ] coins = { 1 , 3 , 5 , 10 , 20 , 50 , 100 , 200 , 500 } ; int amount = new Random ( ) . nextInt ( 10000 ) ; int coinsCount = 0 ; System . out . println ( ""amount = "" + amount ) ; int [ ] numberOfCoins = findNumberOfCoins ( coins , amount ) ; for ( int i = 0 ; i < numberOfCoins . length ; i ++ ) { if ( numberOfCoins [ i ] > 0 ) { System . out . println ( ""coins= "" + coins [ i ] + "" Count="" + numberOfCoins [ i ] + ""\n"" ) ; coinsCount += numberOfCoins [ i ] ; } } System . out . println ( ""numberOfCoins = "" + coinsCount ) ; }"
1255,"void main ( String [ ] args ) { int [ ] coins = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int money = 600 ; int [ ] [ ] recorder = new int [ money + 1 ] [ coins . length ] ; for ( int k = 0 ; k < coins . length ; k ++ ) { recorder [ 0 ] [ k ] = 1 ; } for ( int i = 1 ; i <= money ; i ++ ) { int with = 0 ; int without = 0 ; for ( int coin_index = 0 ; coin_index < coins . length ; coin_index ++ ) { if ( i - coins [ coin_index ] < 0 ) { with = 0 ; } else { with = recorder [ i - coins [ coin_index ] ] [ coin_index ] ; } if ( coin_index - 1 < 0 ) { without = 0 ; } else { without = recorder [ i ] [ coin_index - 1 ] ; } recorder [ i ] [ coin_index ] = with + without ; } } System . out . print ( recorder [ money ] [ coins . length - 1 ] ) ; }"
1256,int isPerfectSquare ( int n ) { int h = n & 0xF ; if ( h > 9 ) return 0 ; if ( h != 2 && h != 3 && h != 5 && h != 6 && h != 7 && h != 8 ) { int t = ( int ) floor ( sqrt ( ( double ) n ) + 0.5 ) ; return t * t == n ; } return 0 ; }
1257,boolean isPerfectSquare ( long n ) { if ( n < 0 ) { return false ; } else { switch ( ( byte ) n ) { case - 128 : case - 127 : case - 124 : case - 119 : case - 112 : case - 111 : case - 103 : case - 95 : case - 92 : case - 87 : case - 79 : case - 71 : case - 64 : case - 63 : case - 60 : case - 55 : case - 47 : case - 39 : case - 31 : case - 28 : case - 23 : case - 15 : case - 7 : case 0 : case 1 : case 4 : case 9 : case 16 : case 17 : case 25 : case 33 : case 36 : case 41 : case 49 : case 57 : case 64 : case 65 : case 68 : case 73 : case 81 : case 89 : case 97 : case 100 : case 105 : case 113 : case 121 : long i = ( n * INV3465 ) > > > 52 ; if ( ! good3465 [ ( int ) i ] ) { return false ; } else { long r = round ( Math . sqrt ( n ) ) ; return r * r == n ; } default : return false ; } } }
1258,"void type ( CharSequence chars , int ms ) { ms = ms > 0 ? ms : 0 ; for ( int i = 0 , len = chars . length ( ) ; i < len ; i ++ ) { char c = chars . charAt ( i ) ; AWTKeyStroke keyStroke = getKeyStroke ( c ) ; int keyCode = keyStroke . getKeyCode ( ) ; boolean shift = Character . isUpperCase ( c ) || keyStroke . getModifiers ( ) == ( SHIFT_DOWN_MASK + 1 ) ; if ( shift ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; } robot . keyPress ( keyCode ) ; robot . keyRelease ( keyCode ) ; if ( shift ) { robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } if ( ms > 0 ) { robot . delay ( ms ) ; } } }"
1259,void type ( char character ) { handleSpecialCharacter ( character ) ; if ( Character . isLowerCase ( character ) ) { typeCharacter ( Character . toUpperCase ( character ) ) ; } if ( Character . isUpperCase ( character ) ) { typeShiftCharacter ( character ) ; } if ( Character . isDigit ( character ) ) { typeCharacter ( character ) ; } }
1260,"void main ( String [ ] args ) { int first , second ; Scanner myScanner = new Scanner ( System . in ) ; System . out . println ( ""Enter first integer: "" ) ; int numOne ; numOne = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numOne ) ; System . out . println ( ""Enter second integer: "" ) ; int numTwo ; numTwo = myScanner . nextInt ( ) ; System . out . println ( ""You have keyed in "" + numTwo ) ; Random generator = new Random ( ) ; int num = ( int ) ( Math . random ( ) * numTwo ) ; System . out . println ( ""Random number: "" + ( ( num > numOne ) ? num : numOne + num ) ) ; }"
1261,"void main ( String [ ] args ) { Random ran = new Random ( ) ; int min , max ; Scanner sc = new Scanner ( System . in ) ; System . out . println ( ""Enter min range:"" ) ; min = sc . nextInt ( ) ; System . out . println ( ""Enter max range:"" ) ; max = sc . nextInt ( ) ; int num = ran . nextInt ( min ) ; int num1 = ran . nextInt ( max ) ; System . out . println ( ""Random Number between given range is "" + num1 ) ; }"
1262,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1263,"void transform ( ) { String call = ""transform "" ; System . out . println ( call + ""Workbook"" ) ; XSSFSheet sheetNew ; HSSFSheet sheetOld ; this . workbookNew . setForceFormulaRecalculation ( this . workbookOld . getForceFormulaRecalculation ( ) ) ; this . workbookNew . setMissingCellPolicy ( this . workbookOld . getMissingCellPolicy ( ) ) ; for ( int i = 0 ; i < this . workbookOld . getNumberOfSheets ( ) ; i ++ ) { sheetOld = this . workbookOld . getSheetAt ( i ) ; sheetNew = this . workbookNew . getSheet ( sheetOld . getSheetName ( ) ) ; System . out . println ( call + ""Sheet erstellt: "" + sheetOld . getSheetName ( ) ) ; sheetNew = this . workbookNew . createSheet ( sheetOld . getSheetName ( ) ) ; this . transform ( sheetOld , sheetNew ) ; } System . out . println ( call + ""Anzahl verwendeter Styles: "" + this . styleMap . size ( ) ) ; System . out . println ( call + ""abgeschlossen"" ) ; }"
1264,"void main ( String [ ] args ) { System . out . println ( ""Please enter the length of your picure in inches:"" ) ; final double length = console . nextDouble ( ) ; System . out . println ( ""Please enter the width of your picure in inches: "" ) ; final double width = console . nextDouble ( ) ; System . out . println ( ""Please enter the type of frame: R or r (Regular), F or f (Fancy). "" ) ; final char typeOfFrame = console . next ( ) . charAt ( 0 ) ; FrameType frameType = FrameType . valueOf ( """" + Character . toUpperCase ( typeOfFrame ) ) ; System . out . println ( ""Would you like to add color?: Y for (Yes), N for (No): "" ) ; final char choiceOfColor = console . next ( ) . charAt ( 0 ) ; final boolean color = Character . toUpperCase ( choiceOfColor ) == 'Y' ; System . out . println ( ""Would you like to add crowns? Enter Y (Yes), or N (No): "" ) ; final char choiceOfCrowns = console . next ( ) . charAt ( 0 ) ; final boolean crowns = Character . toUpperCase ( choiceOfCrowns ) == 'Y' ; final double priceOfCrowns ; if ( crowns ) { System . out . println ( ""How many crowns would you like? "" ) ; final int numberOfCrowns = console . nextInt ( ) ; priceOfCrowns = ( numberOfCrowns * CROWNS ) ; } else { priceOfCrowns = 0.0 ; } final double grandTotalPrice = priceOfCrowns + areaPriceInDollars ( frameType , length , width , color ) ; System . out . printf ( ""Your total comes to: $%.2f%n"" , grandTotalPrice ) ; }"
1265,"void main ( String [ ] args ) { final double length ; final double width ; final char typeOfFrame ; final char choiceOfColor ; System . out . println ( ""Please enter the length of your picure in inches:"" ) ; length = console . nextDouble ( ) ; System . out . println ( ""Please enter the width of your picure in inches: "" ) ; width = console . nextDouble ( ) ; System . out . println ( ""Please enter the type of frame: R or r (Regular), F or f (Fancy). "" ) ; typeOfFrame = console . next ( ) . charAt ( 0 ) ; System . out . println ( ""Would you like to add color?: Y for (Yes), N for (No): "" ) ; choiceOfColor = console . next ( ) . charAt ( 0 ) ; if ( ! ( isFrameType ( typeOfFrame ) ) ) { } else { final double area ; final double perimeter ; final double priceOfFrame ; final double priceOfCardboard ; final double priceOfGlass ; area = ( length * width ) ; perimeter = ( 2 * length ) + ( 2 * width ) ; priceOfFrame = ( perimeter * REGULAR_FRAME ) ; priceOfCardboard = ( area * CARDBOARD ) ; priceOfGlass = ( area * GLASS ) ; if ( isValidChoice ( choiceOfColor ) ) { final double priceOfColor ; final double finalPrice ; final char choiceOfCrowns ; final double grandTotalPrice ; if ( choiceOfColor == 'N' ) { finalPrice = ( priceOfFrame + priceOfCardboard + priceOfGlass ) ; } else { priceOfColor = ( area * COLOR ) ; finalPrice = ( priceOfFrame + priceOfColor + priceOfCardboard + priceOfGlass ) ; } System . out . println ( ""Would you like to add crowns? Enter Y (Yes), or N (No): "" ) ; choiceOfCrowns = console . next ( ) . charAt ( 0 ) ; if ( isValidChoice ( choiceOfCrowns ) ) { if ( choiceOfCrowns == 'Y' ) { final double crownFinalPrice ; final int numberOfCrowns ; System . out . println ( ""How many crowns would you like? "" ) ; numberOfCrowns = console . nextInt ( ) ; crownFinalPrice = ( numberOfCrowns * CROWNS ) ; grandTotalPrice = ( crownFinalPrice + finalPrice ) ; } else { grandTotalPrice = finalPrice ; } System . out . printf ( ""Your total comes to: $%.2f%n"" , grandTotalPrice ) ; } } } }"
1266,"String encrypt ( String data ) { String encrypted = new String ( """" ) ; for ( char c : data . toCharArray ( ) ) { char newC = c + 2 ; if ( newC > 'z' ) newC -= 26 ; encrypted += newC ; } return encrpyted ; }"
1267,"String encrypt ( String data ) { String returned = new String ( """" ) ; for ( char h : data . toCharArray ( ) ) { if ( h == 'a' ) returned += "" a', 'c"" ; if ( h == 'b' ) returned += ""d"" ; if ( h == 'c' ) returned += ""e"" ; if ( h == 'd' ) returned += ""f"" ; if ( h == 'e' ) returned += ""g"" ; if ( h == 'f' ) returned += ""h"" ; if ( h == 'g' ) returned += ""i"" ; if ( h == 'h' ) returned += ""j"" ; if ( h == 'i' ) returned += ""k"" ; if ( h == 'j' ) returned += ""l"" ; if ( h == 'k' ) returned += ""m"" ; if ( h == 'l' ) returned += ""n"" ; if ( h == 'm' ) returned += ""o"" ; if ( h == 'n' ) returned += ""p"" ; if ( h == 'o' ) returned += ""q"" ; if ( h == 'p' ) returned += ""r"" ; if ( h == 'q' ) returned += ""s"" ; if ( h == 'r' ) returned += ""t"" ; if ( h == 's' ) returned += ""u"" ; if ( h == 't' ) returned += ""v"" ; if ( h == 'u' ) returned += ""w"" ; if ( h == 'v' ) returned += ""x"" ; if ( h == 'w' ) returned += ""y"" ; if ( h == 'x' ) returned += ""z"" ; if ( h == 'y' ) returned += ""a"" ; if ( h == 'z' ) returned += ""b"" ; } return returned ; }"
1268,"String join ( Collection s , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; Iterator iter = s . iterator ( ) ; while ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { buffer . append ( delimiter ) ; } } return buffer . toString ( ) ; }"
1269,"String join ( Object [ ] objects , String delimiter ) { if ( objects . length == 0 ) { return """" ; } int capacityGuess = ( objects . length * objects [ 0 ] . toString ( ) . length ( ) ) + ( ( objects . length - 1 ) * delimiter . length ( ) ) ; StringBuilder ret = new StringBuilder ( capacityGuess ) ; ret . append ( objects [ 0 ] ) ; for ( int i = 1 ; i < objects . length ; i ++ ) { ret . append ( delimiter ) ; ret . append ( objects [ i ] ) ; } return ret . toString ( ) ; }"
1270,"Object read ( JsonReader in ) throws IOException { JsonToken token = in . peek ( ) ; switch ( token ) { case BEGIN_ARRAY : List < Object > list = new ArrayList < Object > ( ) ; in . beginArray ( ) ; while ( in . hasNext ( ) ) { list . add ( read ( in ) ) ; } in . endArray ( ) ; return list ; case BEGIN_OBJECT : Map < String , Object > map = new LinkedTreeMap < String , Object > ( ) ; in . beginObject ( ) ; while ( in . hasNext ( ) ) { map . put ( in . nextName ( ) , read ( in ) ) ; } in . endObject ( ) ; return map ; case STRING : return in . nextString ( ) ; case NUMBER : String n = in . nextString ( ) ; if ( n . indexOf ( '.' ) != - 1 ) { return Double . parseDouble ( n ) ; } return Long . parseLong ( n ) ; case BOOLEAN : return in . nextBoolean ( ) ; case NULL : in . nextNull ( ) ; return null ; default : throw new IllegalStateException ( ) ; } }"
1271,"Object read ( JsonElement in ) { if ( in . isJsonArray ( ) ) { List < Object > list = new ArrayList < Object > ( ) ; JsonArray arr = in . getAsJsonArray ( ) ; for ( JsonElement anArr : arr ) { list . add ( read ( anArr ) ) ; } return list ; } else if ( in . isJsonObject ( ) ) { Map < String , Object > map = new LinkedTreeMap < String , Object > ( ) ; JsonObject obj = in . getAsJsonObject ( ) ; Set < Map . Entry < String , JsonElement > > entitySet = obj . entrySet ( ) ; for ( Map . Entry < String , JsonElement > entry : entitySet ) { map . put ( entry . getKey ( ) , read ( entry . getValue ( ) ) ) ; } return map ; } else if ( in . isJsonPrimitive ( ) ) { JsonPrimitive prim = in . getAsJsonPrimitive ( ) ; if ( prim . isBoolean ( ) ) { return prim . getAsBoolean ( ) ; } else if ( prim . isString ( ) ) { return prim . getAsString ( ) ; } else if ( prim . isNumber ( ) ) { Number num = prim . getAsNumber ( ) ; if ( Math . ceil ( num . doubleValue ( ) ) == num . longValue ( ) ) return num . longValue ( ) ; else { return num . doubleValue ( ) ; } } } return null ; }"
1272,boolean equals ( Object that ) { if ( this == that ) return true ; if ( ! ( that instanceof People ) ) return false ; People thatPeople = ( People ) that ; return this . name . equals ( thatPeople . name ) && this . age == thatPeople . age ; }
1273,boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! Person . class . isAssignableFrom ( obj . getClass ( ) ) ) { return false ; } final Person other = ( Person ) obj ; if ( ( this . name == null ) ? ( other . name != null ) : ! this . name . equals ( other . name ) ) { return false ; } if ( this . age != other . age ) { return false ; } return true ; }
1274,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
1275,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Time (s)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; drawRotate ( gg , getWidth ( ) , ( getHeight ( ) + width ) / 2 , 270 , string ) ; }"
1276,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( ""how many number you want to put in the pot?"" ) ; int num = input . nextInt ( ) ; int numbers [ ] = new int [ num ] ; for ( int i = 0 ; i < num ; i ++ ) { System . out . println ( ""number"" + i + "":"" ) ; numbers [ i ] = input . nextInt ( ) ; } for ( int temp : numbers ) { System . out . print ( temp + ""\t"" ) ; } input . close ( ) ; }"
1277,"void main ( String [ ] args ) { int arr [ ] ; Scanner scan = new Scanner ( System . in ) ; for ( int i = 0 ; i < 5 ; i ++ ) { System . out . print ( ""Enter number "" + ( i + 1 ) + "": "" ) ; arr [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 5 ; i ++ ) System . out . println ( ""Number "" + ( i + 1 ) + "": "" + arr [ i ] ) ; }"
1278,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
1279,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
1280,"void main ( String [ ] args ) throws Exception { BigInteger bad1 = new BigInteger ( DH_GRP_14_P ) ; BigInteger good1 = new BigInteger ( 1 , DH_GRP_14_P ) ; byte [ ] augmentedBytes = new byte [ DH_GRP_14_P . length + 1 ] ; System . arraycopy ( DH_GRP_14_P , 0 , augmentedBytes , 1 , DH_GRP_14_P . length ) ; BigInteger good2 = new BigInteger ( augmentedBytes ) ; System . out . println ( bad1 ) ; System . out . println ( good1 ) ; System . out . println ( good1 . equals ( good2 ) ) ; System . out . println ( good1 . isProbablePrime ( 50 ) ) ; }"
1281,"void main ( String [ ] args ) throws Exception { KeyPairGenerator hostKeyGen = KeyPairGenerator . getInstance ( ""DH"" ) ; BigInteger p = new BigInteger ( modp2048 , 16 ) ; BigInteger g = BigInteger . valueOf ( 2L ) ; System . out . println ( ""p bits: "" + p . bitLength ( ) ) ; System . out . println ( ""g bits: "" + g . bitLength ( ) ) ; DHParameterSpec dhGrp14KeySpec = new DHParameterSpec ( p , p ) ; hostKeyGen . initialize ( dhGrp14KeySpec ) ; System . out . println ( ""Creating Host DH private key..."" ) ; KeyPair hostKey = hostKeyGen . generateKeyPair ( ) ; System . out . println ( ""Initiating host side Schannel..."" ) ; KeyAgreement schannel = KeyAgreement . getInstance ( ""DH"" ) ; schannel . init ( hostKey . getPrivate ( ) ) ; }"
1282,"int solution ( int N ) { int gap = 0 ; String binaryStr = Integer . toBinaryString ( N ) ; String [ ] zeroArrays = binaryStr . split ( ""1"" ) ; System . out . println ( Arrays . toString ( zeroArrays ) ) ; for ( String zeroArray : zeroArrays ) { gap = zeroArray . length ( ) > gap ? zeroArray . length ( ) : gap ; } return gap ; }"
1283,"int solution ( int N ) { int result = 0 ; while ( N > 0 ) { if ( ( N & 1 ) == 1 ) { int temp = 0 ; while ( ( N >>= 1 ) > 0 && ( ( N & 1 ) != 1 ) ) { temp ++ ; } result = Math . max ( result , temp ) ; } else { N >>= 1 ; } } return result ; }"
1284,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int x = 0 ; int [ ] list1Array = new int [ 1 ] ; System . out . println ( ""Enter list1: "" ) ; while ( input . hasNext ( ) ) { list1Array [ x ] = input . nextInt ( ) ; x ++ ; int [ ] temp = new int [ list1Array . length + 1 ] ; for ( int i = 0 ; i < list1Array . length ; i ++ ) { temp [ i ] = list1Array [ i ] ; } list1Array = temp ; } }"
1285,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . out . println ( ""Enter elemnt size "" ) ; int size = input . nextInt ( ) ; int x = 0 ; int [ ] list1Array = new int [ size ] ; for ( int y = 0 ; y < size ; y ++ ) { System . out . println ( ""Enter number"" ) ; list1Array [ x ] = input . nextInt ( ) ; x ++ ; } System . out . println ( Arrays . toString ( list1Array ) ) ; }"
1286,"String compressBad ( String str ) { String compressedString = """" ; if ( str != null && str . length ( ) > 0 ) { int countConsecutive = 1 ; char prevChar = str . charAt ( 0 ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != prevChar ) { compressedString += String . valueOf ( prevChar ) + countConsecutive ; prevChar = str . charAt ( i ) ; countConsecutive = 1 ; continue ; } countConsecutive ++ ; } compressedString += String . valueOf ( prevChar ) + countConsecutive ; } return compressedString ; }"
1287,"String compressBad ( String str ) { int countConsecutive = 0 ; String compressedString = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { countConsecutive ++ ; if ( str . length ( ) == ( i + 1 ) ) { compressedString += """" + str . charAt ( i ) + countConsecutive ; countConsecutive = 0 ; break ; } else if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) { compressedString += """" + str . charAt ( i ) + countConsecutive ; countConsecutive = 0 ; } } return compressedString ; }"
1288,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
1289,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Distance (m)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; gg . drawString ( string , ( getWidth ( ) - width ) / 2 , 11 ) ; }"
1290,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
1291,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
1292,"void main ( String [ ] args ) { String s = ""aaaabbccccdddeee"" ; String s1 = """" ; String s2 = """" ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s1 . indexOf ( s . charAt ( i ) ) < 0 ) { s1 = s1 + s . charAt ( i ) ; } } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s1 . charAt ( i ) == s . charAt ( j ) ) { count ++ ; } } s2 = s2 + s1 . charAt ( i ) + count ; count = 0 ; } System . out . println ( s2 ) ; }"
1293,"void main ( String [ ] args ) { String string = ""aaabbbbbaccc"" ; int counter ; String result = """" ; int i = 0 ; while ( i < string . length ( ) ) { counter = 1 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { System . out . println ( ""string length ="" + string . length ( ) ) ; if ( string . charAt ( i ) == string . charAt ( j ) ) { counter ++ ; } } result = result + string . charAt ( i ) + counter ; string = string . replaceAll ( String . valueOf ( string . charAt ( i ) ) , """" ) ; } System . out . println ( ""result is = "" + result ) ; }"
1294,boolean deleteRecursive ( File path ) throws FileNotFoundException { if ( ! path . exists ( ) ) throw new FileNotFoundException ( path . getAbsolutePath ( ) ) ; boolean ret = true ; if ( path . isDirectory ( ) ) { for ( File f : path . listFiles ( ) ) { ret = ret && deleteRecursive ( f ) ; } } return ret && path . delete ( ) ; }
1295,"void deleteRecursive ( File path ) { File [ ] c = path . listFiles ( ) ; System . out . println ( ""Cleaning out folder:"" + path . toString ( ) ) ; for ( File file : c ) { if ( file . isDirectory ( ) ) { System . out . println ( ""Deleting file:"" + file . toString ( ) ) ; deleteRecursive ( file ) ; file . delete ( ) ; } else { file . delete ( ) ; } } path . delete ( ) ; }"
1296,int countClamps ( int [ ] arr ) { int result = 0 ; for ( int i = 1 ; i < arr . length ; ++ i ) { if ( arr [ i ] == arr [ i - 1 ] && ( i == arr . length - 1 || arr [ i ] != arr [ i + 1 ] ) ) { ++ result ; } } return result ; }
1297,int countClamps ( int [ ] arr ) { int result = 0 ; int prev = 0 ; boolean same = false ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( i == 0 ) { prev = arr [ i ] ; } else { if ( arr [ i ] == prev ) { if ( ! same ) { result ++ ; same = true ; } } else { prev = arr [ i ] ; same = false ; } } } return result ; }
1298,"void main ( String [ ] args ) throws Exception { String strA = ""1234567890"" ; String strB = ""1234567890"" ; char [ ] charA = getBackingArray ( strA ) ; char [ ] charB = getBackingArray ( strB ) ; char [ ] subA1 = getBackingArray ( strA . substring ( 1 ) ) ; char [ ] subA2 = getBackingArray ( strA . substring ( 0 , 9 ) ) ; System . out . println ( ""charA address: "" + System . identityHashCode ( charA ) ) ; System . out . println ( ""charB address: "" + System . identityHashCode ( charB ) ) ; System . out . println ( ""subA1 address: "" + System . identityHashCode ( subA1 ) ) ; System . out . println ( ""subA2 address: "" + System . identityHashCode ( subA2 ) ) ; System . out . println ( ""charA == charB: "" + ( charA == charB ) ) ; System . out . println ( ""charA == subA1: "" + ( charA == subA1 ) ) ; System . out . println ( ""charA == subA2: "" + ( charA == subA2 ) ) ; }"
1299,void main ( String args [ ] ) { Object sharedObject = new Object ( ) ; MyClass sampleA = new MyClass ( ) ; sampleA . myObject = sharedObject ; MyClass sampleB = new MyClass ( ) ; sampleB . myObject = sharedObject ; System . out . println ( sampleA . sharedObject == sampleB . sharedObject ) ; System . out . println ( sampleA == sampleB ) ; }
1300,"void main ( String [ ] args ) { System . out . println ( ""Enter Number to convert into words"" ) ; Scanner sc = new Scanner ( System . in ) ; long num = sc . nextInt ( ) ; int rem = 0 ; int i = 0 ; while ( num > 0 ) { if ( i == 0 ) { rem = ( int ) ( num % 1000 ) ; printText ( rem ) ; num = num / 1000 ; i ++ ; } else if ( num > 0 ) { rem = ( int ) ( num % 100 ) ; if ( rem > 0 ) text = denom . values ( ) [ i - 1 ] + "" "" + text ; printText ( rem ) ; num = num / 100 ; i ++ ; } } if ( i > 0 ) System . out . println ( text ) ; else System . out . println ( ""Zero"" ) ; }"
1301,"void main ( String ... args ) { processor = new DefaultProcessor ( ) ; long [ ] values = new long [ ] { 0 , 4 , 10 , 12 , 100 , 108 , 299 , 1000 , 1003 , 2040 , 45213 , 100000 , 100005 , 100010 , 202020 , 202022 , 999999 , 1000000 , 1000001 , 10000000 , 10000007 , 99999999 , Long . MAX_VALUE , Long . MIN_VALUE } ; String [ ] strValues = new String [ ] { ""0"" , ""1.30"" , ""0001.00"" , ""3.141592"" } ; for ( long val : values ) { System . out . println ( val + "" = "" + processor . getName ( val ) ) ; } for ( String strVal : strValues ) { System . out . println ( strVal + "" = "" + processor . getName ( strVal ) ) ; } StringBuilder bigNumber = new StringBuilder ( ) ; for ( int d = 0 ; d < 66 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } bigNumber . append ( ""."" ) ; for ( int d = 0 ; d < 26 ; d ++ ) { bigNumber . append ( ( char ) ( ( Math . random ( ) * 10 ) + '0' ) ) ; } System . out . println ( bigNumber . toString ( ) + "" = "" + processor . getName ( bigNumber . toString ( ) ) ) ; }"
1302,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1303,"void transform ( Integer hash , HSSFCellStyle styleOld , XSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( styleOld . getFont ( this . workbookOld ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
1304,"boolean isAnagram ( String a , String b ) { a = a . toLowerCase ( ) ; b = b . toLowerCase ( ) ; if ( a . length ( ) != b . length ( ) ) { return false ; } char [ ] chars = a . toCharArray ( ) ; for ( char c : chars ) { int index = b . indexOf ( c ) ; if ( index != - 1 ) { b = b . substring ( 0 , index ) + b . substring ( index + 1 , b . length ( ) ) ; } else { return false ; } } return b . isEmpty ( ) ; }"
1305,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int n = s1 . length ( ) ; int [ ] charMap = new int [ 256 ] ; for ( int i = 0 ; i < n ; i ++ ) { char c1 = s1 . charAt ( i ) ; charMap [ c1 ] ++ ; char c2 = s2 . charAt ( i ) ; charMap [ c2 ] -- ; } for ( int i = 0 ; i < charMap . length ; i ++ ) { if ( charMap [ i ] != 0 ) return false ; } return true ; }"
1306,"void drawTable ( PDPage page , PDPageContentStream contentStream , float y , float margin , String [ ] [ ] content ) throws IOException { final int rows = content . length ; final int cols = content [ 0 ] . length ; final float rowHeight = 20f ; final float tableWidth = page . getCropBox ( ) . getWidth ( ) - margin - margin ; final float tableHeight = rowHeight * rows ; final float colWidth = tableWidth / ( float ) cols ; final float cellMargin = 5f ; float nexty = y ; for ( int i = 0 ; i <= rows ; i ++ ) { contentStream . drawLine ( margin , nexty , margin + tableWidth , nexty ) ; nexty -= rowHeight ; } float nextx = margin ; for ( int i = 0 ; i <= cols ; i ++ ) { contentStream . drawLine ( nextx , y , nextx , y - tableHeight ) ; nextx += colWidth ; } contentStream . setFont ( PDType1Font . HELVETICA_BOLD , 12 ) ; float textx = margin + cellMargin ; float texty = y - 15 ; for ( int i = 0 ; i < content . length ; i ++ ) { for ( int j = 0 ; j < content [ i ] . length ; j ++ ) { String text = content [ i ] [ j ] ; contentStream . beginText ( ) ; contentStream . moveTextPositionByAmount ( textx , texty ) ; contentStream . drawString ( text ) ; contentStream . endText ( ) ; textx += colWidth ; } texty -= rowHeight ; textx = margin + cellMargin ; } }"
1307,"void drawTable ( PDPage page , PDPageContentStream contentStream ) { try { float y = 650 ; float margin = 130 ; String [ ] content = { ""One"" , ""Two"" , ""Date"" , ""Score"" , ""Score2"" , ""Score3"" , ""Score4"" , ""Score5"" , ""Score6"" } ; final int rows = content . length ; final int cols = 2 ; final float rowHeight = 22f ; final float tableWidth = 900.0f ; final float tableHeight = rowHeight * rows ; final float cellMargin = 1f ; float nexty = y ; for ( int i = 0 ; i <= rows ; i ++ ) { contentStream . drawLine ( margin , nexty , 400 , nexty ) ; nexty -= rowHeight ; } float colWidthX [ ] = { 200 , 70 , 0 } ; float nextx = margin ; for ( int i = 0 ; i <= cols ; i ++ ) { contentStream . drawLine ( nextx , y , nextx , y - tableHeight ) ; nextx += colWidthX [ i ] ; } float textx = margin + cellMargin ; float texty = y - 15 ; for ( int j = 0 ; j < rows ; j ++ ) { contentStream . beginText ( ) ; contentStream . moveTextPositionByAmount ( textx , texty ) ; contentStream . drawString ( content [ j ] ) ; contentStream . endText ( ) ; textx += colWidthX [ 0 ] + 9 ; contentStream . beginText ( ) ; contentStream . moveTextPositionByAmount ( textx , texty ) ; if ( j == 0 ) contentStream . drawString ( ""1"" ) ; if ( j == 1 ) contentStream . drawString ( ""12345"" ) ; if ( j == 2 ) contentStream . drawString ( ""05-December-2003"" ) ; if ( j == 3 ) contentStream . drawString ( ""15"" ) ; if ( j == 4 ) contentStream . drawString ( ""1"" ) ; if ( j == 5 ) contentStream . drawString ( ""1"" ) ; if ( j == 6 ) contentStream . drawString ( ""1"" ) ; if ( j == 7 ) contentStream . drawString ( ""1"" ) ; if ( j == 8 ) contentStream . drawString ( ""1"" ) ; contentStream . endText ( ) ; textx = margin + cellMargin ; texty -= rowHeight ; } texty -= rowHeight ; textx = margin + cellMargin ; } catch ( IOException ioe ) { final String errormsg = ""Could not drawTable "" ; throw new RuntimeException ( errormsg , ioe ) ; } catch ( Exception ex ) { final String errormsg = ""Could not drawTable "" ; throw new RuntimeException ( errormsg , ex ) ; } }"
1308,"void main ( String [ ] args ) throws IOException { String ch ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter the Statement:"" ) ; ch = br . readLine ( ) ; int count = 0 , len = 0 ; do { try { char name [ ] = ch . toCharArray ( ) ; len = name . length ; count = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( ( name [ 0 ] == name [ j ] ) && ( ( name [ 0 ] >= 65 && name [ 0 ] <= 91 ) || ( name [ 0 ] >= 97 && name [ 0 ] <= 123 ) ) ) count ++ ; } if ( count != 0 ) System . out . println ( name [ 0 ] + "" "" + count + "" Times"" ) ; ch = ch . replace ( """" + name [ 0 ] , """" ) ; } catch ( Exception ex ) { } } while ( len != 1 ) ; }"
1309,"void main ( String [ ] args ) { String name = ""AnuvratAnuvra"" ; char [ ] arr = name . toCharArray ( ) ; HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char val : arr ) { map . put ( val , map . containsKey ( val ) ? map . get ( val ) + 1 : 1 ) ; } for ( Entry < Character , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { Character key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; System . out . println ( key + "":"" + value ) ; } } }"
1310,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
1311,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1312,boolean haveThree ( int [ ] nums ) { int count = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] == 3 && nums [ i + 1 ] == 3 ) { return false ; } if ( ( nums [ i ] == 3 ) ) { count ++ ; } } if ( nums [ nums . length - 1 ] == 3 ) { count ++ ; } return count == 3 ; }
1313,boolean haveThree ( int [ ] nums ) { int count = 0 ; boolean flag = false ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 3 ) { if ( flag ) { return false ; } else { count ++ ; flag = true ; } } else { flag = false ; } } return count == 3 ; }
1314,"String startOz ( String str ) { if ( str != null ) { char [ ] arr = str . toLowerCase ( ) . toCharArray ( ) ; boolean oTest = arr . length >= 1 && arr [ 0 ] == 'o' ; boolean zTest = arr . length >= 2 && arr [ 1 ] == 'z' ; if ( oTest && zTest ) { return ""oz"" ; } else if ( oTest ) { return ""o"" ; } else if ( zTest ) { return ""z"" ; } } return """" ; }"
1315,"String startOz ( String str ) { int len = str . length ( ) ; if ( len < 1 ) return new String ( """" ) ; if ( len > 1 && str . charAt ( 0 ) == 'o' && str . charAt ( 1 ) == 'z' ) return new String ( ""oz"" ) ; if ( str . charAt ( 0 ) == 'o' ) return new String ( ""o"" ) ; if ( str . charAt ( 1 ) == 'z' ) return new String ( ""z"" ) ; return new String ( """" ) ; }"
1316,"int [ ] solution ( String S , int [ ] P , int [ ] K ) { char [ ] sc = S . toCharArray ( ) ; int [ ] A = new int [ sc . length ] ; int [ ] G = new int [ sc . length ] ; int [ ] C = new int [ sc . length ] ; int prevA = - 1 , prevG = - 1 , prevC = - 1 ; for ( int i = 0 ; i < sc . length ; i ++ ) { if ( sc [ i ] == 'A' ) prevA = i ; else if ( sc [ i ] == 'G' ) prevG = i ; else if ( sc [ i ] == 'C' ) prevC = i ; A [ i ] = prevA ; G [ i ] = prevG ; C [ i ] = prevC ; } int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { if ( A [ K [ i ] ] >= P [ i ] && A [ K [ i ] ] <= K [ i ] ) { result [ i ] = 1 ; } else if ( C [ K [ i ] ] >= P [ i ] && C [ K [ i ] ] <= K [ i ] ) { result [ i ] = 2 ; } else if ( G [ K [ i ] ] >= P [ i ] && G [ K [ i ] ] <= K [ i ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } return result ; }"
1317,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] arr = new int [ S . length ( ) ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : arr [ i ] = 1 ; break ; case 'C' : arr [ i ] = 2 ; break ; case 'G' : arr [ i ] = 3 ; break ; case 'T' : arr [ i ] = 4 ; break ; default : break ; } } segmentNode root = buildTree ( arr , 0 , S . length ( ) - 1 ) ; int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { result [ i ] = getMin ( root , P [ i ] , Q [ i ] ) ; } return result ; }"
1318,"int getRandomNumberBetween ( int min , int max ) { Random foo = new Random ( ) ; int randomNumber = foo . nextInt ( max - min ) + min ; if ( randomNumber == min ) { return min + 1 ; } else { return randomNumber ; } }"
1319,"float getRandomNumberBetween ( float numberOne , float numberTwo ) throws Exception { if ( numberOne == numberTwo ) { throw new Exception ( ""Both the numbers can not be equal"" ) ; } float rand = ( float ) Math . random ( ) ; float highRange = Math . max ( numberOne , numberTwo ) ; float lowRange = Math . min ( numberOne , numberTwo ) ; float lowRand = ( float ) Math . floor ( rand - 1 ) ; float highRand = ( float ) Math . ceil ( rand + 1 ) ; float genRand = ( highRange - lowRange ) * ( ( rand - lowRand ) / ( highRand - lowRand ) ) + lowRange ; return genRand ; }"
1320,"int pow ( int a , int p ) { int res = 1 ; int i1 = 31 - Integer . numberOfLeadingZeros ( p ) ; for ( int i = i1 ; i >= 0 ; -- i ) { res *= res ; if ( ( p & ( 1 << i ) ) > 0 ) res *= a ; } return res ; }"
1321,"long pow ( long a , int b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; if ( isEven ( b ) ) return pow ( a * a , b / 2 ) ; else return a * pow ( a * a , b / 2 ) ; }"
1322,"void replaceText ( int start , int end , String text ) { if ( ! characters . equals ( """" ) ) { if ( validateCh ( text ) ) { text = check ( text ) ; super . replaceText ( start , end , text ) ; if ( max > 0 ) verifyLengh ( ) ; } } else { text = check ( text ) ; super . replaceText ( start , end , text ) ; if ( max > 0 ) verifyLengh ( ) ; } }"
1323,"void replaceText ( int start , int end , String text ) { String oldValue = getText ( ) ; if ( ! text . matches ( ""[A-Za-z]"" ) && ! text . matches ( ""[\\\\!\""#$%&()*+,./:;<=>?@\\[\\]^_{|}~]+"" ) ) { super . replaceText ( start , end , text ) ; } if ( getText ( ) . length ( ) > 2 ) { setText ( oldValue ) ; } }"
1324,"void main ( String [ ] args ) throws Exception { Experius a = new Experius ( ) ; int count = 10000000 ; int v = 0 ; long tm = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < count ; ++ i ) { v = a . something ( i + v ) ; ++ v ; } tm = System . currentTimeMillis ( ) - tm ; System . out . println ( ""Time: "" + tm ) ; tm = System . currentTimeMillis ( ) ; Method method = Experius . class . getMethod ( ""something"" , Integer . TYPE ) ; for ( int i = 0 ; i < count ; ++ i ) { Object o = method . invoke ( a , i + v ) ; ++ v ; } tm = System . currentTimeMillis ( ) - tm ; System . out . println ( ""Time: "" + tm ) ; }"
1325,"void main ( String [ ] args ) throws Exception { int loops = 1000 * 1000 ; Object object = new Object ( ) ; long start = System . nanoTime ( ) ; Object s ; testMethodCall ( object , loops ) ; long regularCalls = System . nanoTime ( ) - start ; java . lang . reflect . Method method = Object . class . getMethod ( ""getClass"" ) ; method . setAccessible ( true ) ; start = System . nanoTime ( ) ; testInvoke ( object , loops , method ) ; long reflectiveCalls = System . nanoTime ( ) - start ; start = System . nanoTime ( ) ; testGetMethodInvoke ( object , loops ) ; long reflectiveLookup = System . nanoTime ( ) - start ; System . out . println ( ""Average regular method calls:"" + regularCalls / loops + "" ns."" ) ; System . out . println ( ""Average reflective method calls without lookup:"" + reflectiveCalls / loops + "" ns."" ) ; System . out . println ( ""Average reflective method calls with lookup:"" + reflectiveLookup / loops + "" ns."" ) ; }"
1326,"void main ( String [ ] args ) { Calendar calendar = Calendar . getInstance ( ) ; int countFirstSunday = 0 ; for ( int year = 1901 ; year <= 2000 ; year ++ ) { for ( int month = 0 ; month <= 11 ; month ++ ) { calendar . set ( year , month , 1 ) ; if ( calendar . get ( Calendar . DAY_OF_WEEK ) == Calendar . SUNDAY ) { countFirstSunday ++ ; } } } System . out . println ( ""Sundays as the first of month: "" + countFirstSunday ) ; }"
1327,"void main ( String [ ] args ) { final int ThirtyOne = 31 ; final int Thirty = 30 ; final int FebNorm = 28 ; final int FebLeap = 29 ; int numOfSundays = 0 ; int calendar [ ] [ ] = new int [ 12 ] [ ] ; calendar [ 0 ] = new int [ ThirtyOne ] ; calendar [ 1 ] = new int [ FebLeap ] ; calendar [ 2 ] = new int [ ThirtyOne ] ; calendar [ 3 ] = new int [ Thirty ] ; calendar [ 4 ] = new int [ ThirtyOne ] ; calendar [ 5 ] = new int [ Thirty ] ; calendar [ 6 ] = new int [ ThirtyOne ] ; calendar [ 7 ] = new int [ ThirtyOne ] ; calendar [ 8 ] = new int [ Thirty ] ; calendar [ 9 ] = new int [ ThirtyOne ] ; calendar [ 10 ] = new int [ Thirty ] ; calendar [ 11 ] = new int [ ThirtyOne ] ; int dayOfWeek = 1 ; for ( int year = 1900 ; year < 2001 ; year ++ ) { for ( int month = 0 ; month < calendar . length ; month ++ ) { int dayOfMonth = 0 ; int daysInMonth ; if ( month == 1 ) { daysInMonth = isLeapYear ( year ) ? FebLeap : FebNorm ; } else { daysInMonth = calendar [ month ] . length ; } while ( dayOfWeek < 8 && dayOfMonth < daysInMonth ) { System . out . println ( ""year: "" + year + ""\tday: "" + dayOfWeek + ""\tcalendar["" + month + ""]["" + dayOfMonth + ""]: "" + calendar [ month ] [ dayOfMonth ] ) ; if ( dayOfWeek == 7 && year > 1900 ) { calendar [ month ] [ dayOfMonth ] ++ ; if ( dayOfMonth == 0 ) { numOfSundays ++ ; } } dayOfMonth ++ ; dayOfWeek ++ ; if ( dayOfWeek > 7 ) { dayOfWeek = 1 ; } } } } for ( int month = 0 ; month < calendar . length ; month ++ ) { System . out . println ( calendar [ month ] [ 0 ] ) ; } System . out . println ( numOfSundays ) ; }"
1328,"byte [ ] readData ( File f , int startByte , int chunkSize ) throws Exception { RandomAccessFile raf = new RandomAccessFile ( f , ""r"" ) ; raf . seek ( startByte ) ; byte [ ] data = new byte [ chunkSize ] ; int bytesRead = raf . read ( data ) ; if ( bytesRead != chunkSize ) { byte [ ] smallerData = new byte [ bytesRead ] ; System . arraycopy ( data , 0 , smallerData , 0 , bytesRead ) ; data = smallerData ; } raf . close ( ) ; return data ; }"
1329,"byte [ ] readData ( File f , int startByte , int chunkSize ) throws Exception { RandomAccessFile raf = new RandomAccessFile ( f , ""r"" ) ; raf . seek ( startByte ) ; byte [ ] data = new byte [ chunkSize ] ; int read = raf . read ( data ) ; raf . close ( ) ; if ( read == data . length ) return data ; else return Arrays . copyOf ( data , read ) ; }"
1330,"void main ( String [ ] args ) { String pass = ""admin"" ; Scanner input = new Scanner ( System . in ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . print ( ""Insert the admin pass: "" ) ; String test = input . nextLine ( ) ; if ( pass . equals ( test ) ) { System . out . print ( ""Access granted"" ) ; i = 3 ; } else { System . out . println ( ""Incorrect password, you have "" + ( 2 - i ) + "" attempts remaining"" ) ; } } }"
1331,"void main ( String [ ] args ) { String pass = ""admin"" ; Scanner input = new Scanner ( System . in ) ; System . out . print ( ""Insert the admin pass: "" ) ; String test = input . nextLine ( ) ; if ( pass . equals ( test ) ) { System . out . print ( ""Access granted"" ) ; } else { for ( int i = 1 ; i < 3 ; i ++ ) { System . out . print ( ""You have "" + i + "" try(es): "" ) ; test = input . nextLine ( ) ; if ( pass . equals ( test ) ) { System . out . print ( ""Access granted"" ) ; break ; } else if ( i == 2 ) { System . out . print ( ""Access denied"" ) ; } } } }"
1332,"void main ( String [ ] args ) { String string = ""aaabbbbbaccc"" ; int counter ; String result = """" ; int i = 0 ; while ( i < string . length ( ) ) { counter = 1 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { System . out . println ( ""string length ="" + string . length ( ) ) ; if ( string . charAt ( i ) == string . charAt ( j ) ) { counter ++ ; } } result = result + string . charAt ( i ) + counter ; string = string . replaceAll ( String . valueOf ( string . charAt ( i ) ) , """" ) ; } System . out . println ( ""result is = "" + result ) ; }"
1333,"void main ( String [ ] args ) { String output = """" ; Multiset < String > wordsMultiset = HashMultiset . create ( ) ; String [ ] words = ""AAABBBBCC"" . split ( """" ) ; wordsMultiset . addAll ( Arrays . asList ( words ) ) ; for ( Entry < String > string : wordsMultiset . entrySet ( ) ) { if ( ! string . getElement ( ) . isEmpty ( ) ) output += string . getCount ( ) + """" + string . getElement ( ) ; } System . out . println ( output ) ; }"
1334,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
1335,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
1336,boolean hasLoop ( Node first ) { Node slow = first ; Node fast = first ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; }
1337,"boolean hasLoop ( Node root ) { if ( root == null ) return false ; Node slow = root , fast = root ; int taken = 0 , limit = 2 ; while ( fast . next != null ) { fast = fast . next ; taken ++ ; if ( slow == fast ) return true ; if ( taken == limit ) { taken = 0 ; limit <<= 1 ; slow = fast ; } } return false ; }"
1338,"Serializable generate ( SessionImplementor session , Object object ) throws HibernateException { String prefix = ""DEP"" ; Connection connection = session . connection ( ) ; try { Statement statement = connection . createStatement ( ) ; ResultSet rs = statement . executeQuery ( ""select count(Department_Id) as Id from demo.Department"" ) ; if ( rs . next ( ) ) { int id = rs . getInt ( 1 ) + 101 ; String generatedId = prefix + new Integer ( id ) . toString ( ) ; System . out . println ( ""Generated Id: "" + generatedId ) ; return generatedId ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return null ; }"
1339,"Serializable generate ( SessionImplementor session , Object object ) throws HibernateException { Serializable result = null ; Connection connection = null ; Statement statement = null ; ResultSet resultSet = null ; String prefix = ""emp"" ; try { connection = session . connection ( ) ; statement = connection . createStatement ( ) ; try { resultSet = statement . executeQuery ( ""SELECT next_val FROM  "" + DEFAULT_SEQUENCE_NAME ) ; } catch ( Exception e ) { System . out . println ( ""In catch, cause : Table is not available."" ) ; statement . execute ( ""CREATE table "" + DEFAULT_SEQUENCE_NAME + "" (next_val INT NOT NULL)"" ) ; statement . executeUpdate ( ""INSERT INTO "" + DEFAULT_SEQUENCE_NAME + "" VALUES(0)"" ) ; statement . executeUpdate ( ""UPDATE "" + DEFAULT_SEQUENCE_NAME + "" SET next_val=LAST_INSERT_ID(next_val+1)"" ) ; resultSet = statement . executeQuery ( ""SELECT next_val FROM  "" + DEFAULT_SEQUENCE_NAME ) ; } if ( resultSet . next ( ) ) { int nextValue = resultSet . getInt ( 1 ) ; String suffix = String . format ( ""%04d"" , nextValue ) ; result = prefix . concat ( suffix ) ; System . out . println ( ""Custom generated sequence is : "" + result ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return result ; }"
1340,"int findArray ( int [ ] array , int [ ] subArray ) { int count = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = 0 ; j < subArray . length ; j ++ ) { if ( array [ i ] == subArray [ j ] ) { if ( array . length > ( i + 1 ) && subArray . length > ( j + 1 ) ) { if ( array [ i + 1 ] == subArray [ j + 1 ] ) { count += 1 ; continue ; } } else if ( subArray . length == j + 1 ) { count += 1 ; continue ; } } } } if ( count < subArray . length ) { return - 1 ; } return count ; }"
1341,"int findArray ( int [ ] array , int [ ] subArray ) { int index = - 1 ; arrayLoop : for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == subArray [ 0 ] ) { for ( int j = 1 ; j < subArray . length ; j ++ ) { if ( i + j > array . length - 1 || array [ i + j ] != subArray [ j ] ) continue arrayLoop ; } index = i ; } } return index ; }"
1342,"String validName ( Scanner input , Scanner histogram ) { HashSet < String > validInputs = new HashSet < > ( ) ; while ( histogram . hasNext ( ) ) validInputs . add ( histogram . next ( ) ) ; while ( true ) { String userInput = input . next ( ) ; if ( validInputs . contains ( userInput ) ) return userInput ; System . out . println ( ""invalid input"" ) ; } }"
1343,"String validName ( Scanner input , Scanner histogram ) { String user = """" ; String name = input . next ( ) ; String tmp = """" ; boolean test = false ; while ( histogram . hasNext ( ) ) { user = histogram . next ( ) ; tmp += user + "" "" ; if ( name . equalsIgnoreCase ( user ) ) { test = true ; break ; } else { test = false ; } } if ( ! test ) { System . out . println ( ""Name not found"" ) ; user = validName ( input , new Scanner ( tmp ) ) ; } return user ; }"
1344,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int exes = 0 ; int whys = 0 ; while ( scan . hasNext ( ) ) { String line = scan . next ( ) ; if ( line . equals ( ""x="" ) ) exes += scan . nextInt ( ) ; else whys += scan . nextInt ( ) ; } System . out . println ( ""X: "" + exes ) ; System . out . println ( ""Y: "" + whys ) ; }"
1345,"void main ( String [ ] args ) throws IOException { FileReader file = new FileReader ( ""D:\\Test.txt"" ) ; BufferedReader br = new BufferedReader ( file ) ; String str ; int xSum = 0 ; int ySum = 0 ; while ( ( str = br . readLine ( ) ) != null ) { if ( str . contains ( ""x="" ) ) { xSum += Integer . parseInt ( str . split ( ""="" ) [ 1 ] . trim ( ) ) ; } if ( str . contains ( ""y="" ) ) { ySum += Integer . parseInt ( str . split ( ""="" ) [ 1 ] . trim ( ) ) ; } } System . out . println ( ""Sum x is: "" + xSum + "" Sum y is: "" + ySum ) ; }"
1346,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1347,"XSSFFont transform ( XSSFWorkbook workbookNew , HSSFFont fontOld ) { XSSFFont fontNew = workbookNew . createFont ( ) ; fontNew . setBoldweight ( fontOld . getBoldweight ( ) ) ; fontNew . setCharSet ( fontOld . getCharSet ( ) ) ; fontNew . setColor ( fontOld . getColor ( ) ) ; fontNew . setFontName ( fontOld . getFontName ( ) ) ; fontNew . setFontHeight ( fontOld . getFontHeight ( ) ) ; fontNew . setItalic ( fontOld . getItalic ( ) ) ; fontNew . setStrikeout ( fontOld . getStrikeout ( ) ) ; fontNew . setTypeOffset ( fontOld . getTypeOffset ( ) ) ; fontNew . setUnderline ( fontOld . getUnderline ( ) ) ; return fontNew ; }"
1348,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1349,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
1350,"void main ( String [ ] args ) { Scanner myScanner ; myScanner = new Scanner ( System . in ) ; double mon , tues , wed , thurs , fri , sat , sun ; do { try { System . out . print ( ""Expenses for Monday: "" ) ; mon = myScanner . nextDouble ( ) ; } catch ( Exception e ) { mon = - 1 ; myScanner . nextLine ( ) ; } } while ( mon < 0 ) ; System . out . println ( mon ) ; }"
1351,"void main ( String args [ ] ) { Scanner myScanner = new Scanner ( System . in ) ; double mon = getExpensesForDay ( myScanner , ""Monday"" ) ; double tues = getExpensesForDay ( myScanner , ""Tuesday"" ) ; double wed = getExpensesForDay ( myScanner , ""Wednesday"" ) ; double thurs = getExpensesForDay ( myScanner , ""Thursday"" ) ; double fri = getExpensesForDay ( myScanner , ""Friday"" ) ; double sat = getExpensesForDay ( myScanner , ""Saturday"" ) ; double sun = getExpensesForDay ( myScanner , ""Sunday"" ) ; }"
1352,void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == select ) { activeTool = SELECTION_TOOL ; } else if ( ae . getSource ( ) == draw ) { activeTool = DRAW_TOOL ; } else if ( ae . getSource ( ) == text ) { activeTool = TEXT_TOOL ; } }
1353,"void actionPerformed ( ActionEvent e ) { JFileChooser ch = getFileChooser ( ) ; int result = ch . showSaveDialog ( gui ) ; if ( result == JFileChooser . APPROVE_OPTION ) { try { File f = ch . getSelectedFile ( ) ; ImageIO . write ( BasicPaint . this . canvasImage , ""png"" , f ) ; BasicPaint . this . originalImage = BasicPaint . this . canvasImage ; dirty = false ; } catch ( IOException ioe ) { showError ( ioe ) ; ioe . printStackTrace ( ) ; } } }"
1354,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { final char [ ] characterInput = S . toCharArray ( ) ; final int [ ] integerInput = new int [ characterInput . length ] ; for ( int counter = 0 ; counter < characterInput . length ; counter ++ ) { integerInput [ counter ] = characterMapping . get ( characterInput [ counter ] ) ; } int [ ] result = new int [ P . length ] ; for ( int index = 0 ; index < P . length ; index ++ ) { if ( P [ index ] == Q [ index ] ) { result [ index ] = integerInput [ P [ index ] ] ; break ; } final int [ ] subArray = Arrays . copyOfRange ( integerInput , P [ index ] , Q [ index ] + 1 ) ; final int minimumValue = minimum ( subArray ) ; result [ index ] = minimumValue ; } return result ; }"
1355,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] result = new int [ P . length ] ; int [ ] factor1 = new int [ S . length ( ) ] ; int [ ] factor2 = new int [ S . length ( ) ] ; int [ ] factor3 = new int [ S . length ( ) ] ; int [ ] factor4 = new int [ S . length ( ) ] ; int factor1Sum = 0 ; int factor2Sum = 0 ; int factor3Sum = 0 ; int factor4Sum = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : factor1Sum ++ ; break ; case 'C' : factor2Sum ++ ; break ; case 'G' : factor3Sum ++ ; break ; case 'T' : factor4Sum ++ ; break ; default : break ; } factor1 [ i ] = factor1Sum ; factor2 [ i ] = factor2Sum ; factor3 [ i ] = factor3Sum ; factor4 [ i ] = factor4Sum ; } for ( int i = 0 ; i < P . length ; i ++ ) { int start = P [ i ] ; int end = Q [ i ] ; if ( start == 0 ) { if ( factor1 [ end ] > 0 ) { result [ i ] = 1 ; } else if ( factor2 [ end ] > 0 ) { result [ i ] = 2 ; } else if ( factor3 [ end ] > 0 ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } else { if ( factor1 [ end ] > factor1 [ start - 1 ] ) { result [ i ] = 1 ; } else if ( factor2 [ end ] > factor2 [ start - 1 ] ) { result [ i ] = 2 ; } else if ( factor3 [ end ] > factor3 [ start - 1 ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } } return result ; }"
1356,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1357,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , HSSFSheet sheetOld , XSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; XSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( HSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1358,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
1359,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
1360,"void main ( String [ ] args ) { int number1 , number2 , sum ; Scanner input = new Scanner ( System . in ) ; System . out . println ( ""Enter First multiple"" ) ; number1 = input . nextInt ( ) ; System . out . println ( ""Enter second multiple"" ) ; number2 = input . nextInt ( ) ; sum = number1 * number2 ; System . out . printf ( ""The product of both number is %d"" , sum ) ; }"
1361,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; final int valid = 6 ; Scanner one = new Scanner ( System . in ) ; System . out . println ( ""Enter your username: "" ) ; String s = one . nextLine ( ) ; if ( s . length ( ) < valid ) { System . out . println ( ""Enter a valid username"" ) ; System . out . println ( ""User name must contain "" + valid + "" characters"" ) ; System . out . println ( ""Enter again: "" ) ; s = one . nextLine ( ) ; } System . out . println ( ""Username accepted: "" + s ) ; Scanner two = new Scanner ( System . in ) ; System . out . println ( ""Enter your age: "" ) ; int a = two . nextInt ( ) ; System . out . println ( ""Age accepted: "" + a ) ; Scanner three = new Scanner ( System . in ) ; System . out . println ( ""Enter your sex: "" ) ; String sex = three . nextLine ( ) ; System . out . println ( ""Sex accepted: "" + sex ) ; }"
1362,"void main ( String args [ ] ) { String s = ""1234"" ; int len = s . length ( ) ; int num = Integer . parseInt ( s ) ; int mod ; int od = 0 , even = 0 ; for ( int i = 0 ; i < len ; i ++ ) { mod = num % 10 ; num = num / 10 ; if ( mod % 2 == 0 ) { even = even + mod ; } else { od = od + mod ; } } System . out . println ( ""Sum of even numbers is "" + even ) ; System . out . println ( ""Sum of odd numbers is "" + od ) ; }"
1363,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; String number = """" ; int a = 0 , total = 0 ; boolean even = false ; System . out . println ( ""Enter a number"" ) ; number = input . nextLine ( ) ; for ( int counter = 0 ; counter < number . length ( ) ; counter ++ ) { a = Integer . parseInt ( number . substring ( counter , counter + 1 ) ) ; if ( a % 2 != 0 || a == 1 ) { even = false ; total += a ; } } System . out . println ( ""The sum is "" + total ) ; }"
1364,"void run ( ) { count ++ ; if ( Thread . currentThread ( ) . getName ( ) . compareTo ( ""one"" ) == 0 ) { synchronized ( a . class ) { try { for ( int i = 0 ; i < 5 ; i ++ ) { while ( time . equals ( ""Tock"" ) ) { a . class . wait ( ) ; } System . out . println ( ""Now running thread "" + Thread . currentThread ( ) . getName ( ) + "" with count "" + count ) ; time = ""Tock"" ; System . out . println ( time ) ; a . class . notify ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } else if ( Thread . currentThread ( ) . getName ( ) . compareTo ( ""two"" ) == 0 ) { synchronized ( a . class ) { try { for ( int j = 0 ; j < 5 ; j ++ ) { while ( time . equals ( ""Tick"" ) ) { a . class . wait ( ) ; } System . out . println ( ""Now running thread "" + Thread . currentThread ( ) . getName ( ) + "" with count "" + count ) ; time = ""Tick"" ; System . out . println ( time ) ; a . class . notify ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } }"
1365,"void run ( ) { try { synchronized ( lock ) { for ( int i = 0 ; i < 5 ; i ++ ) { while ( id != token % N ) lock . wait ( ) ; System . out . println ( id + "" "" + i ) ; token ++ ; lock . notifyAll ( ) ; } } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }"
1366,"void main ( String [ ] args ) throws Exception { Class unsafeClass = Class . forName ( ""sun.misc.Unsafe"" ) ; Field f = unsafeClass . getDeclaredField ( ""theUnsafe"" ) ; f . setAccessible ( true ) ; Unsafe unsafe = ( Unsafe ) f . get ( null ) ; System . out . print ( ""4..3..2..1..."" ) ; try { for ( ; ; ) unsafe . allocateMemory ( 1024 * 1024 ) ; } catch ( Error e ) { System . out . println ( ""Boom :)"" ) ; e . printStackTrace ( ) ; } }"
1367,"void main ( String [ ] args ) throws IOException { ZipOutputStream zos = new ZipOutputStream ( new FileOutputStream ( new File ( ""big.jar"" ) ) ) ; zos . putNextEntry ( new ZipEntry ( ""resource.txt"" ) ) ; zos . write ( ""not too much in here"" . getBytes ( ) ) ; zos . closeEntry ( ) ; zos . putNextEntry ( new ZipEntry ( ""largeFile.out"" ) ) ; for ( int i = 0 ; i < 10000000 ; i ++ ) { zos . write ( ( int ) ( Math . round ( Math . random ( ) * 100 ) + 20 ) ) ; } zos . closeEntry ( ) ; zos . close ( ) ; }"
1368,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
1369,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
1370,"void main ( String [ ] args ) { char [ ] values = { 'a' , 'b' , 'c' , 'd' } ; int n = values . length ; int r = 2 ; int i = 0 , j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { System . out . println ( values [ j ] + "" "" + values [ i ] ) ; } } }"
1371,"void main ( String [ ] args ) { char [ ] values = { 'a' , 'b' , 'c' , 'd' } ; int n = values . length ; int r = 2 ; int i [ ] = new int [ r ] ; int rc = 0 ; for ( int j = 0 ; j < Math . pow ( n , r ) ; j ++ ) { rc = 0 ; while ( rc < r ) { System . out . print ( values [ i [ rc ] ] + "" "" ) ; rc ++ ; } System . out . println ( ) ; rc = 0 ; while ( rc < r ) { if ( i [ rc ] < n - 1 ) { i [ rc ] ++ ; break ; } else { i [ rc ] = 0 ; } rc ++ ; } } }"
1372,void type ( char c ) { keyPress ( VK_ALT ) ; keyPress ( VK_NUMPAD0 ) ; keyRelease ( VK_NUMPAD0 ) ; String altCode = Integer . toString ( c ) ; for ( int i = 0 ; i < altCode . length ( ) ; i ++ ) { c = ( char ) ( altCode . charAt ( i ) + '0' ) ; keyPress ( c ) ; keyRelease ( c ) ; } keyRelease ( VK_ALT ) ; }
1373,void type ( String text ) { char c ; for ( int ii = 0 ; ii < text . length ( ) ; ii ++ ) { c = text . charAt ( ii ) ; if ( c <= 31 || c == 129 ) { pressControlKey ( c ) ; } else { typeAsciiCode ( c ) ; } } }
1374,"void rotate ( int [ ] array , int k ) { int size = array . length ; if ( size <= 1 ) return ; k = k % size ; if ( k == 0 ) return ; for ( int i = 0 , start = 0 , from = 0 , to = - 1 , move = array [ 0 ] ; i < size ; ++ i , from = to ) { to = ( from + k ) % size ; int temp = array [ to ] ; array [ to ] = move ; move = to == start ? array [ to = ++ start ] : temp ; } }"
1375,"int [ ] rotate ( int [ ] nums , int k ) { if ( k > nums . length ) k = k % nums . length ; int [ ] result = new int [ nums . length ] ; System . arraycopy ( nums , k + 1 , result , 0 , k ) ; System . arraycopy ( nums , 0 , result , k + 1 , nums . length - 1 ) ; nums = result ; return result ; }"
1376,void move ( ) { if ( x + xa > 0 && x + xa < game . getWidth ( ) - 30 ) x = x + xa ; if ( y + ya > 0 && y + ya < game . getHeight ( ) - 60 ) { for ( int i = 12 ; i < 0 ; i -- ) ; ya += 10 ; y = y + ya ; } if ( collision ( ) ) { y -= 10 ; onGround = true ; } Square . y += 10 ; }
1377,void move ( ) { y += ya ; x += xa ; if ( x < 0 ) { x = 0 ; } else if ( x + 30 > game . getWidth ( ) ) { x = game . getWidth ( ) - 30 ; } if ( y < 0 ) { y = 0 ; } else if ( collision ( ) ) { onGround = true ; y = game . ground . getBounds ( ) . y - d ; } }
1378,"void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; int [ ] wordCount = new int [ 1000 ] ; String [ ] wordList = new String [ 1000 ] ; int j = 0 ; while ( stdin . hasNextLine ( ) ) { String s = stdin . nextLine ( ) ; String [ ] words = s . split ( ""\\W+"" ) ; for ( String word : words ) { int listIndex = - 1 ; for ( int i = 0 ; i < wordList . length ; i ++ ) { if ( word . equals ( wordList [ i ] ) ) { listIndex = i ; } } if ( listIndex > - 1 ) { wordCount [ listIndex ] ++ ; } else { wordList [ j ] = word ; wordCount [ j ] ++ ; j ++ ; } } for ( int i = 0 ; i < j ; i ++ ) { System . out . println ( ""the word: "" + wordList [ i ] + "" occured "" + wordCount [ i ] + "" time(s)."" ) ; } } }"
1379,"void main ( String [ ] args ) { Scanner stdin = new Scanner ( System . in ) ; String [ ] wordArray = new String [ 10000 ] ; int [ ] wordCount = new int [ 10000 ] ; int numWords = 0 ; while ( stdin . hasNextLine ( ) ) { String s = stdin . nextLine ( ) ; ArrayList < String > noDuplicated = new ArrayList < String > ( ) ; String [ ] words = s . replaceAll ( ""[^a-zA-Z ]"" , """" ) . toLowerCase ( ) . split ( ""\\s+"" ) ; for ( int i = 0 ; i < words . length ; i ++ ) { if ( ! noDuplicated . contains ( words [ i ] ) ) noDuplicated . add ( words [ i ] ) ; } for ( int i = 0 ; i < noDuplicated . size ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < words . length ; j ++ ) { if ( noDuplicated . get ( i ) . equals ( words [ j ] ) ) count ++ ; } System . out . println ( ""word count: â "" + words [ i ] + "" "" + count ) ; } } }"
1380,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
1381,"int solution ( int X , int [ ] A ) { int list [ ] = A ; int sum = 0 ; int searchedValue = X ; int sumV = searchedValue * ( searchedValue + 1 ) / 2 ; List < Integer > arrayList = new ArrayList < Integer > ( ) ; for ( int iii = 0 ; iii < list . length ; iii ++ ) { if ( list [ iii ] <= searchedValue && ! arrayList . contains ( list [ iii ] ) ) { sum += list [ iii ] ; if ( sum == sumV ) { return iii ; } arrayList . add ( list [ iii ] ) ; } } return - 1 ; }"
1382,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
1383,"void run ( ) { int i = 3 ; while ( i < 50 ) { while ( s . getState ( ) != 2 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 2 ) System . out . println ( ""t3 "" + i ) ; i = i + 3 ; s . setState ( 3 ) ; s . notifyAll ( ) ; } } }"
1384,"String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ""("" ) ; sb . append ( a + "","" ) ; sb . append ( b + "","" ) ; sb . append ( v + "","" ) ; sb . append ( w + "","" ) ; sb . append ( m + "","" ) ; sb . append ( n ) ; sb . append ( "")"" ) ; return sb . toString ( ) ; }"
1385,"String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( a + ""\n"" ) ; sb . append ( b + ""\n"" ) ; for ( A elem : aList ) { sb . append ( elem + ""\n"" ) ; } return sb . toString ( ) ; }"
1386,int read ( ) throws IOException { if ( currentPos < currentLineEnd ) { in . seek ( currentPos ++ ) ; int readByte = in . readByte ( ) ; return readByte ; } else if ( currentPos < 0 ) { return - 1 ; } else { findPrevLine ( ) ; return read ( ) ; } }
1387,int read ( ) throws IOException { if ( currentPos < currentLineEnd ) { in . seek ( currentPos ++ ) ; int readByte = in . readByte ( ) ; return readByte ; } else if ( currentPos > lastPosInFile && currentLineStart < currentLineEnd ) { findPrevLine ( ) ; if ( lastChar != '\n' && lastChar != '\r' ) { return '\n' ; } else { return read ( ) ; } } else if ( currentPos < 0 ) { return - 1 ; } else { findPrevLine ( ) ; return read ( ) ; } }
1388,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
1389,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tac"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
1390,"void main ( String [ ] args ) { List < String > list = new ArrayList < String > ( ) ; list . add ( ""A"" ) ; list . add ( ""B"" ) ; list . add ( ""A"" ) ; list . add ( ""B"" ) ; list . add ( ""C"" ) ; list . add ( ""D"" ) ; Map < String , List < String > > map = getMap ( list ) ; printMapAsLists ( map ) ; }"
1391,"void main ( String args [ ] ) throws java . io . IOException { List < String > list = new ArrayList < String > ( ) ; list . add ( ""A"" ) ; list . add ( ""B"" ) ; list . add ( ""A"" ) ; list . add ( ""B"" ) ; list . add ( ""C"" ) ; list . add ( ""D"" ) ; Collections . sort ( list ) ; List < ArrayList < String > > arrays = new ArrayList < ArrayList < String > > ( ) ; int k = 0 ; for ( int i = 0 ; i < list . size ( ) ; ) { int count = Collections . frequency ( list , list . get ( i ) ) ; arrays . add ( new ArrayList < String > ( ) ) ; for ( int j = 0 ; j < count ; j ++ ) { arrays . get ( k ) . add ( list . get ( i ) ) ; } i += count ; k ++ ; } for ( ArrayList < String > arr : arrays ) { for ( String s : arr ) { System . out . print ( s + "" "" ) ; } System . out . println ( ) ; } }"
1392,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
1393,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
1394,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int number ; if ( """" . equals ( value ) ) { number = 0 ; } else if ( value . length ( ) > 4 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 4 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 1000 ; if ( number >= 100 ) { buffer . append ( unitProcessor . getName ( number / 100 ) ) ; buffer . append ( SEPARATOR ) ; buffer . append ( SCALE . getName ( EXPONENT ) ) ; } String tensName = tensProcessor . getName ( number % 100 ) ; if ( ! """" . equals ( tensName ) && ( number >= 100 ) ) { buffer . append ( SEPARATOR ) ; } buffer . append ( tensName ) ; return buffer . toString ( ) ; }"
1395,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1396,"void main ( String [ ] args ) { String string = ""check duplicate charcters in string"" ; string = string . toLowerCase ( ) ; char [ ] charAr = string . toCharArray ( ) ; Arrays . sort ( charAr ) ; for ( int i = 1 ; i < charAr . length ; ) { int count = recursiveMethod ( charAr , i , 1 ) ; if ( count > 1 ) { System . out . println ( ""'"" + charAr [ i ] + ""' comes "" + count + "" times"" ) ; i = i + count ; } else i ++ ; } }"
1397,"void main ( String [ ] args ) throws IOException { String ch ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . print ( ""Enter the Statement:"" ) ; ch = br . readLine ( ) ; int count = 0 , len = 0 ; do { try { char name [ ] = ch . toCharArray ( ) ; len = name . length ; count = 0 ; for ( int j = 0 ; j < len ; j ++ ) { if ( ( name [ 0 ] == name [ j ] ) && ( ( name [ 0 ] >= 65 && name [ 0 ] <= 91 ) || ( name [ 0 ] >= 97 && name [ 0 ] <= 123 ) ) ) count ++ ; } if ( count != 0 ) System . out . println ( name [ 0 ] + "" "" + count + "" Times"" ) ; ch = ch . replace ( """" + name [ 0 ] , """" ) ; } catch ( Exception ex ) { } } while ( len != 1 ) ; }"
1398,"void investigate ( Type t , Type ... typeArgs ) { if ( t == null ) return ; if ( t instanceof Class < ? > ) { investigate ( ( Class < ? > ) t , typeArgs ) ; } else if ( t instanceof ParameterizedType ) { investigate ( ( ParameterizedType ) t , typeArgs ) ; } }"
1399,"void investigate ( ParameterizedType p , Type ... typeArgs ) { final Class < ? > c = ( Class < ? > ) p . getRawType ( ) ; final StringBuilder b = new StringBuilder ( c . getName ( ) ) ; b . append ( '<' ) ; Type [ ] localArgs = p . getActualTypeArguments ( ) ; if ( typeArgs != null && typeArgs . length > 0 ) { int i = 0 , nextTypeArg = 0 ; for ( Type local : localArgs ) { if ( local instanceof ParameterizedType ) { ParameterizedType localP = ( ParameterizedType ) local ; b . append ( localP . getRawType ( ) ) . append ( '<' ) ; b . append ( typeArgs [ nextTypeArg ++ ] ) ; b . append ( '>' ) ; } else if ( local instanceof TypeVariable ) { localArgs [ nextTypeArg ] = typeArgs [ nextTypeArg ] ; b . append ( localArgs [ nextTypeArg ] ) ; nextTypeArg ++ ; } else { b . append ( local . toString ( ) ) ; } b . append ( "", "" ) ; i ++ ; } if ( typeArgs . length > 0 ) { b . delete ( b . length ( ) - 2 , b . length ( ) ) ; } b . append ( '>' ) ; } else { String args = Arrays . toString ( localArgs ) ; b . append ( args . substring ( 1 , args . length ( ) - 1 ) ) . append ( '>' ) ; } System . out . println ( b ) ; investigate ( c , localArgs ) ; }"
1400,"int gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }"
1401,"int gcd ( int a , int b ) { if ( a == Integer . MIN_VALUE ) { if ( b == Integer . MIN_VALUE ) throw new IllegalArgumentException ( ""gcd() is greater than Integer.MAX_VALUE"" ) ; return 1 << Integer . numberOfTrailingZeros ( Math . abs ( b ) ) ; } if ( b == Integer . MIN_VALUE ) return 1 << Integer . numberOfTrailingZeros ( Math . abs ( a ) ) ; a = Math . abs ( a ) ; b = Math . abs ( b ) ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; int factorsOfTwoInA = Integer . numberOfTrailingZeros ( a ) , factorsOfTwoInB = Integer . numberOfTrailingZeros ( b ) , commonFactorsOfTwo = Math . min ( factorsOfTwoInA , factorsOfTwoInB ) ; a >>= factorsOfTwoInA ; b >>= factorsOfTwoInB ; while ( a != b ) { if ( a > b ) { a = ( a - b ) ; a >>= Integer . numberOfTrailingZeros ( a ) ; } else { b = ( b - a ) ; b >>= Integer . numberOfTrailingZeros ( b ) ; } } return a << commonFactorsOfTwo ; }"
1402,"GenericType parse ( String s ) { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( s ) ) ; tokenizer . wordChars ( '.' , '.' ) ; try { tokenizer . nextToken ( ) ; return parse ( tokenizer ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } }"
1403,"GenericType parse ( StreamTokenizer tokenizer ) throws IOException { String baseName = tokenizer . sval ; tokenizer . nextToken ( ) ; List < GenericType > params = new ArrayList < > ( ) ; if ( tokenizer . ttype == '<' ) { do { tokenizer . nextToken ( ) ; params . add ( parse ( tokenizer ) ) ; } while ( tokenizer . ttype == ',' ) ; tokenizer . nextToken ( ) ; } return new GenericType ( baseName , params ) ; }"
1404,"int [ ] removeDuplicates ( int [ ] arr ) { int end = arr . length ; for ( int i = 0 ; i < end ; i ++ ) { for ( int j = i + 1 ; j < end ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { arr [ j ] = arr [ end - 1 ] ; end -- ; j -- ; } } } int [ ] whitelist = new int [ end ] ; System . arraycopy ( arr , 0 , whitelist , 0 , end ) ; return whitelist ; }"
1405,int [ ] removeDuplicates ( int [ ] arr ) { boolean [ ] set = new boolean [ 1001 ] ; int totalItems = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) { if ( ! set [ arr [ i ] ] ) { set [ arr [ i ] ] = true ; totalItems ++ ; } } int [ ] ret = new int [ totalItems ] ; int c = 0 ; for ( int i = 0 ; i < set . length ; ++ i ) { if ( set [ i ] ) { ret [ c ++ ] = i ; } } return ret ; }
1406,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; char [ ] c1 = s1 . toCharArray ( ) ; char [ ] c2 = s2 . toCharArray ( ) ; Arrays . sort ( c1 ) ; Arrays . sort ( c2 ) ; for ( int i = 0 ; i < c1 . length ; i ++ ) { if ( c1 [ i ] != c2 [ i ] ) return false ; } return true ; }"
1407,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ! s1 . contains ( """" + s2 . charAt ( i ) ) ) { return false ; } s1 = s1 . replaceFirst ( """" + s2 . charAt ( i ) , """" ) ; s2 = s2 . replaceFirst ( """" + s2 . charAt ( i ) , """" ) ; } return true ; }"
1408,int [ ] zeroFront ( int [ ] nums ) { Stack stack = new Stack ( ) ; int [ ] nums2 = new int [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] != 0 ) { stack . push ( nums [ i ] ) ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 0 ) { stack . push ( nums [ i ] ) ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { nums2 [ i ] = ( Integer ) stack . pop ( ) ; } return nums2 ; }
1409,int [ ] zeroFront ( int [ ] nums ) { if ( nums == null ) { return null ; } int [ ] result = new int [ nums . length ] ; int zeroesPos = 0 ; int othersPos = result . length - 1 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { result [ zeroesPos ] = 0 ; ++ zeroesPos ; } else { result [ othersPos ] = nums [ i ] ; -- othersPos ; } } return result ; }
1410,"void processRow ( ResultSet rs ) throws SQLException { Long id = rs . getLong ( ""CUSTOMER_ID"" ) ; Customer customer = map . get ( id ) ; if ( customer == null ) { customer = new Customer ( ) ; customer . setId ( id ) ; customer . setName ( rs . getString ( ""CUSTOMER_NAME"" ) ) ; customer . setAccountNumber ( rs . getLong ( ""CUSTOMER_ACCOUNT_NO"" ) ) ; map . put ( id , customer ) ; } }"
1411,"void processRow ( ResultSet rs ) throws SQLException { Long id = rs . getLong ( ""CUSTOMER_ID"" ) ; Customer customer = map . get ( id ) ; if ( customer != null ) { List brandList = customer . getBrands ( ) ; if ( brandsList == null ) { brandsList = new ArrayList < Brand > ( ) ; customer . setBrands ( brandsList ) ; } Brand brand = new Brand ( ) ; brand . setId ( rs . getLong ( ""CUSTOMER_BRAND_ID"" ) ) ; brand . setName ( rs . getString ( ""CUSTOMER_BRAND_NAME"" ) ) ; brandsList . add ( brand ) ; } }"
1412,"int [ ] front11 ( int [ ] a , int [ ] b ) { if ( a . length > 0 && b . length > 0 ) return new int [ ] { a [ 0 ] , b [ 0 ] } ; if ( a . length > 0 ) return new int [ ] { a [ 0 ] } ; if ( b . length > 0 ) return new int [ ] { b [ 0 ] } ; return new int [ 0 ] ; }"
1413,"int [ ] front11 ( int [ ] a , int [ ] b ) { int alen = ( a != null ) ? a . length : 0 , blen = ( b != null ) ? b . length : 0 ; if ( alen > 0 && blen > 0 ) { return new int [ ] { a [ 0 ] , b [ 0 ] } ; } else if ( alen > 0 ) { return new int [ ] { a [ 0 ] } ; } else if ( blen > 0 ) { return new int [ ] { b [ 0 ] } ; } else { return new int [ 0 ] ; } }"
1414,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] arr = new int [ S . length ( ) ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : arr [ i ] = 1 ; break ; case 'C' : arr [ i ] = 2 ; break ; case 'G' : arr [ i ] = 3 ; break ; case 'T' : arr [ i ] = 4 ; break ; default : break ; } } segmentNode root = buildTree ( arr , 0 , S . length ( ) - 1 ) ; int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { result [ i ] = getMin ( root , P [ i ] , Q [ i ] ) ; } return result ; }"
1415,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { final char [ ] characterInput = S . toCharArray ( ) ; final int [ ] integerInput = new int [ characterInput . length ] ; for ( int counter = 0 ; counter < characterInput . length ; counter ++ ) { integerInput [ counter ] = characterMapping . get ( characterInput [ counter ] ) ; } int [ ] result = new int [ P . length ] ; for ( int index = 0 ; index < P . length ; index ++ ) { if ( P [ index ] == Q [ index ] ) { result [ index ] = integerInput [ P [ index ] ] ; break ; } final int [ ] subArray = Arrays . copyOfRange ( integerInput , P [ index ] , Q [ index ] + 1 ) ; final int minimumValue = minimum ( subArray ) ; result [ index ] = minimumValue ; } return result ; }"
1416,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1417,"void transform ( HSSFSheet sheetOld , XSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setForceFormulaRecalculation ( sheetOld . getForceFormulaRecalculation ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; XSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( ( HSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1418,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
1419,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
1420,"void main ( String [ ] args ) { String str = ""AAABBBBCC"" ; int length = str . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int count = 1 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == length - 1 ) { sb . append ( str . charAt ( i ) + """" + count ) ; break ; } if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { count ++ ; } else { sb . append ( str . charAt ( i ) + """" + count ) ; count = 1 ; } } System . out . println ( sb . toString ( ) ) ; }"
1421,"void main ( String [ ] args ) { String string = ""aaabbbbbaccc"" ; int counter ; String result = """" ; int i = 0 ; while ( i < string . length ( ) ) { counter = 1 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { System . out . println ( ""string length ="" + string . length ( ) ) ; if ( string . charAt ( i ) == string . charAt ( j ) ) { counter ++ ; } } result = result + string . charAt ( i ) + counter ; string = string . replaceAll ( String . valueOf ( string . charAt ( i ) ) , """" ) ; } System . out . println ( ""result is = "" + result ) ; }"
1422,"void CountbyChar ( String s ) { int [ ] arr = new int [ 256 ] ; for ( char c : s . toCharArray ( ) ) { if ( c < 256 ) { arr [ c ] ++ ; } } for ( int i = 0 ; i != 256 ; i ++ ) { if ( arr [ i ] != 0 ) { System . out . print ( ( char ) i ) ; System . out . print ( "" : "" ) ; System . out . println ( arr [ i ] ) ; } } }"
1423,"void CountbyChar ( String s ) { HashMap < Character , Integer > letterCountMap = new HashMap < Character , Integer > ( ) ; char [ ] c = s . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { Integer count = 0 ; if ( letterCountMap . containsKey ( c [ i ] ) ) { count = letterCountMap . get ( c [ i ] ) + 1 ; } else { count = 1 ; } letterCountMap . put ( c [ i ] , count ) ; } for ( Map . Entry < String , String > entry : letterCountMap . entrySet ( ) ) { System . out . println ( entry . getValue ( ) + ""( for"" + entry . getKey ( ) + "" )"" ) ; } }"
1424,"void main ( String [ ] args ) { try { InetAddress address = InetAddress . getByName ( ""192.168.1.103"" ) ; boolean reachable = address . isReachable ( 10000 ) ; System . out . println ( ""Is host reachable? "" + reachable ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
1425,"void main ( String [ ] args ) throws UnknownHostException , IOException { InetAddress inet ; inet = InetAddress . getByAddress ( new byte [ ] { 127 , 0 , 0 , 1 } ) ; System . out . println ( ""Sending Ping Request to "" + inet ) ; System . out . println ( inet . isReachable ( 5000 ) ? ""Host is reachable"" : ""Host is NOT reachable"" ) ; inet = InetAddress . getByAddress ( new byte [ ] { ( byte ) 173 , ( byte ) 194 , 32 , 38 } ) ; System . out . println ( ""Sending Ping Request to "" + inet ) ; System . out . println ( inet . isReachable ( 5000 ) ? ""Host is reachable"" : ""Host is NOT reachable"" ) ; }"
1426,"String compressBad ( String str ) { if ( str . length ( ) == 1 ) return str + ""1"" ; int countConsecutive = 0 ; String compressedString = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i > 0 ) { countConsecutive ++ ; if ( str . charAt ( i ) != str . charAt ( i - 1 ) ) { compressedString += """" + str . charAt ( i - 1 ) + countConsecutive ; countConsecutive = 0 ; } if ( i == str . length ( ) - 1 ) { countConsecutive ++ ; compressedString += """" + str . charAt ( i ) + countConsecutive ; } } } return compressedString ; }"
1427,"String compressBad ( String str ) { String compressedString = """" ; if ( str != null && str . length ( ) > 0 ) { int countConsecutive = 1 ; char prevChar = str . charAt ( 0 ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != prevChar ) { compressedString += String . valueOf ( prevChar ) + countConsecutive ; prevChar = str . charAt ( i ) ; countConsecutive = 1 ; continue ; } countConsecutive ++ ; } compressedString += String . valueOf ( prevChar ) + countConsecutive ; } return compressedString ; }"
1428,"void main ( String [ ] args ) throws IOException { final SSHClient ssh = new SSHClient ( ) ; ssh . loadKnownHosts ( ) ; ssh . connect ( ""localhost"" ) ; try { ssh . authPublickey ( System . getProperty ( ""user.name"" ) ) ; final String src = System . getProperty ( ""user.home"" ) + File . separator + ""test_file"" ; final SFTPClient sftp = ssh . newSFTPClient ( ) ; try { sftp . put ( new FileSystemFile ( src ) , ""/tmp"" ) ; } finally { sftp . close ( ) ; } } finally { ssh . disconnect ( ) ; } }"
1429,"void main ( String args [ ] ) { JSch jsch = new JSch ( ) ; Session session = null ; try { session = jsch . getSession ( ""username"" , ""127.0.0.1"" , 22 ) ; session . setConfig ( ""StrictHostKeyChecking"" , ""no"" ) ; session . setPassword ( ""password"" ) ; session . connect ( ) ; Channel channel = session . openChannel ( ""sftp"" ) ; channel . connect ( ) ; ChannelSftp sftpChannel = ( ChannelSftp ) channel ; sftpChannel . get ( ""remotefile.txt"" , ""localfile.txt"" ) ; sftpChannel . exit ( ) ; session . disconnect ( ) ; } catch ( JSchException e ) { e . printStackTrace ( ) ; } catch ( SftpException e ) { e . printStackTrace ( ) ; } }"
1430,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
1431,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Time (s)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; drawRotate ( gg , getWidth ( ) , ( getHeight ( ) + width ) / 2 , 270 , string ) ; }"
1432,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
1433,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
1434,String inputStreamToString ( InputStream in ) throws IOException { ReadableByteChannel channel = Channels . newChannel ( in ) ; ByteBuffer byteBuffer = ByteBuffer . allocate ( 1024 * 16 ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; WritableByteChannel outChannel = Channels . newChannel ( bout ) ; while ( channel . read ( byteBuffer ) > 0 || byteBuffer . position ( ) > 0 ) { byteBuffer . flip ( ) ; outChannel . write ( byteBuffer ) ; byteBuffer . compact ( ) ; } channel . close ( ) ; outChannel . close ( ) ; return bout . toString ( UTF_8 ) ; }
1435,"String inputStreamToString ( InputStream inputStream ) throws IOException { String newLine = System . getProperty ( ""line.separator"" ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; StringBuilder result = new StringBuilder ( UTF_8 ) ; String line ; boolean flag = false ; while ( ( line = reader . readLine ( ) ) != null ) { result . append ( flag ? newLine : """" ) . append ( line ) ; flag = true ; } return result . toString ( ) ; }"
1436,"void main ( String [ ] args ) { String s = ""a a a A A"" ; String [ ] splitedString = s . split ( "" "" ) ; Map m = new HashMap ( ) ; int count = 1 ; for ( String s1 : splitedString ) { count = m . containsKey ( s1 ) ? count + 1 : 1 ; m . put ( s1 , count ) ; } Iterator < StringToword > itr = m . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . println ( itr . next ( ) ) ; } }"
1437,"void main ( String [ ] args ) { System . out . println ( ""Please enter the String"" ) ; Scanner input = new Scanner ( System . in ) ; String userInput = input . nextLine ( ) . trim ( ) ; int numOfWords = getNumberOfWords ( userInput ) ; char words [ ] [ ] = new char [ numOfWords + 1 ] [ ] ; words = getWordsFromString ( userInput ) ; System . out . println ( ""Total number of words found in the String is "" + ( numOfWords ) ) ; for ( int i = 0 ; i < numOfWords ; i ++ ) { System . out . println ( "" "" ) ; for ( int j = 0 ; j < words [ i ] . length ; j ++ ) { System . out . print ( words [ i ] [ j ] ) ; } } }"
1438,"void run ( ) { try { Thread t = new Thread ( new Lock ( ) ) ; t . start ( ) ; t . join ( ) ; } catch ( InterruptedException ex ) { System . out . println ( ""won't see me"" ) ; } }"
1439,"void run ( ) { System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" starting"" ) ; synchronized ( BadRunnable . class ) { System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" acquired the monitor on BadRunnable.class"" ) ; latch . countDown ( ) ; while ( true ) { try { latch . await ( ) ; } catch ( InterruptedException ex ) { continue ; } break ; } } System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" released the monitor on BadRunnable.class"" ) ; System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" ending"" ) ; }"
1440,V remove ( Object key ) { readWriteLock . writeLock ( ) . lock ( ) ; V value ; try { value = super . remove ( key ) ; } finally { readWriteLock . writeLock ( ) . unlock ( ) ; } return value ; }
1441,K remove ( ) { if ( head == null ) return null ; K val = head . value ; if ( head . next == null ) { head = null ; tail = null ; } else { head = head . next ; head . prev = null ; } return val ; }
1442,"void main ( String [ ] args ) { ScriptEngineManager manager = new ScriptEngineManager ( ) ; ScriptEngine engine = manager . getEngineByName ( ""js"" ) ; engine . put ( ""a"" , 1 ) ; engine . put ( ""b"" , 2 ) ; try { String expression = ""(a + b) > 2"" ; Object result = engine . eval ( expression ) ; System . out . println ( expression + "" ? "" + result ) ; } catch ( ScriptException se ) { se . printStackTrace ( ) ; } }"
1443,"void main ( String [ ] args ) { long a = 5 ; long b = 4 ; String theExpression = ""a * b"" ; JexlEngine jexl = new JexlEngine ( ) ; Expression e = jexl . createExpression ( theExpression ) ; JexlContext context = new MapContext ( ) ; context . set ( ""a"" , a ) ; context . set ( ""b"" , b ) ; Long result = ( Long ) e . evaluate ( context ) ; System . out . println ( ""The answer : "" + result ) ; }"
1444,"String join ( Collection s , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; Iterator iter = s . iterator ( ) ; while ( iter . hasNext ( ) ) { buffer . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { buffer . append ( delimiter ) ; } } return buffer . toString ( ) ; }"
1445,"String join ( String r [ ] , String d ) { if ( r . length == 0 ) return """" ; StringBuilder sb = new StringBuilder ( ) ; int i ; for ( i = 0 ; i < r . length - 1 ; i ++ ) { sb . append ( r [ i ] ) ; sb . append ( d ) ; } sb . append ( r [ i ] ) ; return sb . toString ( ) ; }"
1446,"void onRequestPermissionsResult ( int requestCode , String permissions [ ] , int [ ] grantResults ) { switch ( requestCode ) { case Constants . PERMISSIONS_REQUEST_CALL_PHONE : { if ( grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { checkPermissionsAndCall ( ) ; } } } }"
1447,"void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { int index = ( requestCode > > 16 ) & 0xffff ; if ( index != 0 ) { index -- ; String who = mPendingFragmentActivityResults . get ( index ) ; mPendingFragmentActivityResults . remove ( index ) ; if ( who == null ) { Log . w ( TAG , ""Activity result delivered for unknown Fragment."" ) ; return ; } Fragment frag = mFragments . findFragmentByWho ( who ) ; if ( frag == null ) { Log . w ( TAG , ""Activity result no fragment exists for who: "" + who ) ; } else { frag . onRequestPermissionsResult ( requestCode & 0xffff , permissions , grantResults ) ; } } }"
1448,"void printTable ( String [ ] countries , int [ ] populations ) { int countryLength = 0 ; long populationLength = 0 ; for ( String country : countries ) { if ( country . length ( ) > countryLength ) countryLength = country . length ( ) ; } for ( int i : populations ) { if ( String . valueOf ( i ) . length ( ) > populationLength ) populationLength = String . valueOf ( i ) . length ( ) ; } for ( int i = 0 ; i < countries . length ; i ++ ) System . out . format ( ""%-"" + ( countryLength + 1 ) + ""s|%"" + ( populationLength + 1 ) + ""d\n"" , countries [ i ] , populations [ i ] ) ; }"
1449,"void printTable ( String [ ] countries , int [ ] populations ) { if ( countries . length == 0 || populations . length == 0 || countries . length != populations . length ) { return ; } int longestCountry = Arrays . stream ( countries ) . map ( String :: toString ) . mapToInt ( String :: length ) . max ( ) . getAsInt ( ) ; int longestPop = Arrays . stream ( populations ) . mapToObj ( Integer :: toString ) . mapToInt ( String :: length ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < countries . length ; i ++ ) { System . out . printf ( ""%-"" + longestCountry + ""s | %"" + longestPop + ""d%n"" , countries [ i ] , populations [ i ] ) ; } }"
1450,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1451,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
1452,"void main ( String [ ] args ) { int a = 100 ; int b = 1000 ; int lowest = b ; int highest = a ; int count = 100000 ; Random random = new Random ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int nextNumber = ( int ) ( ( Math . abs ( random . nextDouble ( ) ) * ( b - a ) ) ) + a ; if ( nextNumber < a || nextNumber > b ) { System . err . println ( ""number not in range :"" + nextNumber ) ; } else { System . out . println ( nextNumber ) ; } if ( nextNumber < lowest ) { lowest = nextNumber ; } if ( nextNumber > highest ) { highest = nextNumber ; } } System . out . println ( ""Produced "" + count + "" numbers from "" + lowest + "" to "" + highest ) ; }"
1453,"void main ( String ... aArgs ) { log ( ""Generating 10 random integers in range 1..10."" ) ; int START = 1 ; int END = 10 ; Random randomGenerator = new Random ( ) ; for ( int idx = 1 ; idx <= 10 ; ++ idx ) { showRandomInteger ( START , END , randomGenerator ) ; } log ( ""Done"" ) ; }"
1454,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1455,"void transform ( HSSFSheet sheetOld , XSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setForceFormulaRecalculation ( sheetOld . getForceFormulaRecalculation ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; XSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( ( HSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1456,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String formatedSource = source . subSequence ( start , end ) . toString ( ) ; String destPrefix = dest . subSequence ( 0 , dstart ) . toString ( ) ; String destSuffix = dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; String result = destPrefix + formatedSource + destSuffix ; result = result . replace ( "","" , ""."" ) ; Matcher matcher = mPattern . matcher ( result ) ; if ( matcher . matches ( ) ) { return null ; } return """" ; }"
1457,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String lsStart = """" ; String lsInsert = """" ; String lsEnd = """" ; String lsText = """" ; Log . d ( ""debug"" , moPattern . toString ( ) ) ; Log . d ( ""debug"" , ""source: "" + source + "", start: "" + start + "", end:"" + end + "", dest: "" + dest + "", dstart: "" + dstart + "", dend: "" + dend ) ; lsText = dest . toString ( ) ; if ( lsText . length ( ) > 0 ) { lsStart = lsText . substring ( 0 , dstart ) ; Log . d ( ""debug"" , ""lsStart : "" + lsStart ) ; if ( source != """" ) { lsInsert = source . toString ( ) ; Log . d ( ""debug"" , ""lsInsert: "" + lsInsert ) ; } lsEnd = lsText . substring ( dend ) ; Log . d ( ""debug"" , ""lsEnd   : "" + lsEnd ) ; lsText = lsStart + lsInsert + lsEnd ; Log . d ( ""debug"" , ""lsText  : "" + lsText ) ; } Matcher loMatcher = moPattern . matcher ( lsText ) ; Log . d ( ""debug"" , ""loMatcher.matches(): "" + loMatcher . matches ( ) + "", lsText: "" + lsText ) ; if ( ! loMatcher . matches ( ) ) { return """" ; } return null ; }"
1458,int tortoiseMoves ( ) { int i = tGen ( ) ; if ( i >= 1 && i <= 5 ) { int fastplod = 3 ; return fastplod ; } else if ( i >= 6 && i <= 8 ) { int slowplod = 1 ; return slowplod ; } else if ( i >= 9 && i <= 10 ) { int slip = - 6 ; return slip ; } else { return 0 ; } }
1459,int tortoiseMoves ( ) { switch ( tGen ( ) ) { case 1 : case 2 : case 3 : case 4 : case 5 : return 3 ; case 6 : case 7 : case 8 : return 1 ; case 9 : case 10 : return - 6 ; default : return 0 ; } }
1460,"void permute ( char [ ] alphabet , int k ) { int permutationNumber = ( int ) Math . pow ( alphabet . length , k ) ; for ( int i = 0 ; i < permutationNumber ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { System . out . print ( alphabet [ ( i + ( j * i / alphabet . length ) ) % alphabet . length ] ) ; } System . out . println ( ) ; } }"
1461,"void permute ( int level , String prefix ) { if ( level == 0 ) { System . out . println ( prefix ) ; return ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) permute ( level - 1 , prefix + s . charAt ( i ) ) ; }"
1462,"void main ( String [ ] args ) { int len = args . length ; if ( len == 0 ) { sopl ( ""\n\tUsage: java echo <args:String[]>"" ) ; System . exit ( 0 ) ; } sop ( ""\n\t"" ) ; for ( int i = 0 ; i < len ; i ++ ) { sop ( args [ i ] + "" "" ) ; } sop ( ""\n\t"" ) ; while ( len > 0 ) sop ( args [ args . length - len -- ] + "" "" ) ; sopl ( """" ) ; }"
1463,"void main ( String [ ] args ) { int len = args . length ; if ( len <= 0 ) { System . out . println ( "" ERROR: Please input a value of 1-5"" ) ; System . exit ( 0 ) ; } int j ; for ( int i = 0 ; i <= len ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) System . out . print ( ""*"" ) ; System . out . println ( """" ) ; } }"
1464,"void main ( String [ ] args ) { int x = 123456789 ; System . out . println ( ""x = "" + x ) ; int hi = x , n = 0 ; while ( hi > 9 ) { hi /= 10 ; ++ n ; } for ( int i = 0 ; i < n ; i ++ ) hi *= 10 ; x -= hi ; System . out . println ( ""x with high digit removed = "" + x ) ; }"
1465,"void main ( String [ ] argv ) { final int x = 123456789 ; int newX = x ; final double originalLog = Math . floor ( Math . log10 ( x ) ) ; final int getRidOf = ( int ) Math . pow ( 10 , originalLog ) ; while ( originalLog == Math . floor ( Math . log10 ( newX ) ) ) { newX -= getRidOf ; } System . out . println ( newX ) ; }"
1466,"void print ( ) throws InterruptedException { while ( count < 15 ) { for ( int i = 0 ; i < 5 ; i ++ ) { count ++ ; System . out . println ( count + "" -- "" + Thread . currentThread ( ) ) ; } notifyAll ( ) ; wait ( ) ; } }"
1467,"void print ( ) { try { waitForSemaphore . acquire ( ) ; int start = nextStartIdx ; for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( String . format ( ""%d -- %s"" , i + start , Thread . currentThread ( ) . getName ( ) ) ) ; } nextStartIdx += 5 ; next . release ( ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; } }"
1468,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
1469,"void run ( ) { int i = 1 ; while ( i < 50 ) { while ( s . getState ( ) != 3 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 3 ) System . out . println ( ""t1 "" + i ) ; s . setState ( 1 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
1470,int mode ( int [ ] [ ] arr ) { int [ ] oneDArray = new int [ arr . length * arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int s = 0 ; s < arr . length ; s ++ ) { oneDArray [ ( i * arr . length ) + s ] = arr [ i ] [ s ] ; } } }
1471,int mode ( int [ ] [ ] arr ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { list . add ( arr [ i ] [ j ] ) ; } } int [ ] vector = new int [ list . size ( ) ] ; for ( int i = 0 ; i < vector . length ; i ++ ) { vector [ i ] = list . get ( i ) ; } }
1472,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
1473,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
1474,"Node reverse ( Node root ) { if ( root == null || root . next == null ) { return root ; } Node curr , prev , next ; curr = root ; prev = next = null ; while ( curr != null ) { next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; }"
1475,"Node reverse ( Node n , Node p ) { if ( n == null ) return null ; if ( n . next == null ) { n . next = p ; return n ; } Node r = reverse ( n . next , n ) ; n . next = p ; return r ; }"
1476,"int interpolateColor ( int a , int b , float proportion ) { float [ ] hsva = new float [ 3 ] ; float [ ] hsvb = new float [ 3 ] ; Color . colorToHSV ( a , hsva ) ; Color . colorToHSV ( b , hsvb ) ; for ( int i = 0 ; i < 3 ; i ++ ) { hsvb [ i ] = interpolate ( hsva [ i ] , hsvb [ i ] , proportion ) ; } return Color . HSVToColor ( hsvb ) ; }"
1477,"int interpolateColor ( int a , int b , float proportion ) { if ( proportion > 1 || proportion < 0 ) { throw new IllegalArgumentException ( ""proportion must be [0 - 1]"" ) ; } float [ ] hsva = new float [ 3 ] ; float [ ] hsvb = new float [ 3 ] ; float [ ] hsv_output = new float [ 3 ] ; Color . colorToHSV ( a , hsva ) ; Color . colorToHSV ( b , hsvb ) ; for ( int i = 0 ; i < 3 ; i ++ ) { hsv_output [ i ] = interpolate ( hsva [ i ] , hsvb [ i ] , proportion ) ; } int alpha_a = Color . alpha ( a ) ; int alpha_b = Color . alpha ( b ) ; float alpha_output = interpolate ( alpha_a , alpha_b , proportion ) ; return Color . HSVToColor ( ( int ) alpha_output , hsv_output ) ; }"
1478,"void setCursorColor ( EditText editText , @ ColorInt int color ) { try { Field field = TextView . class . getDeclaredField ( ""mCursorDrawableRes"" ) ; field . setAccessible ( true ) ; int drawableResId = field . getInt ( editText ) ; Drawable drawable = ContextCompat . getDrawable ( editText . getContext ( ) , drawableResId ) ; drawable . setColorFilter ( color , PorterDuff . Mode . SRC_IN ) ; Drawable [ ] drawables = { drawable , drawable } ; if ( Build . VERSION . SDK_INT == 15 ) { Class < ? > drawableFieldClass = TextView . class ; field = drawableFieldClass . getDeclaredField ( ""mCursorDrawable"" ) ; field . setAccessible ( true ) ; field . set ( editText , drawables ) ; } else { field = TextView . class . getDeclaredField ( ""mEditor"" ) ; field . setAccessible ( true ) ; Object editor = field . get ( editText ) ; field = editor . getClass ( ) . getDeclaredField ( ""mCursorDrawable"" ) ; field . setAccessible ( true ) ; field . set ( editor , drawables ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , ""-> "" , e ) ; } }"
1479,"void setCursorColor ( EditText view , @ ColorInt int color ) { try { Field field = TextView . class . getDeclaredField ( ""mCursorDrawableRes"" ) ; field . setAccessible ( true ) ; int drawableResId = field . getInt ( view ) ; field = TextView . class . getDeclaredField ( ""mEditor"" ) ; field . setAccessible ( true ) ; Object editor = field . get ( view ) ; Drawable drawable = ContextCompat . getDrawable ( view . getContext ( ) , drawableResId ) ; drawable . setColorFilter ( color , PorterDuff . Mode . SRC_IN ) ; Drawable [ ] drawables = { drawable , drawable } ; field = editor . getClass ( ) . getDeclaredField ( ""mCursorDrawable"" ) ; field . setAccessible ( true ) ; field . set ( editor , drawables ) ; } catch ( Exception ignored ) { } }"
1480,"String getDurationBreakdown ( long millis ) { if ( millis < 0 ) { throw new IllegalArgumentException ( ""Duration must be greater than zero!"" ) ; } long days = TimeUnit . MILLISECONDS . toDays ( millis ) ; long hours = TimeUnit . MILLISECONDS . toHours ( millis ) % 24 ; long minutes = TimeUnit . MILLISECONDS . toMinutes ( millis ) % 60 ; long seconds = TimeUnit . MILLISECONDS . toSeconds ( millis ) % 60 ; long milliseconds = millis % 1000 ; return String . format ( ""%d Days %d Hours %d Minutes %d Seconds %d Milliseconds"" , days , hours , minutes , seconds , milliseconds ) ; }"
1481,"String getDurationBreakdown ( long millis ) { if ( millis < 0 ) { throw new IllegalArgumentException ( ""Duration must be greater than zero!"" ) ; } long days = TimeUnit . MILLISECONDS . toDays ( millis ) ; millis -= TimeUnit . DAYS . toMillis ( days ) ; long hours = TimeUnit . MILLISECONDS . toHours ( millis ) ; millis -= TimeUnit . HOURS . toMillis ( hours ) ; long minutes = TimeUnit . MILLISECONDS . toMinutes ( millis ) ; millis -= TimeUnit . MINUTES . toMillis ( minutes ) ; long seconds = TimeUnit . MILLISECONDS . toSeconds ( millis ) ; StringBuilder sb = new StringBuilder ( 64 ) ; sb . append ( days ) ; sb . append ( "" Days "" ) ; sb . append ( hours ) ; sb . append ( "" Hours "" ) ; sb . append ( minutes ) ; sb . append ( "" Minutes "" ) ; sb . append ( seconds ) ; sb . append ( "" Seconds"" ) ; return ( sb . toString ( ) ) ; }"
1482,"void registerModule ( HttpServletRequest req , ModuleType moduleType ) { LOGGER . debug ( ""Register New Module - "" + moduleType . name ( ) ) ; try { if ( req . getParts ( ) . isEmpty ( ) || req . getParameterMap ( ) . isEmpty ( ) ) { LOGGER . error ( ""The rest request is empty.No info to register"" ) ; return ; } ModuleEntityGenerator moduleEntityGenerator = new ModuleEntityGenerator ( ) ; ModuleEntityDao moduleEntityDao = moduleEntityGenerator . get ( req , moduleType ) ; if ( moduleEntityDao == null ) { LOGGER . error ( ""The BA object is null. There is nothing to register"" ) ; return ; } if ( processRegistryDal . getModule ( moduleType , moduleEntityDao . getId ( ) ) == null ) { processRegistryDal . addNewModule ( moduleEntityDao ) ; } else { processRegistryDal . updateModule ( moduleEntityDao ) ; } } catch ( IOException e ) { LOGGER . error ( ""IO Error\n"" + e . getMessage ( ) ) ; } catch ( ServletException e ) { LOGGER . error ( ""Servlet Error\n"" + e . getMessage ( ) ) ; } }"
1483,"void registerModule ( HttpServletRequest req , ModuleType moduleType ) { LOGGER . debug ( ""Register New Module - "" + moduleType . name ( ) ) ; try { ModuleEntityDao moduleEntityDao ; if ( req . getParts ( ) . isEmpty ( ) || req . getParameterMap ( ) . isEmpty ( ) ) { LOGGER . error ( ""The rest request is empty.No info to register"" ) ; } else if ( ( moduleEntityDao = new ModuleEntityGenerator ( ) . get ( req , moduleType ) ) == null ) { LOGGER . error ( ""The BA object is null. There is nothing to register"" ) ; } else if ( processRegistryDal . getModule ( moduleType , moduleEntityDao . getId ( ) ) == null ) { processRegistryDal . addNewModule ( moduleEntityDao ) ; } else { processRegistryDal . updateModule ( moduleEntityDao ) ; } } catch ( IOException e ) { LOGGER . error ( ""IO Error\n"" + e . getMessage ( ) ) ; } catch ( ServletException e ) { LOGGER . error ( ""Servlet Error\n"" + e . getMessage ( ) ) ; } }"
1484,"void main ( String [ ] args ) { String sr = new String ( ""fsdfesfsfdddddddsfdsfssdfdsfdsfdsfdsfdsdfggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggghghghghggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggfsdfesfsfdddddddsfdsfssdfdsfdsfdsfdsfdsdfggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggghghghghggggggggggggggggggggggggggggggggggggggggg"" ) ; byte [ ] data = sr . getBytes ( ) ; System . out . println ( ""src size "" + data . length ) ; try { compress ( data ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
1485,"void main ( String [ ] args ) { byte [ ] dataToCompress = ""This is the test data."" . getBytes ( StandardCharsets . ISO_8859_1 ) ; try { ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( dataToCompress . length ) ; try { GZIPOutputStream zipStream = new GZIPOutputStream ( byteStream ) ; try { zipStream . write ( dataToCompress ) ; } finally { zipStream . close ( ) ; } } finally { byteStream . close ( ) ; } byte [ ] compressedData = byteStream . toByteArray ( ) ; FileOutputStream fileStream = new FileOutputStream ( ""C:/Users/UserName/Desktop/zip_file.gz"" ) ; try { fileStream . write ( compressedData ) ; } finally { try { fileStream . close ( ) ; } catch ( Exception e ) { } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
1486,"void sort ( int [ ] input ) { for ( int i = 0 ; i < input . length ; i ++ ) { for ( int j = i + 1 ; j < input . length ; j ++ ) { if ( input [ i ] > input [ j ] ) { int tmp = input [ i ] ; input [ i ] = input [ j ] ; input [ j ] = tmp ; } } } System . out . println ( ""Slow sorting is done and the result is :"" ) ; for ( int i : input ) { System . out . print ( i + "","" ) ; } }"
1487,"void sort ( int [ ] input ) { for ( int i = 0 ; i < input . length - 1 ; i ++ ) { int k = i + 1 ; int nxtVal = input [ k ] ; while ( input [ k - 1 ] > nxtVal ) { input [ k ] = input [ k - 1 ] ; k -- ; if ( k == 0 ) break ; } input [ k ] = nxtVal ; } System . out . println ( ""Medium sorting is done and the result is :"" ) ; for ( int i : input ) { System . out . print ( i + "","" ) ; } }"
1488,void shuffle ( String input ) { List < Character > characters = new ArrayList < Character > ( ) ; for ( char c : input . toCharArray ( ) ) { characters . add ( c ) ; } StringBuilder output = new StringBuilder ( input . length ( ) ) ; while ( characters . size ( ) != 0 ) { int randPicker = ( int ) ( Math . random ( ) * characters . size ( ) ) ; output . append ( characters . remove ( randPicker ) ) ; } System . out . println ( output . toString ( ) ) ; }
1489,String shuffle ( String text ) { char [ ] characters = text . toCharArray ( ) ; for ( int i = 0 ; i < characters . length ; i ++ ) { int randomIndex = ( int ) ( Math . random ( ) * characters . length ) ; char temp = characters [ i ] ; characters [ i ] = characters [ randomIndex ] ; characters [ randomIndex ] = temp ; } return new String ( characters ) ; }
1490,"void actionPerformed ( ActionEvent arg0 ) { int result = JOptionPane . OK_OPTION ; if ( dirty ) { result = JOptionPane . showConfirmDialog ( gui , ""Erase the current painting?"" ) ; } if ( result == JOptionPane . OK_OPTION ) { clear ( canvasImage ) ; } }"
1491,"void actionPerformed ( ActionEvent arg0 ) { if ( ! dirty ) { JFileChooser ch = getFileChooser ( ) ; int result = ch . showOpenDialog ( gui ) ; if ( result == JFileChooser . APPROVE_OPTION ) { try { BufferedImage bi = ImageIO . read ( ch . getSelectedFile ( ) ) ; setImage ( bi ) ; } catch ( IOException e ) { showError ( e ) ; e . printStackTrace ( ) ; } } } else { JOptionPane . showMessageDialog ( gui , ""TODO - prompt save image.."" ) ; } }"
1492,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1493,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1494,"String makeStringsEqual ( String str , String keyword ) { StringBuilder equalStringBuilder = new StringBuilder ( ) ; if ( str . length ( ) > keyword . length ( ) ) { int keywordIndex = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != ' ' ) { equalStringBuilder . append ( keyword . charAt ( keywordIndex ++ ) ) ; keywordIndex %= keyword . length ( ) ; } else { equalStringBuilder . append ( ' ' ) ; } } } return equalStringBuilder . toString ( ) ; }"
1495,"String makeStringsEqual ( String str , String keyword ) { if ( str . length ( ) > keyword . length ( ) ) { string result = """" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != ' ' ) { result += keyword . charAt ( i % keyword . length ( ) ) ; } else result += "" "" ; } } return result ; }"
1496,"void main ( String [ ] args ) { String name1 ; String name2 ; String name3 ; Scanner keyboard = new Scanner ( System . in ) ; System . out . print ( ""Please Enter First Name "" ) ; name1 = keyboard . nextLine ( ) ; System . out . print ( ""Please Enter Second Name "" ) ; name2 = keyboard . nextLine ( ) ; System . out . print ( ""Please Enter Third Name "" ) ; name3 = keyboard . nextLine ( ) ; if ( ( name1 . compareTo ( name2 ) < 0 ) && ( name1 . compareTo ( name3 ) < 0 ) ) { System . out . println ( name1 ) ; if ( name2 . compareTo ( name3 ) < 0 ) { System . out . println ( name2 ) ; System . out . println ( name3 ) ; } else { System . out . println ( name3 ) ; System . out . println ( name2 ) ; } } else if ( ( name1 . compareTo ( name2 ) > 0 ) && ( name2 . compareTo ( name3 ) < 0 ) ) { System . out . println ( name2 ) ; if ( name1 . compareTo ( name3 ) < 0 ) { System . out . println ( name1 ) ; System . out . println ( name3 ) ; } else { System . out . println ( name3 ) ; System . out . println ( name1 ) ; } } else { System . out . println ( name3 ) ; if ( name1 . compareTo ( name2 ) < 0 ) { System . out . println ( name1 ) ; System . out . println ( name2 ) ; } else { System . out . println ( name2 ) ; System . out . println ( name1 ) ; } } }"
1497,"void main ( final String [ ] args ) { final Console console = System . console ( ) ; if ( console != null ) { final SortNames sortNames = new SortNames ( console ) ; sortNames . run ( ) ; } else { System . err . println ( ""Sorry, no console."" ) ; System . exit ( 1 ) ; } }"
1498,"int solution ( int N ) { int tempGap = 0 , gap = 0 ; String binaryString = Integer . toBinaryString ( N ) ; int i = 0 ; while ( i < binaryString . length ( ) ) { if ( binaryString . charAt ( i ) == '1' ) { ++ i ; tempGap = 0 ; while ( i < binaryString . length ( ) && binaryString . charAt ( i ) != '1' ) { ++ i ; tempGap ++ ; } if ( i >= binaryString . length ( ) ) { tempGap = 0 ; } } else { ++ i ; } if ( tempGap > gap ) { gap = tempGap ; } } return gap ; }"
1499,"int solution ( int N ) { int result = 0 ; while ( N > 0 ) { if ( ( N & 1 ) == 1 ) { int temp = 0 ; while ( ( N >>= 1 ) > 0 && ( ( N & 1 ) != 1 ) ) { temp ++ ; } result = Math . max ( result , temp ) ; } else { N >>= 1 ; } } return result ; }"
1500,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setColor ( Color . RED ) ; g2d . drawLine ( getWidth ( ) / 2 , 0 , getWidth ( ) / 2 , getHeight ( ) ) ; g2d . drawLine ( 0 , getHeight ( ) / 2 , getWidth ( ) , getHeight ( ) / 2 ) ; FontRenderContext context = g2d . getFontRenderContext ( ) ; Font font = new Font ( ""Arial"" , Font . BOLD , 48 ) ; TextLayout txt = new TextLayout ( text , font , context ) ; Rectangle2D bounds = txt . getBounds ( ) ; int x = ( int ) ( ( getWidth ( ) - ( int ) bounds . getWidth ( ) ) / 2 ) ; int y = ( int ) ( ( getHeight ( ) - ( bounds . getHeight ( ) - txt . getDescent ( ) ) ) / 2 ) ; y += txt . getAscent ( ) - txt . getDescent ( ) ; g2d . setFont ( font ) ; g2d . setColor ( Color . BLACK ) ; g2d . drawString ( text , x , y ) ; g2d . setColor ( Color . BLUE ) ; g2d . translate ( x , y ) ; g2d . draw ( bounds ) ; g2d . dispose ( ) ; }"
1501,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Font font = new Font ( ""Arial"" , Font . BOLD , 48 ) ; String text = ""Along time ago, in a galaxy, far, far away"" ; Shape outline = font . createGlyphVector ( g . getFontMetrics ( ) . getFontRenderContext ( ) , text ) . getOutline ( ) ; AffineTransform transform = AffineTransform . getTranslateInstance ( - outline . getBounds ( ) . getX ( ) + getWidth ( ) / 2 - outline . getBounds ( ) . width / 2 , - outline . getBounds ( ) . getY ( ) + getHeight ( ) / 2 - outline . getBounds ( ) . height / 2 ) ; outline = transform . createTransformedShape ( outline ) ; g2d . fill ( outline ) ; }"
1502,"void main ( String [ ] args ) { ArrayList < String > al = new ArrayList < String > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( true ) { System . out . print ( ""Enter name:"" ) ; String temp = sc . next ( ) ; if ( al . isEmpty ( ) != true ) { if ( temp . equals ( al . get ( 0 ) ) ) break ; } al . add ( temp ) ; } for ( int i = 0 ; i < al . size ( ) ; i ++ ) { System . out . println ( al . get ( i ) ) ; } }"
1503,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int numOfItems = 0 ; System . out . print ( ""Enter How Many Items: "" ) ; try { numOfItems = Integer . parseInt ( scan . nextLine ( ) . trim ( ) ) ; } catch ( NumberFormatException e ) { System . out . print ( ""Number of items you entered is invalid!"" ) ; System . exit ( 0 ) ; } Grocery grocery = new Grocery ( numOfItems ) ; for ( int i = 0 ; i < numOfItems ; i ++ ) { System . out . print ( ""Enter Item "" + ( i + 1 ) + "" : "" ) ; if ( ! grocery . addItem ( scan . nextLine ( ) ) ) { System . out . println ( ""First Item Duplicate Detected!"" ) ; System . exit ( 0 ) ; } } scan . close ( ) ; System . out . println ( grocery . toString ( ) ) ; }"
1504,void type ( char c ) { keyPress ( VK_ALT ) ; keyPress ( VK_NUMPAD0 ) ; keyRelease ( VK_NUMPAD0 ) ; String altCode = Integer . toString ( c ) ; for ( int i = 0 ; i < altCode . length ( ) ; i ++ ) { c = ( char ) ( altCode . charAt ( i ) + '0' ) ; keyPress ( c ) ; keyRelease ( c ) ; } keyRelease ( VK_ALT ) ; }
1505,"void type ( CharSequence chars , int ms ) { ms = ms > 0 ? ms : 0 ; for ( int i = 0 , len = chars . length ( ) ; i < len ; i ++ ) { char c = chars . charAt ( i ) ; AWTKeyStroke keyStroke = getKeyStroke ( c ) ; int keyCode = keyStroke . getKeyCode ( ) ; boolean shift = Character . isUpperCase ( c ) || keyStroke . getModifiers ( ) == ( SHIFT_DOWN_MASK + 1 ) ; if ( shift ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; } robot . keyPress ( keyCode ) ; robot . keyRelease ( keyCode ) ; if ( shift ) { robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } if ( ms > 0 ) { robot . delay ( ms ) ; } } }"
1506,"void add ( View v ) { first = findViewById ( R . id . first ) ; second = findViewById ( R . id . second ) ; TextView result = findViewById ( R . id . result ) ; double r ; if ( Validates ( ) ) { double s = Double . parseDouble ( second . getText ( ) . toString ( ) ) ; double f = Double . parseDouble ( first . getText ( ) . toString ( ) ) ; r = f + s ; result . setText ( """" + r ) ; } }"
1507,"void add ( View v ) { EditText first = findViewById ( R . id . first ) ; EditText second = findViewById ( R . id . second ) ; TextView result = findViewById ( R . id . result ) ; double r ; if ( TextUtils . isEmpty ( first . getText ( ) . toString ( ) ) ) { first . setError ( ""This field can't be empty"" ) ; } else if ( TextUtils . isEmpty ( second . getText ( ) . toString ( ) ) ) { second . setError ( ""This field can't be empty"" ) ; } else { double s = Double . parseDouble ( second . getText ( ) . toString ( ) ) ; double f = Double . parseDouble ( first . getText ( ) . toString ( ) ) ; r = f + s ; result . setText ( """" + r ) ; } }"
1508,"void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = Integer . parseInt ( s . nextLine ( ) ) ; int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String str = s . nextLine ( ) ; String [ ] tempArray = str . split ( "" "" ) ; for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = Integer . parseInt ( tempArray [ j ] ) ; } } int x = 0 ; int y = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += a [ i ] [ i ] ; } for ( int p = 0 ; p < n ; p ++ ) { int k = a . length - p - 1 ; y += a [ p ] [ a . length - p - 1 ] ; k += - 1 ; } sum = x - y ; System . out . println ( Math . abs ( sum ) ) ; }"
1509,void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int a [ ] [ ] = new int [ n ] [ n ] ; for ( int a_i = 0 ; a_i < n ; a_i ++ ) { for ( int a_j = 0 ; a_j < n ; a_j ++ ) { a [ a_i ] [ a_j ] = in . nextInt ( ) ; } } int l_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { l_sum += a [ i ] [ i ] ; } int r_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { r_sum += a [ j ] [ n - 1 - j ] ; } int sum = l_sum + r_sum ; System . out . println ( sum ) ; }
1510,int [ ] createArray ( int size ) { int [ ] array = new int [ size ] ; int half = ( size / 2 ) + ( size % 2 ) ; int index = half ; int value = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( i == index ) { half = ( half / 2 ) + ( half % 2 ) ; index += half ; value ++ ; } array [ i ] = value ; } return array ; }
1511,"int [ ] createArray ( int size ) { int [ ] result = new int [ size ] ; int limit = ( size + 1 ) / 2 ; int start = 0 , value = 0 , idx = 0 ; do { for ( int i = start ; i < start + limit && idx < size ; ++ i ) result [ idx ++ ] = value ; start += limit ; limit = ( limit + 1 ) / 2 ; ++ value ; } while ( idx < size ) ; return result ; }"
1512,"String toHexString ( byte [ ] bytes ) { char [ ] hexArray = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] hexChars = new char [ bytes . length * 2 ] ; int v ; for ( int j = 0 ; j < bytes . length ; j ++ ) { v = bytes [ j ] & 0xFF ; hexChars [ j * 2 ] = hexArray [ v / 16 ] ; hexChars [ j * 2 + 1 ] = hexArray [ v % 16 ] ; } return new String ( hexChars ) ; }"
1513,String toHexString ( byte [ ] bytes ) { StringBuilder hexString = new StringBuilder ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { String hex = Integer . toHexString ( 0xFF & bytes [ i ] ) ; if ( hex . length ( ) == 1 ) { hexString . append ( '0' ) ; } hexString . append ( hex ) ; } return hexString . toString ( ) ; }
1514,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1515,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
1516,"int maxBlock ( String str ) { Pattern pattern = Pattern . compile ( ""(.)(\\1)*"" ) ; Matcher matcher = pattern . matcher ( str ) ; int max = 0 ; while ( matcher . find ( ) ) { max = Math . max ( max , matcher . group ( ) . length ( ) ) ; } return max ; }"
1517,int maxBlock ( String str ) { int max = 0 ; int count = 1 ; char o = ' ' ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c == o ) { count ++ ; if ( count > max ) { max = count ; } } else { count = 1 ; if ( count > max ) { max = count ; } } o = c ; } return max ; }
1518,void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int leftStartDiagnol = 0 ; int rightStartDiagnol = n ; int leftTotal = 0 ; int rightTotal = 0 ; int a [ ] [ ] = new int [ n ] [ n ] ; for ( int a_i = 0 ; a_i < n ; a_i ++ ) { for ( int a_j = 0 ; a_j < n ; a_j ++ ) { a [ a_i ] [ a_j ] = in . nextInt ( ) ; } } for ( int a_i = 0 ; a_i < n ; a_i ++ ) { boolean leftNotFound = true ; boolean rightNotFound = true ; rightStartDiagnol = -- rightStartDiagnol ; for ( int a_j = 0 ; a_j < n ; a_j ++ ) { if ( leftStartDiagnol == a_j && leftNotFound ) { leftTotal = leftTotal + a [ a_i ] [ a_j ] ; leftNotFound = false ; } if ( rightStartDiagnol == a_j && rightNotFound ) { rightTotal = rightTotal + a [ a_i ] [ a_j ] ; rightNotFound = false ; } } leftStartDiagnol = ++ leftStartDiagnol ; } int data = leftTotal - rightTotal ; System . out . println ( Math . abs ( data ) ) ; }
1519,void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int a [ ] [ ] = new int [ n ] [ n ] ; for ( int a_i = 0 ; a_i < n ; a_i ++ ) { for ( int a_j = 0 ; a_j < n ; a_j ++ ) { a [ a_i ] [ a_j ] = in . nextInt ( ) ; } } int l_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { l_sum += a [ i ] [ i ] ; } int r_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { r_sum += a [ j ] [ n - 1 - j ] ; } int sum = l_sum + r_sum ; System . out . println ( sum ) ; }
1520,"void main ( String [ ] args ) throws Exception { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document document = db . parse ( new File ( ""input.xml"" ) ) ; NodeList nodeList = document . getElementsByTagName ( ""Item"" ) ; for ( int x = 0 , size = nodeList . getLength ( ) ; x < size ; x ++ ) { System . out . println ( nodeList . item ( x ) . getAttributes ( ) . getNamedItem ( ""name"" ) . getNodeValue ( ) ) ; } }"
1521,"void main ( String [ ] s ) throws VTDException { VTDGen vg = new VTDGen ( ) ; if ( ! vg . parseFile ( ""input.xml"" , false ) ) return ; VTDNav vn = vg . getNav ( ) ; AutoPilot ap = new AutoPilot ( vn ) ; ap . selectXPath ( ""/xml/item/@name"" ) ; int i = 0 ; while ( ( i = ap . evalXPath ( ) ) != - 1 ) { System . out . println ( "" item name is ===>"" + vn . toString ( i + 1 ) ) ; } }"
1522,String toHexString ( byte bytes [ ] ) { if ( bytes == null ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; for ( int iter = 0 ; iter < bytes . length ; iter ++ ) { byte high = ( byte ) ( ( bytes [ iter ] & 0xf0 ) > > 4 ) ; byte low = ( byte ) ( bytes [ iter ] & 0x0f ) ; sb . append ( nibble2char ( high ) ) ; sb . append ( nibble2char ( low ) ) ; } return sb . toString ( ) ; }
1523,String toHexString ( byte [ ] bytes ) { StringBuilder hexString = new StringBuilder ( ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { String hex = Integer . toHexString ( 0xFF & bytes [ i ] ) ; if ( hex . length ( ) == 1 ) { hexString . append ( '0' ) ; } hexString . append ( hex ) ; } return hexString . toString ( ) ; }
1524,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1525,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! """" . equals ( highName ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! """" . equals ( lowName ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! """" . equals ( lowName ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1526,"void actionPerformed ( ActionEvent e ) { tick ( ) ; int delta = 20 ; int width = SPRITE_WIDTH + 2 * delta ; int height = width ; if ( moved ) { int x = oldMX - delta ; int y = oldMY - delta ; repaint ( x , y , width , height ) ; } int x = mX - delta ; int y = mY - delta ; repaint ( x , y , width , height ) ; moved = false ; }"
1527,void actionPerformed ( ActionEvent e ) { switch ( direction ) { case UP : draw . incrementY ( false ) ; break ; case DOWN : draw . incrementY ( true ) ; break ; case LEFT : draw . incrementX ( false ) ; break ; case RIGHT : draw . incrementX ( true ) ; break ; default : break ; } }
1528,"int solution ( int N ) { String binary = Integer . toString ( N , 2 ) ; int largestGap = 0 ; for ( int i = 1 , gap = 0 ; i < binary . length ( ) ; i ++ ) { while ( i < binary . length ( ) && binary . charAt ( i ) == '0' ) { i ++ ; gap ++ ; } if ( gap > largestGap && i < binary . length ( ) ) { largestGap = gap ; } gap = 0 ; } return largestGap ; }"
1529,"int solution ( Integer number ) { String binary = Integer . toBinaryString ( number ) ; String [ ] gaps = binary . split ( ""1"" ) ; String biggestGap = """" ; for ( int i = 0 ; i < ( binary . endsWith ( ""1"" ) ? gaps . length : gaps . length - 1 ) ; i ++ ) { if ( gaps [ i ] . contains ( ""0"" ) && gaps [ i ] . length ( ) > biggestGap . length ( ) ) biggestGap = gaps [ i ] ; } return biggestGap . length ( ) ; }"
1530,"void parseComments ( String tmpFile , Workbook workbook ) { try { FileInputStream fin = new FileInputStream ( tmpFile ) ; final ZipInputStream zin = new ZipInputStream ( fin ) ; InputStream in = getInputStream ( zin ) ; while ( true ) { ZipEntry entry = zin . getNextEntry ( ) ; if ( entry == null ) break ; String name = entry . getName ( ) ; if ( name . endsWith ( "".xml"" ) ) { if ( name . contains ( COMMENTS ) ) { parseComments ( in , workbook ) ; } } zin . closeEntry ( ) ; } in . close ( ) ; zin . close ( ) ; fin . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( e ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
1531,"void parseComments ( InputStream in , Workbook workbook ) { try { DefaultHandler handler = getCommentHandler ( workbook ) ; SAXParser saxParser = getSAXParser ( ) ; saxParser . parse ( in , handler ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }"
1532,Key secondMaxKey ( ) { if ( this . size ( ) <= 1 ) return null ; if ( this . size ( ) == 2 ) { if ( first . key . compareTo ( first . next . key ) > 0 ) { return first . next . key ; } } Key max = first . key ; Key secondMax = first . next . key ; Node n = first ; for ( Node x = n . next ; x != null ; x = x . next ) { if ( x . key . compareTo ( max ) >= 0 ) { secondMax = max ; max = x . key ; } else if ( x . key . compareTo ( secondMax ) > 0 ) secondMax = x . key ; } return secondMax ; }
1533,Key secondMaxKey ( ) { if ( size ( ) < 2 ) { return null ; } Node max = null ; Node max_2 = null ; Node second = first . next ; if ( first . key . compareTo ( second . key ) > 0 ) { max = first ; max_2 = second ; } else { max = second ; max_2 = first ; } for ( Node x = second . next ; x != null ; x = x . next ) { if ( x . key . compareTo ( max . key ) > 0 ) { max_2 = max ; max = x ; } else if ( ( x . key . compareTo ( max_2 . key ) > 0 ) && ( x . key . compareTo ( max . key ) < 0 ) ) { max_2 = x ; } } return max_2 . key ; }
1534,"void main ( String [ ] args ) { ArrayList < String > al = new ArrayList < String > ( ) ; Scanner sc = new Scanner ( System . in ) ; while ( true ) { System . out . print ( ""Enter name:"" ) ; String temp = sc . next ( ) ; if ( al . isEmpty ( ) != true ) { if ( temp . equals ( al . get ( 0 ) ) ) break ; } al . add ( temp ) ; } for ( int i = 0 ; i < al . size ( ) ; i ++ ) { System . out . println ( al . get ( i ) ) ; } }"
1535,"void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int numOfItems = 20 , maxItems = 0 ; String arrayOfNames [ ] = new String [ numOfItems ] ; String Temp = """" ; for ( int i = 0 ; i < arrayOfNames . length ; i ++ ) { System . out . print ( ""Enter Item "" + ( i + 1 ) + "" : "" ) ; Temp = scan . nextLine ( ) ; if ( Temp . equals ( arrayOfNames [ 0 ] ) ) { maxItems = i ; break ; } else { arrayOfNames [ i ] = Temp ; } } for ( int i = 0 ; i < maxItems ; i ++ ) { System . out . print ( ""Item # "" + ( i + 1 ) + "" : "" ) ; System . out . print ( arrayOfNames [ i ] + ""\n"" ) ; } }"
1536,void type ( char c ) { keyPress ( VK_ALT ) ; keyPress ( VK_NUMPAD0 ) ; keyRelease ( VK_NUMPAD0 ) ; String altCode = Integer . toString ( c ) ; for ( int i = 0 ; i < altCode . length ( ) ; i ++ ) { c = ( char ) ( altCode . charAt ( i ) + '0' ) ; keyPress ( c ) ; keyRelease ( c ) ; } keyRelease ( VK_ALT ) ; }
1537,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_SHIFT , VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_AT ) ; break ; case '#' : doType ( VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_AMPERSAND ) ; break ; case '*' : doType ( VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
1538,"String shuffle ( String text ) { if ( text . length ( ) <= 1 ) return text ; int split = text . length ( ) / 2 ; String temp1 = shuffle ( text . substring ( 0 , split ) ) ; String temp2 = shuffle ( text . substring ( split ) ) ; if ( Math . random ( ) > 0.5 ) return temp1 + temp2 ; else return temp2 + temp1 ; }"
1539,String shuffle ( String text ) { char [ ] characters = text . toCharArray ( ) ; for ( int i = 0 ; i < characters . length ; i ++ ) { int randomIndex = ( int ) ( Math . random ( ) * characters . length ) ; char temp = characters [ i ] ; characters [ i ] = characters [ randomIndex ] ; characters [ randomIndex ] = temp ; } return new String ( characters ) ; }
1540,"void actionPerformed ( ActionEvent arg0 ) { int result = JOptionPane . OK_OPTION ; if ( dirty ) { result = JOptionPane . showConfirmDialog ( gui , ""Erase the current painting?"" ) ; } if ( result == JOptionPane . OK_OPTION ) { clear ( canvasImage ) ; } }"
1541,void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == select ) { activeTool = SELECTION_TOOL ; } else if ( ae . getSource ( ) == draw ) { activeTool = DRAW_TOOL ; } else if ( ae . getSource ( ) == text ) { activeTool = TEXT_TOOL ; } }
1542,"void type ( char character ) { switch ( character ) { case 'a' : doType ( VK_A ) ; break ; case 'b' : doType ( VK_B ) ; break ; case 'c' : doType ( VK_C ) ; break ; case 'd' : doType ( VK_D ) ; break ; case 'e' : doType ( VK_E ) ; break ; case 'f' : doType ( VK_F ) ; break ; case 'g' : doType ( VK_G ) ; break ; case 'h' : doType ( VK_H ) ; break ; case 'i' : doType ( VK_I ) ; break ; case 'j' : doType ( VK_J ) ; break ; case 'k' : doType ( VK_K ) ; break ; case 'l' : doType ( VK_L ) ; break ; case 'm' : doType ( VK_M ) ; break ; case 'n' : doType ( VK_N ) ; break ; case 'o' : doType ( VK_O ) ; break ; case 'p' : doType ( VK_P ) ; break ; case 'q' : doType ( VK_Q ) ; break ; case 'r' : doType ( VK_R ) ; break ; case 's' : doType ( VK_S ) ; break ; case 't' : doType ( VK_T ) ; break ; case 'u' : doType ( VK_U ) ; break ; case 'v' : doType ( VK_V ) ; break ; case 'w' : doType ( VK_W ) ; break ; case 'x' : doType ( VK_X ) ; break ; case 'y' : doType ( VK_Y ) ; break ; case 'z' : doType ( VK_Z ) ; break ; case 'A' : doType ( VK_SHIFT , VK_A ) ; break ; case 'B' : doType ( VK_SHIFT , VK_B ) ; break ; case 'C' : doType ( VK_SHIFT , VK_C ) ; break ; case 'D' : doType ( VK_SHIFT , VK_D ) ; break ; case 'E' : doType ( VK_SHIFT , VK_E ) ; break ; case 'F' : doType ( VK_SHIFT , VK_F ) ; break ; case 'G' : doType ( VK_SHIFT , VK_G ) ; break ; case 'H' : doType ( VK_SHIFT , VK_H ) ; break ; case 'I' : doType ( VK_SHIFT , VK_I ) ; break ; case 'J' : doType ( VK_SHIFT , VK_J ) ; break ; case 'K' : doType ( VK_SHIFT , VK_K ) ; break ; case 'L' : doType ( VK_SHIFT , VK_L ) ; break ; case 'M' : doType ( VK_SHIFT , VK_M ) ; break ; case 'N' : doType ( VK_SHIFT , VK_N ) ; break ; case 'O' : doType ( VK_SHIFT , VK_O ) ; break ; case 'P' : doType ( VK_SHIFT , VK_P ) ; break ; case 'Q' : doType ( VK_SHIFT , VK_Q ) ; break ; case 'R' : doType ( VK_SHIFT , VK_R ) ; break ; case 'S' : doType ( VK_SHIFT , VK_S ) ; break ; case 'T' : doType ( VK_SHIFT , VK_T ) ; break ; case 'U' : doType ( VK_SHIFT , VK_U ) ; break ; case 'V' : doType ( VK_SHIFT , VK_V ) ; break ; case 'W' : doType ( VK_SHIFT , VK_W ) ; break ; case 'X' : doType ( VK_SHIFT , VK_X ) ; break ; case 'Y' : doType ( VK_SHIFT , VK_Y ) ; break ; case 'Z' : doType ( VK_SHIFT , VK_Z ) ; break ; case '`' : doType ( VK_BACK_QUOTE ) ; break ; case '0' : doType ( VK_0 ) ; break ; case '1' : doType ( VK_1 ) ; break ; case '2' : doType ( VK_2 ) ; break ; case '3' : doType ( VK_3 ) ; break ; case '4' : doType ( VK_4 ) ; break ; case '5' : doType ( VK_5 ) ; break ; case '6' : doType ( VK_6 ) ; break ; case '7' : doType ( VK_7 ) ; break ; case '8' : doType ( VK_8 ) ; break ; case '9' : doType ( VK_9 ) ; break ; case '-' : doType ( VK_MINUS ) ; break ; case '=' : doType ( VK_EQUALS ) ; break ; case '~' : doType ( VK_BACK_QUOTE ) ; break ; case '!' : doType ( VK_SHIFT , VK_EXCLAMATION_MARK ) ; break ; case '@' : doType ( VK_SHIFT , VK_AT ) ; break ; case '#' : doType ( VK_SHIFT , VK_NUMBER_SIGN ) ; break ; case '$' : doType ( VK_SHIFT , VK_DOLLAR ) ; break ; case '%' : doType ( VK_SHIFT , VK_5 ) ; break ; case '^' : doType ( VK_SHIFT , VK_CIRCUMFLEX ) ; break ; case '&' : doType ( VK_SHIFT , VK_AMPERSAND ) ; break ; case '*' : doType ( VK_SHIFT , VK_ASTERISK ) ; break ; case '(' : doType ( VK_LEFT_PARENTHESIS ) ; break ; case ')' : doType ( VK_RIGHT_PARENTHESIS ) ; break ; case '_' : doType ( VK_SHIFT , VK_UNDERSCORE ) ; break ; case '+' : doType ( VK_SHIFT , VK_PLUS ) ; break ; case '\t' : doType ( VK_TAB ) ; break ; case '\n' : doType ( VK_ENTER ) ; break ; case '[' : doType ( VK_OPEN_BRACKET ) ; break ; case ']' : doType ( VK_CLOSE_BRACKET ) ; break ; case '\\' : doType ( VK_BACK_SLASH ) ; break ; case '{' : doType ( VK_SHIFT , VK_OPEN_BRACKET ) ; break ; case '}' : doType ( VK_SHIFT , VK_CLOSE_BRACKET ) ; break ; case '|' : doType ( VK_SHIFT , VK_BACK_SLASH ) ; break ; case ';' : doType ( VK_SEMICOLON ) ; break ; case ':' : doType ( VK_SHIFT , VK_COLON ) ; break ; case '\'' : doType ( VK_QUOTE ) ; break ; case '""' : doType ( VK_SHIFT , VK_QUOTEDBL ) ; break ; case ',' : doType ( VK_COMMA ) ; break ; case '<' : doType ( VK_SHIFT , VK_COMMA ) ; break ; case '.' : doType ( VK_PERIOD ) ; break ; case '>' : doType ( VK_SHIFT , VK_PERIOD ) ; break ; case '/' : doType ( VK_SLASH ) ; break ; case '?' : doType ( VK_SHIFT , VK_SLASH ) ; break ; case ' ' : doType ( VK_SPACE ) ; break ; case '\b' : doType ( VK_BACK_SPACE ) ; break ; default : throw new IllegalArgumentException ( ""Cannot type character "" + character ) ; } }"
1543,void type ( String text ) { char c ; for ( int ii = 0 ; ii < text . length ( ) ; ii ++ ) { c = text . charAt ( ii ) ; if ( c <= 31 || c == 129 ) { pressControlKey ( c ) ; } else { typeAsciiCode ( c ) ; } } }
1544,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1545,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
1546,"String getString ( ) { String result = """" ; while ( true ) { String message = inputGenerator . getMessage ( ) ; result += message ; if ( ! message . startsWith ( ""hi"" ) ) { break ; } } return result ; }"
1547,"String getString ( ) { StringBuilder msg = new StringBuilder ( ) ; String read ; do { read = inputGenerator . getMessage ( ) ; msg . append ( read ) ; } while ( read . toLowerCase ( ) . startsWith ( ""hi"" ) ) ; return msg . toString ( ) ; }"
1548,"Date addBusinessDays ( Date day , int days , int weekendPattern ) { Calendar ret = Calendar . getInstance ( ) ; if ( day != null ) { ret . setTime ( day ) ; } if ( days != 0 ) { int startDayofWeek = ret . get ( Calendar . DAY_OF_WEEK ) - 1 ; int idx = days > 0 ? 0 : 3 ; int howManyWeekendDays = 0 ; int [ ] [ ] adjV = adjVector [ weekendPattern ] ; int numWeekendDaysInOneWeek = adjV [ idx + 1 ] . length ; for ( int i = 0 ; i < numWeekendDaysInOneWeek ; i ++ ) { int adjustmentA = adjV [ idx ] [ startDayofWeek ] ; int adjustmentB = adjV [ idx + 1 ] [ i ] ; howManyWeekendDays += ( days - adjustmentA - adjustmentB ) / ( 7 - numWeekendDaysInOneWeek ) ; } int adjustmentC = adjV [ idx + 2 ] [ startDayofWeek ] ; howManyWeekendDays += adjustmentC ; ret . add ( Calendar . DATE , days + howManyWeekendDays ) ; } return ret . getTime ( ) ; }"
1549,"Date addBusinessDays ( Date date , int days ) { DateTime result = new DateTime ( date ) ; result = isWeekEnd ( result ) ? getPreviousBusinessDate ( result ) : result ; for ( int i = 0 ; i < days ; i ++ ) { if ( isWeekEnd ( result ) ) { i -- ; } result = result . plusDays ( 1 ) ; } return result . toDate ( ) ; }"
1550,"void sort ( int [ ] input ) { for ( int i = 0 ; i < input . length ; i ++ ) { for ( int j = i + 1 ; j < input . length ; j ++ ) { if ( input [ i ] > input [ j ] ) { int tmp = input [ i ] ; input [ i ] = input [ j ] ; input [ j ] = tmp ; } } } System . out . println ( ""Slow sorting is done and the result is :"" ) ; for ( int i : input ) { System . out . print ( i + "","" ) ; } }"
1551,"void sort ( int [ ] input , int startIndx , int endIndx ) { int endIndexOrig = endIndx ; int startIndexOrig = startIndx ; if ( startIndx >= endIndx ) return ; int pavitVal = input [ endIndx ] ; while ( startIndx <= endIndx ) { while ( input [ startIndx ] < pavitVal ) startIndx ++ ; while ( input [ endIndx ] > pavitVal ) endIndx -- ; if ( startIndx <= endIndx ) { int tmp = input [ startIndx ] ; input [ startIndx ] = input [ endIndx ] ; input [ endIndx ] = tmp ; startIndx ++ ; endIndx -- ; } } sort ( input , startIndexOrig , endIndx ) ; sort ( input , startIndx , endIndexOrig ) ; }"
1552,"Node reverse ( Node root ) { if ( root == null || root . next == null ) { return root ; } Node curr , prev , next ; curr = root ; prev = next = null ; while ( curr != null ) { next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; }"
1553,"ListNode reverse ( ListNode toBeNextNode , ListNode currentNode ) { ListNode currentHead = currentNode ; if ( ( currentNode == null || currentNode . next == null ) && toBeNextNode == null ) return currentHead ; if ( currentNode . next != null ) currentHead = reverse ( currentNode , currentNode . next ) ; currentNode . next = toBeNextNode ; return currentHead ; }"
1554,"boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( ( keyCode == KeyEvent . KEYCODE_VOLUME_DOWN ) ) { return true ; } else if ( ( keyCode == KeyEvent . KEYCODE_VOLUME_UP ) ) { return true ; } else return super . onKeyDown ( keyCode , event ) ; }"
1555,"boolean onKeyDown ( int keyCode , KeyEvent event ) { super . onKeyDown ( keyCode , event ) ; if ( keyCode == KeyEvent . KEYCODE_VOLUME_DOWN ) { Toast . makeText ( MainActivity . this , ""Down working"" , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } return false ; }"
1556,"String getDurationBreakdown ( long millis ) { if ( millis < 0 ) { throw new IllegalArgumentException ( ""Duration must be greater than zero!"" ) ; } long days = TimeUnit . MILLISECONDS . toDays ( millis ) ; long hours = TimeUnit . MILLISECONDS . toHours ( millis ) % 24 ; long minutes = TimeUnit . MILLISECONDS . toMinutes ( millis ) % 60 ; long seconds = TimeUnit . MILLISECONDS . toSeconds ( millis ) % 60 ; long milliseconds = millis % 1000 ; return String . format ( ""%d Days %d Hours %d Minutes %d Seconds %d Milliseconds"" , days , hours , minutes , seconds , milliseconds ) ; }"
1557,"String getDurationBreakdown ( long millis ) { String [ ] units = { "" Days "" , "" Hours "" , "" Minutes "" , "" Seconds "" } ; Long [ ] values = new Long [ units . length ] ; if ( millis < 0 ) { throw new IllegalArgumentException ( ""Duration must be greater than zero!"" ) ; } values [ 0 ] = TimeUnit . MILLISECONDS . toDays ( millis ) ; millis -= TimeUnit . DAYS . toMillis ( values [ 0 ] ) ; values [ 1 ] = TimeUnit . MILLISECONDS . toHours ( millis ) ; millis -= TimeUnit . HOURS . toMillis ( values [ 1 ] ) ; values [ 2 ] = TimeUnit . MILLISECONDS . toMinutes ( millis ) ; millis -= TimeUnit . MINUTES . toMillis ( values [ 2 ] ) ; values [ 3 ] = TimeUnit . MILLISECONDS . toSeconds ( millis ) ; StringBuilder sb = new StringBuilder ( 64 ) ; boolean startPrinting = false ; for ( int i = 0 ; i < units . length ; i ++ ) { if ( ! startPrinting && values [ i ] != 0 ) startPrinting = true ; if ( startPrinting ) { sb . append ( values [ i ] ) ; sb . append ( units [ i ] ) ; } } return ( sb . toString ( ) ) ; }"
1558,"void main ( String [ ] args ) { List < String > list1 = new LinkedList < > ( Arrays . asList ( ""Cat"" , ""Mouse"" , ""Dog"" ) ) ; List < String > list2 = new LinkedList < > ( Arrays . asList ( ""Dog"" , ""Mouse"" , ""Cat"" ) ) ; List < String > list3 = new LinkedList < > ( Arrays . asList ( ""Dog"" , ""Horse"" , ""Cat"" ) ) ; List < String > list4 = new LinkedList < > ( Arrays . asList ( ""Dog"" , ""Tiger"" , ""Lion"" ) ) ; List < List < String > > list = new LinkedList < > ( Arrays . asList ( list1 , list2 , list3 , list4 ) ) ; boolean flag = false ; boolean matchFlag = true ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < list . size ( ) ; j ++ ) { if ( list . get ( i ) . size ( ) == list . get ( j ) . size ( ) ) { matchFlag = true ; for ( String str : list . get ( i ) ) { flag = false ; for ( String string : list . get ( j ) ) { if ( str . equals ( string ) ) { flag = true ; } } if ( flag == false ) { matchFlag = false ; break ; } } if ( matchFlag ) { list . remove ( j ) ; j -- ; } } } } System . out . println ( list . size ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . println ( list . get ( i ) ) ; } }"
1559,"void main ( String [ ] args ) { List < Animal > list1 = new LinkedList < > ( Arrays . asList ( Cat , Mouse , Dog ) ) ; List < Animal > list2 = new LinkedList < > ( Arrays . asList ( Dog , Mouse , Cat ) ) ; List < Animal > list3 = new LinkedList < > ( Arrays . asList ( Dog , Horse , Cat ) ) ; List < Animal > list4 = new LinkedList < > ( Arrays . asList ( Dog , Tiger , Lion ) ) ; List < List < Animal > > list = new LinkedList < > ( Arrays . asList ( list1 , list2 , list3 , list4 ) ) ; Set < List < Animal > > sorted = new LinkedHashSet < > ( ) ; for ( List < Animal > animals : list ) { List < Animal > arList = new ArrayList < > ( animals ) ; Collections . sort ( arList ) ; sorted . add ( new LinkedList < > ( arList ) ) ; } for ( List < Animal > animals : sorted ) { System . out . println ( animals ) ; } }"
1560,String transpose ( String s ) { char [ ] c = s . toCharArray ( ) ; int n = ( int ) Math . sqrt ( s . length ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { char h = c [ i * n + j ] ; c [ i * n + j ] = c [ j * n + i ] ; c [ j * n + i ] = h ; } } return new String ( c ) ; }
1561,"String transpose ( String s , int rows , int columns ) { int n = s . length ( ) ; if ( rows * columns != n ) throw new IllegalArgumentException ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) sb . append ( s . charAt ( i * columns % ( n - 1 ) ) ) ; sb . append ( s . charAt ( n - 1 ) ) ; return sb . toString ( ) ; }"
1562,void mouseDragged ( MouseEvent me ) { super . mouseDragged ( me ) ; if ( me . getX ( ) < startX ) { x -= 2 ; } else if ( me . getX ( ) > startX ) { x += 2 ; } if ( me . getY ( ) < startY ) { y -= 2 ; } else if ( me . getY ( ) > startY ) { y += 2 ; } repaint ( ) ; }
1563,"void mouseDragged ( MouseEvent e ) { JViewport vport = ( JViewport ) e . getSource ( ) ; JComponent label = ( JComponent ) vport . getView ( ) ; Point cp = e . getPoint ( ) ; Point vp = vport . getViewPosition ( ) ; vp . translate ( pp . x - cp . x , pp . y - cp . y ) ; label . scrollRectToVisible ( new Rectangle ( vp , vport . getSize ( ) ) ) ; pp . setLocation ( cp ) ; }"
1564,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
1565,"void run ( ) { int i = 2 ; while ( i < 50 ) { while ( s . getState ( ) != 1 ) { synchronized ( s ) { try { s . wait ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } synchronized ( s ) { if ( s . getState ( ) == 1 ) System . out . println ( ""t2 "" + i ) ; s . setState ( 2 ) ; i = i + 3 ; s . notifyAll ( ) ; } } }"
1566,"String getLongestSubstring ( String s ) { int length = 1 ; String longestString = """" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { StringBuilder str = new StringBuilder ( ) ; str . append ( s . charAt ( i ) ) ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { str . append ( s . charAt ( j ) ) ; } else { break ; } } if ( length < str . length ( ) ) { length = str . length ( ) ; longestString = str . toString ( ) ; } } return longestString ; }"
1567,"String getLongestSubstring ( String s ) { if ( s . length ( ) == 0 ) return null ; char currentChar = s . charAt ( 0 ) ; String longestString = """" + currentChar ; String runningString = """" + currentChar ; int currentLongestLength = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == currentChar ) { runningString = runningString + currentChar ; if ( runningString . length ( ) > longestString . length ( ) ) { currentLongestLength ++ ; longestString = runningString ; } } else { runningString = """" + s . charAt ( i ) ; } } return longestString ; }"
1568,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
1569,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
1570,"String sequenceNums ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( ) ; int rangeStart = nums [ 0 ] ; int previous = nums [ 0 ] ; int current ; int expected = previous + 1 ; for ( int i = 1 ; i < nums . length ; i ++ ) { current = nums [ i ] ; expected = previous + 1 ; if ( current != expected || i == ( nums . length - 1 ) ) { if ( current == rangeStart ) { sb . append ( previous + "","" ) ; } else { if ( rangeStart != previous ) { if ( i == nums . length - 1 ) sb . append ( rangeStart + ""-"" + current ) ; else sb . append ( rangeStart + ""-"" + previous + "","" ) ; } else { if ( i == nums . length - 1 ) sb . append ( rangeStart + "","" + current ) ; else sb . append ( rangeStart + "","" ) ; } } rangeStart = current ; } previous = current ; } if ( sb . charAt ( sb . length ( ) - 1 ) == ',' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }"
1571,"String sequenceNums ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( ) ; if ( nums . length == 0 ) return sb . toString ( ) ; int begin = nums [ 0 ] , end = nums [ 0 ] ; for ( int cur : nums ) if ( cur - end <= 1 ) end = cur ; else { appendRange ( sb , begin , end ) ; begin = end = cur ; } appendRange ( sb , begin , end ) ; return sb . substring ( 1 ) ; }"
1572,"void main ( String [ ] args ) throws Exception { for ( int len : new int [ ] { 100 * 1000 * 1000 , 10 * 1000 * 1000 , 1000 * 1000 , 100 * 1000 , 10 * 1000 , 1000 } ) { int [ ] nums = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) nums [ i ] = ( int ) ( Math . random ( ) * ( Math . random ( ) * 2001 - 1000 ) ) ; Arrays . sort ( nums ) ; long timeArray = 0 ; long timeSet = 0 ; int runs = len > 1000 * 1000 ? 10 : len >= 100 * 1000 ? 100 : 1000 ; for ( int i = 0 ; i < runs ; i ++ ) { long time1 = System . nanoTime ( ) ; int count = countDistinct ( nums ) ; long time2 = System . nanoTime ( ) ; int count2 = countDistinctUsingSet ( nums ) ; long time3 = System . nanoTime ( ) ; timeArray += time2 - time1 ; timeSet += time3 - time2 ; assert count == count2 ; } System . out . printf ( ""For %,d numbers, using an array took %,d us on average, using a Set took %,d us on average, ratio=%.1f%n"" , len , timeArray / 1000 / runs , timeSet / 1000 / runs , 1.0 * timeSet / timeArray ) ; } }"
1573,"void main ( String [ ] args ) throws Exception { CodilityTest o_tc = new CodilityTest ( ) ; int [ ] x = { 1 , 2 , - 3 , 4 , - 5 , - 11 , - 2 , 3 , - 4 , 5 } ; int [ ] y = new int [ 0 ] ; o_tc . setInput ( x ) ; o_tc . getOutput ( x ) ; System . out . println ( count ) ; CodilityTest o_tc1 = new CodilityTest ( ) ; o_tc1 . getOutput ( y ) ; }"
1574,"String replace ( String old , String newWord , String input ) { int i = input . indexOf ( old ) ; if ( i < 0 ) { return input ; } String partBefore = input . substring ( 0 , i ) ; String partAfter = input . substring ( i + old . length ( ) ) ; return partBefore + newWord + replace ( old , newWord , partAfter ) ; }"
1575,"String replace ( String oldStr , String newStr , String input ) { StringBuilder sb = new StringBuilder ( ) ; int i ; int prev = 0 ; while ( ( i = input . indexOf ( oldStr , prev ) ) >= 0 ) { sb . append ( input . substring ( prev , i ) ) . append ( newStr ) ; prev = i + oldStr . length ( ) ; } sb . append ( input . substring ( prev ) ) ; return sb . toString ( ) ; }"
1576,"void main ( String [ ] args ) { System . out . println ( ""Enter no of rows to be printed"" ) ; int row = Integer . parseInt ( args [ 0 ] ) ; int len = args . length ; if ( len <= 0 ) { System . out . println ( "" ERROR: Please input a value of 1-5"" ) ; System . exit ( 0 ) ; } int j ; for ( int i = 0 ; i <= row ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) System . out . print ( ""*"" ) ; System . out . println ( """" ) ; } }"
1577,"void main ( String [ ] args ) { int len = args . length ; if ( len == 0 ) { sopl ( ""\n\tUsage: java echo <args:String[]>"" ) ; System . exit ( 0 ) ; } sop ( ""\n\t"" ) ; for ( int i = 0 ; i < len ; i ++ ) { sop ( args [ i ] + "" "" ) ; } sop ( ""\n\t"" ) ; while ( len > 0 ) sop ( args [ args . length - len -- ] + "" "" ) ; sopl ( """" ) ; }"
1578,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { String formatedSource = source . subSequence ( start , end ) . toString ( ) ; String destPrefix = dest . subSequence ( 0 , dstart ) . toString ( ) ; String destSuffix = dest . subSequence ( dend , dest . length ( ) ) . toString ( ) ; String result = destPrefix + formatedSource + destSuffix ; result = result . replace ( "","" , ""."" ) ; Matcher matcher = mPattern . matcher ( result ) ; if ( matcher . matches ( ) ) { return null ; } return """" ; }"
1579,"CharSequence filter ( CharSequence source , int start , int end , Spanned dest , int dstart , int dend ) { CharSequence out = super . filter ( source , start , end , dest , dstart , dend ) ; if ( out != null ) { source = out ; start = 0 ; end = out . length ( ) ; } int len = end - start ; if ( len == 0 ) { return source ; } int dlen = dest . length ( ) ; for ( int i = 0 ; i < dstart ; i ++ ) { if ( dest . charAt ( i ) == '.' ) { return ( dlen - ( i + 1 ) + len > digits ) ? """" : new SpannableStringBuilder ( source , start , end ) ; } } for ( int i = start ; i < end ; ++ i ) { if ( source . charAt ( i ) == '.' ) { if ( ( dlen - dend ) + ( end - ( i + 1 ) ) > digits ) return """" ; else break ; } } return new SpannableStringBuilder ( source , start , end ) ; }"
1580,"String [ ] [ ] allUniqueCombinations ( ) { List < String > labels = new ArrayList < String > ( ) ; List < List < String > > lists = new ArrayList < List < String > > ( ) ; for ( Map . Entry < String , Vector < String > > entry : dataStructure . entrySet ( ) ) { labels . add ( entry . getKey ( ) ) ; lists . add ( entry . getValue ( ) ) ; } List < List < String > > combinations = product ( lists ) ; int m = combinations . size ( ) + 1 ; int n = labels . size ( ) ; String [ ] [ ] answer = new String [ m ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) answer [ 0 ] [ i ] = labels . get ( i ) ; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) answer [ i ] [ j ] = combinations . get ( i - 1 ) . get ( j ) ; return answer ; }"
1581,String [ ] [ ] allUniqueCombinations ( ) { int n = dataStructure . keySet ( ) . size ( ) ; int solutions = 1 ; for ( Vector < String > vector : dataStructure . values ( ) ) { solutions *= vector . size ( ) ; } String [ ] [ ] allCombinations = new String [ solutions + 1 ] [ ] ; allCombinations [ 0 ] = dataStructure . keySet ( ) . toArray ( new String [ n ] ) ; for ( int i = 0 ; i < solutions ; i ++ ) { Vector < String > combination = new Vector < String > ( n ) ; int j = 1 ; for ( Vector < String > vec : dataStructure . values ( ) ) { combination . add ( vec . get ( ( i / j ) % vec . size ( ) ) ) ; j *= vec . size ( ) ; } allCombinations [ i + 1 ] = combination . toArray ( new String [ n ] ) ; } return allCombinations ; }
1582,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
1583,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1584,"void main ( String [ ] args ) { int a = 100 ; int b = 1000 ; int lowest = b ; int highest = a ; int count = 100000 ; Random random = new Random ( ) ; for ( int i = 0 ; i < count ; i ++ ) { int nextNumber = ( int ) ( ( Math . abs ( random . nextDouble ( ) ) * ( b - a ) ) ) + a ; if ( nextNumber < a || nextNumber > b ) { System . err . println ( ""number not in range :"" + nextNumber ) ; } else { System . out . println ( nextNumber ) ; } if ( nextNumber < lowest ) { lowest = nextNumber ; } if ( nextNumber > highest ) { highest = nextNumber ; } } System . out . println ( ""Produced "" + count + "" numbers from "" + lowest + "" to "" + highest ) ; }"
1585,"void main ( String [ ] args ) { Random ran = new Random ( ) ; int min , max ; Scanner sc = new Scanner ( System . in ) ; System . out . println ( ""Enter min range:"" ) ; min = sc . nextInt ( ) ; System . out . println ( ""Enter max range:"" ) ; max = sc . nextInt ( ) ; int num = ran . nextInt ( min ) ; int num1 = ran . nextInt ( max ) ; System . out . println ( ""Random Number between given range is "" + num1 ) ; }"
1586,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1587,"void transform ( HSSFRow rowOld , XSSFRow rowNew ) { XSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; if ( rowOld . getRowStyle ( ) != null ) { Integer hash = rowOld . getRowStyle ( ) . hashCode ( ) ; if ( ! this . styleMap . containsKey ( hash ) ) this . transform ( hash , rowOld . getRowStyle ( ) , this . workbookNew . createCellStyle ( ) ) ; rowNew . setRowStyle ( this . styleMap . get ( hash ) ) ; } for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( ( HSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1588,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
1589,"int solution ( int X , int [ ] A ) { Set < Integer > values = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( values . add ( A [ i ] ) ) X -- ; if ( X == 0 ) return i ; } return - 1 ; }"
1590,"void main ( final String ... args ) { if ( args . length == 0 ) throw new IllegalArgumentException ( ""missing pattern as an argument"" ) ; final Pattern pattern = Pattern . compile ( args [ 0 ] ) ; final Charset cs = Charset . defaultCharset ( ) ; final CharsetDecoder decoder = cs . newDecoder ( ) . onMalformedInput ( CodingErrorAction . REPORT ) ; try ( final Reader r = new InputStreamReader ( System . in , decoder ) ; final BufferedReader reader = new BufferedReader ( r ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) if ( pattern . matcher ( line ) . find ( ) ) System . out . println ( line ) ; } }"
1591,"void main ( String [ ] args ) throws FileNotFoundException { String s = ""this is line one\n"" + ""this is line two\n"" + ""This is line three"" ; Pattern p = Pattern . compile ( ""this"" ) ; Scanner scanner = new Scanner ( s ) ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { System . out . println ( line ) ; } } }"
1592,"void run ( ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex ) { ex . printStackTrace ( ) ; } JFrame frame = new JFrame ( ""Testing"" ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( new TestPane ( ) ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; }"
1593,"void run ( ) { JLabel l = new JLabel ( new ImageIcon ( bi ) ) ; Border twoPartBorder = new CompoundBorder ( new EmptyBorder ( 15 , 15 , 15 , 15 ) , new EtchedBorder ( ) ) ; Border threePartBorder = new CompoundBorder ( twoPartBorder , new EmptyBorder ( 15 , 15 , 15 , 15 ) ) ; l . setBorder ( threePartBorder ) ; JFrame f = new JFrame ( ""Three Part Border"" ) ; f . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; f . setContentPane ( l ) ; f . pack ( ) ; f . setLocationByPlatform ( true ) ; f . setVisible ( true ) ; }"
1594,"void main ( String args [ ] ) { String s1 = ""a b c"" ; int s1_length = s1 . length ( ) ; System . out . println ( s1_length ) ; String s2 = s1 . replace ( "" "" , """" ) ; int s2_length = s2 . length ( ) ; System . out . println ( s2_length ) ; System . out . println ( ""No of spaces = "" + ( s1_length - s2_length ) ) ; }"
1595,"void main ( String [ ] args ) { String word = ""a b c"" ; int i = 0 , spaceCount = 0 ; while ( i < word . length ( ) ) { if ( word . charAt ( i ) == ' ' ) { spaceCount ++ ; } i ++ ; } System . out . println ( ""Spaces in string: "" + spaceCount ) ; }"
1596,"void run ( ) { System . out . println ( ""Outer launched"" ) ; System . out . println ( ""Obtaining lock"" ) ; synchronized ( lock ) { Thread inner = new Thread ( new InnerTask ( lock ) , ""inner"" ) ; inner . start ( ) ; try { inner . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }"
1597,"void run ( ) { String threadName = Thread . currentThread ( ) . getName ( ) ; try { first . lock ( ) ; latch . countDown ( ) ; System . out . println ( threadName + "": locked first lock"" ) ; latch . await ( ) ; System . out . println ( threadName + "": attempting to lock second lock"" ) ; second . lock ( ) ; System . out . println ( threadName + "": never reached"" ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } }"
1598,void run ( ) { try { synchronized ( signal ) { while ( true ) { while ( current . equals ( info ) ) signal . wait ( ) ; System . out . println ( info ) ; current = info ; signal . notify ( ) ; } } } catch ( Exception e ) { } }
1599,void run ( ) { try { while ( true ) { System . out . println ( info ) ; wait ( ) ; } } catch ( Exception e ) { } }
1600,V remove ( Object key ) { readWriteLock . writeLock ( ) . lock ( ) ; V value ; try { value = super . remove ( key ) ; } finally { readWriteLock . writeLock ( ) . unlock ( ) ; } return value ; }
1601,VV remove ( String key ) { synchronized ( lock ) { Item < VV > item = cache . remove ( key ) ; if ( item != null ) { return item . payload ; } else { return null ; } } }
1602,"void main ( String [ ] args ) throws IOException { Process p = Runtime . getRuntime ( ) . exec ( XVFB_COMMAND ) ; FirefoxBinary firefox = new FirefoxBinary ( ) ; firefox . setEnvironmentProperty ( ""DISPLAY"" , "":"" + DISPLAY_NUMBER ) ; WebDriver driver = new FirefoxDriver ( firefox , null ) ; driver . get ( URL ) ; File scrFile = ( ( TakesScreenshot ) driver ) . getScreenshotAs ( OutputType . FILE ) ; FileUtils . copyFile ( scrFile , new File ( RESULT_FILENAME ) ) ; driver . close ( ) ; p . destroy ( ) ; }"
1603,"void main ( String [ ] args ) { try { Robot robot = new Robot ( ) ; BufferedImage bi = robot . createScreenCapture ( new Rectangle ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ) ) ; ImageIO . write ( bi , ""jpg"" , new File ( ""C:/imageTest.jpg"" ) ) ; } catch ( AWTException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }"
1604,"int solution ( int X , int [ ] A ) { int [ ] counter = new int [ X + 1 ] ; int ans = - 1 ; int x = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( counter [ A [ i ] ] == 0 ) { counter [ A [ i ] ] = A [ i ] ; x += 1 ; if ( x == X ) { return i ; } } } return ans ; }"
1605,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
1606,"void main ( String [ ] args ) throws Exception { NestedMap < String , Integer > test = new NestedMap < > ( ) ; test . put ( ""a"" ) . put ( ""b"" ) . put ( ""c"" , 12 ) ; Map . Entry < String , Integer > foo = test . put ( ""a"" ) . put ( ""b"" ) . put ( ""d"" , 12 ) ; test . put ( ""b"" , 14 ) ; ObjectMapper mapper = new ObjectMapper ( ) ; System . out . println ( mapper . writeValueAsString ( test ) ) ; foo . setValue ( 99 ) ; System . out . println ( mapper . writeValueAsString ( test ) ) ; System . out . println ( test . get ( ""a"" ) . get ( ""b"" ) . getValue ( ""d"" ) ) ; }"
1607,"void main ( String ... args ) { Node tree = new Node ( ) ; tree . value = ""root"" ; Node [ ] n = { new Node ( ) , new Node ( ) } ; tree . nodes = n ; tree . nodes [ 0 ] . value = ""leftish"" ; tree . nodes [ 1 ] . value = ""rightish-leafy"" ; Node [ ] nn = { new Node ( ) } ; tree . nodes [ 0 ] . nodes = nn ; tree . nodes [ 0 ] . nodes [ 0 ] . value = ""off-leftish-leaf"" ; System . out . println ( Arrays . toString ( list ( tree , args [ 0 ] ) . toArray ( ) ) ) ; }"
1608,"String inputStreamToString ( InputStream inputStream ) throws IOException { try ( ByteArrayOutputStream result = new ByteArrayOutputStream ( ) ) { byte [ ] buffer = new byte [ 1024 ] ; int length ; while ( ( length = inputStream . read ( buffer ) ) != - 1 ) { result . write ( buffer , 0 , length ) ; } return result . toString ( UTF_8 ) ; } }"
1609,"String inputStreamToString ( InputStream inputStream ) throws IOException { String newLine = System . getProperty ( ""line.separator"" ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; StringBuilder result = new StringBuilder ( UTF_8 ) ; String line ; boolean flag = false ; while ( ( line = reader . readLine ( ) ) != null ) { result . append ( flag ? newLine : """" ) . append ( line ) ; flag = true ; } return result . toString ( ) ; }"
1610,"void main ( String args [ ] ) throws IOException { JavaPingExampleProgram ping = new JavaPingExampleProgram ( ) ; List < String > commands = new ArrayList < String > ( ) ; commands . add ( ""ping"" ) ; commands . add ( ""-c"" ) ; commands . add ( ""5"" ) ; commands . add ( ""74.125.236.73"" ) ; ping . doCommand ( commands ) ; }"
1611,"void main ( String [ ] args ) throws UnknownHostException , IOException { InetAddress inet ; inet = InetAddress . getByAddress ( new byte [ ] { 127 , 0 , 0 , 1 } ) ; System . out . println ( ""Sending Ping Request to "" + inet ) ; System . out . println ( inet . isReachable ( 5000 ) ? ""Host is reachable"" : ""Host is NOT reachable"" ) ; inet = InetAddress . getByAddress ( new byte [ ] { ( byte ) 173 , ( byte ) 194 , 32 , 38 } ) ; System . out . println ( ""Sending Ping Request to "" + inet ) ; System . out . println ( inet . isReachable ( 5000 ) ? ""Host is reachable"" : ""Host is NOT reachable"" ) ; }"
1612,void actionPerformed ( ActionEvent e ) { float newAlpha = softButton1 . getAlpha ( ) + incrementer ; if ( newAlpha < 0 ) { newAlpha = 0 ; incrementer = - incrementer ; } else if ( newAlpha > 1f ) { newAlpha = 1f ; incrementer = - incrementer ; } softButton1 . setAlpha ( newAlpha ) ; softButton2 . setAlpha ( newAlpha ) ; }
1613,void actionPerformed ( ActionEvent e ) { try { UIManager . setLookAndFeel ( laf [ index ] . getClassName ( ) ) ; SwingUtilities . updateComponentTreeUI ( frame ) ; } catch ( Exception exc ) { exc . printStackTrace ( ) ; } index = ( index + 1 ) % laf . length ; }
1614,"String translateToEnglish ( String phrase ) { if ( phrase == null ) return null ; boolean threeAtBeginning = false , threeAtEnd = fal ; if ( phrase . charAt ( 0 ) == '3' && phrase . charAt ( 1 ) == ' ' ) threeAtBeginning = true ; int length = phrase . length ( ) ; if ( phrase . charAt ( length - 1 ) == '3' && phrase . charAt ( length - 2 ) == ' ' ) threeAtEnd = true ; String finished = phrase . replace ( '4' , 'a' ) . replace ( '1' , 'l' ) . replace ( '2' , 'z' ) . replace ( '5' , 's' ) . replace ( '8' , 'b' ) . replace ( '0' , 'o' ) . replace ( '7' , 't' ) . replace ( ""|_|"" , ""u"" ) . replace ( ""3"" , ""e"" ) ; finished = finished . replace ( "" e "" , "" 3 "" ) ; if ( threeAtBeginning ) finished = '3' + finished . substring ( 1 ) ; if ( threeAtEnd ) finished = finished . substring ( 0 , length - 1 ) + '3' ; return finished ; }"
1615,"String translateToEnglish ( String phrase ) { if ( phrase == null ) { return null ; } String finished = phrase . replace ( '4' , 'a' ) . replace ( '1' , 'l' ) . replace ( '2' , 'z' ) . replace ( '5' , 's' ) . replace ( '8' , 'b' ) . replace ( '0' , 'o' ) . replace ( '7' , 't' ) . replace ( ""|_|"" , ""u"" ) . replace ( ""3"" , ""e"" ) ; finished = finished . replace ( "" e "" , "" 3 "" ) ; if ( finished . startsWith ( ""e "" ) ) { finished = ""3 "" + finished . substring ( 2 ) ; } if ( finished . endsWith ( "" e"" ) ) { finished = finished . substring ( 0 , finished . length ( ) - 2 ) + "" 3"" ; } return finished ; }"
1616,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - ( 2 * padding ) - labelPadding ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * padding - labelPadding ) / ( getMaxScore ( ) - getMinScore ( ) ) ; List < Point > graphPoints = new ArrayList < > ( ) ; for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { int x1 = ( int ) ( i * xScale + padding + labelPadding ) ; int y1 = ( int ) ( ( getMaxScore ( ) - scores . get ( i ) ) * yScale + padding ) ; graphPoints . add ( new Point ( x1 , y1 ) ) ; } g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( padding + labelPadding , padding , getWidth ( ) - ( 2 * padding ) - labelPadding , getHeight ( ) - 2 * padding - labelPadding ) ; g2 . setColor ( Color . BLACK ) ; for ( int i = 0 ; i < numberYDivisions + 1 ; i ++ ) { int x0 = padding + labelPadding ; int x1 = pointWidth + padding + labelPadding ; int y0 = getHeight ( ) - ( ( i * ( getHeight ( ) - padding * 2 - labelPadding ) ) / numberYDivisions + padding + labelPadding ) ; int y1 = y0 ; if ( scores . size ( ) > 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( padding + labelPadding + 1 + pointWidth , y0 , getWidth ( ) - padding , y1 ) ; g2 . setColor ( Color . BLACK ) ; String yLabel = ( ( int ) ( ( getMinScore ( ) + ( getMaxScore ( ) - getMinScore ( ) ) * ( ( i * 1.0 ) / numberYDivisions ) ) * 100 ) ) / 100.0 + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( yLabel ) ; g2 . drawString ( yLabel , x0 - labelWidth - 5 , y0 + ( metrics . getHeight ( ) / 2 ) - 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } for ( int i = 0 ; i < scores . size ( ) ; i ++ ) { if ( scores . size ( ) > 1 ) { int x0 = i * ( getWidth ( ) - padding * 2 - labelPadding ) / ( scores . size ( ) - 1 ) + padding + labelPadding ; int x1 = x0 ; int y0 = getHeight ( ) - padding - labelPadding ; int y1 = y0 - pointWidth ; if ( ( i % ( ( int ) ( ( scores . size ( ) / 20.0 ) ) + 1 ) ) == 0 ) { g2 . setColor ( gridColor ) ; g2 . drawLine ( x0 , getHeight ( ) - padding - labelPadding - 1 - pointWidth , x1 , padding ) ; g2 . setColor ( Color . BLACK ) ; String xLabel = i + """" ; FontMetrics metrics = g2 . getFontMetrics ( ) ; int labelWidth = metrics . stringWidth ( xLabel ) ; g2 . drawString ( xLabel , x0 - labelWidth / 2 , y0 + metrics . getHeight ( ) + 3 ) ; } g2 . drawLine ( x0 , y0 , x1 , y1 ) ; } } g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , padding + labelPadding , padding ) ; g2 . drawLine ( padding + labelPadding , getHeight ( ) - padding - labelPadding , getWidth ( ) - padding , getHeight ( ) - padding - labelPadding ) ; Stroke oldStroke = g2 . getStroke ( ) ; g2 . setColor ( lineColor ) ; g2 . setStroke ( GRAPH_STROKE ) ; for ( int i = 0 ; i < graphPoints . size ( ) - 1 ; i ++ ) { int x1 = graphPoints . get ( i ) . x ; int y1 = graphPoints . get ( i ) . y ; int x2 = graphPoints . get ( i + 1 ) . x ; int y2 = graphPoints . get ( i + 1 ) . y ; g2 . drawLine ( x1 , y1 , x2 , y2 ) ; } g2 . setStroke ( oldStroke ) ; g2 . setColor ( pointColor ) ; for ( int i = 0 ; i < graphPoints . size ( ) ; i ++ ) { int x = graphPoints . get ( i ) . x - pointWidth / 2 ; int y = graphPoints . get ( i ) . y - pointWidth / 2 ; int ovalW = pointWidth ; int ovalH = pointWidth ; g2 . fillOval ( x , y , ovalW , ovalH ) ; } }"
1617,"void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D gg = ( Graphics2D ) g ; gg . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; Font font = new Font ( ""Arial"" , Font . PLAIN , 15 ) ; String string = ""Distance (m)"" ; FontMetrics metrics = g . getFontMetrics ( font ) ; int width = metrics . stringWidth ( string ) ; int height = metrics . getHeight ( ) ; gg . setFont ( font ) ; gg . drawString ( string , ( getWidth ( ) - width ) / 2 , 11 ) ; }"
1618,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
1619,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
1620,"void main ( String [ ] args ) { String str = ""AAABBBBCC"" ; int length = str . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int count = 1 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == length - 1 ) { sb . append ( str . charAt ( i ) + """" + count ) ; break ; } if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { count ++ ; } else { sb . append ( str . charAt ( i ) + """" + count ) ; count = 1 ; } } System . out . println ( sb . toString ( ) ) ; }"
1621,"void main ( String args [ ] ) { inp = new Scanner ( System . in ) ; String str = inp . nextLine ( ) ; List < Character > arrlist = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arrlist . add ( str . charAt ( i ) ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int freq = Collections . frequency ( arrlist , str . charAt ( i ) ) ; System . out . println ( ""Frequency of "" + str . charAt ( i ) + ""  is:   "" + freq ) ; } }"
1622,void print ( Object ... items ) { for ( Object item : items ) { if ( item . getClass ( ) . isArray ( ) ) { Object [ ] objs = primitiveArrayFrom ( item ) ; if ( objs == null ) { objs = ( Object [ ] ) item ; } for ( Object obj : objs ) { System . out . println ( obj ) ; } } else { System . out . println ( item ) ; } } }
1623,void print ( Object ... toPrint ) { for ( Object item : toPrint ) { if ( item . getClass ( ) == int [ ] . class ) { System . out . println ( Arrays . toString ( ( int [ ] ) item ) ) ; } else if ( item . getClass ( ) == double [ ] . class ) { System . out . println ( Arrays . toString ( ( double [ ] ) item ) ) ; } else if ( item instanceof Object [ ] ) { System . out . println ( Arrays . toString ( ( Object [ ] ) item ) ) ; } else { System . out . println ( item ) ; } } }
1624,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] arr = new int [ S . length ( ) ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { switch ( S . charAt ( i ) ) { case 'A' : arr [ i ] = 1 ; break ; case 'C' : arr [ i ] = 2 ; break ; case 'G' : arr [ i ] = 3 ; break ; case 'T' : arr [ i ] = 4 ; break ; default : break ; } } segmentNode root = buildTree ( arr , 0 , S . length ( ) - 1 ) ; int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { result [ i ] = getMin ( root , P [ i ] , Q [ i ] ) ; } return result ; }"
1625,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int [ ] answer = new int [ P . length ] ; char [ ] chars = S . toCharArray ( ) ; int [ ] [ ] cumulativeAnswers = new int [ 4 ] [ chars . length + 1 ] ; for ( int iii = 0 ; iii < chars . length ; iii ++ ) { if ( iii > 0 ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { cumulativeAnswers [ zzz ] [ iii + 1 ] = cumulativeAnswers [ zzz ] [ iii ] ; } } switch ( chars [ iii ] ) { case 'A' : cumulativeAnswers [ 0 ] [ iii + 1 ] ++ ; break ; case 'C' : cumulativeAnswers [ 1 ] [ iii + 1 ] ++ ; break ; case 'G' : cumulativeAnswers [ 2 ] [ iii + 1 ] ++ ; break ; case 'T' : cumulativeAnswers [ 3 ] [ iii + 1 ] ++ ; break ; } } for ( int iii = 0 ; iii < P . length ; iii ++ ) { for ( int zzz = 0 ; zzz < 4 ; zzz ++ ) { if ( ( cumulativeAnswers [ zzz ] [ Q [ iii ] + 1 ] - cumulativeAnswers [ zzz ] [ P [ iii ] ] ) > 0 ) { answer [ iii ] = zzz + 1 ; break ; } } } return answer ; }"
1626,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFRow rowOld , HSSFRow rowNew ) { HSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1627,"void transform ( HSSFRow rowOld , XSSFRow rowNew ) { XSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; if ( rowOld . getRowStyle ( ) != null ) { Integer hash = rowOld . getRowStyle ( ) . hashCode ( ) ; if ( ! this . styleMap . containsKey ( hash ) ) this . transform ( hash , rowOld . getRowStyle ( ) , this . workbookNew . createCellStyle ( ) ) ; rowNew . setRowStyle ( this . styleMap . get ( hash ) ) ; } for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( ( HSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1628,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; char [ ] c1 = s1 . toCharArray ( ) ; char [ ] c2 = s2 . toCharArray ( ) ; Arrays . sort ( c1 ) ; Arrays . sort ( c2 ) ; for ( int i = 0 ; i < c1 . length ; i ++ ) { if ( c1 [ i ] != c2 [ i ] ) return false ; } return true ; }"
1629,"boolean isAnagram ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return false ; } s1 = s1 . toLowerCase ( ) ; s2 = s2 . toLowerCase ( ) ; char [ ] c1 = s1 . toCharArray ( ) ; char [ ] c2 = s2 . toCharArray ( ) ; Arrays . sort ( c1 ) ; Arrays . sort ( c2 ) ; String sc1 = new String ( c1 ) ; String sc2 = new String ( c2 ) ; return sc1 . equals ( sc2 ) ; }"
1630,int [ ] zeroFront ( int [ ] nums ) { Stack stack = new Stack ( ) ; int [ ] nums2 = new int [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] != 0 ) { stack . push ( nums [ i ] ) ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 0 ) { stack . push ( nums [ i ] ) ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { nums2 [ i ] = ( Integer ) stack . pop ( ) ; } return nums2 ; }
1631,int [ ] zeroFront ( int [ ] nums ) { if ( nums == null ) { return null ; } int zerosPos = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) { num [ i ] = num [ zerosPos ] ; num [ zerosPos ] = 0 ; ++ zerosPos ; } } return num ; }
1632,"void main ( String [ ] args ) { String test = ""The quick brown fox jumped over the lazy dog."" ; int countA = 0 , countO = 0 , countSpace = 0 , countDot = 0 ; for ( int i = 0 ; i < test . length ( ) ; i ++ ) { switch ( test . charAt ( i ) ) { case 'a' : case 'A' : countA ++ ; break ; case 'o' : case 'O' : countO ++ ; break ; case ' ' : countSpace ++ ; break ; case '.' : countDot ++ ; break ; } } System . out . printf ( ""%s%d%n%s%d%n%s%d%n%s%d"" , ""A: "" , countA , ""O: "" , countO , ""Space: "" , countSpace , ""Dot: "" , countDot ) ; }"
1633,"void main ( String ... a ) { System . out . print ( ""Enter the String"" ) ; Scanner sc = new Scanner ( System . in ) ; String st = sc . nextLine ( ) ; int [ ] ar = new int [ 256 ] ; for ( int i = 0 ; i < st . length ( ) ; i ++ ) { ar [ st . charAt ( i ) ] = ar [ st . charAt ( i ) ] + 1 ; } for ( int i = 0 ; i < 256 ; i ++ ) { char ch = ( char ) i ; if ( ar [ i ] > 0 ) { if ( ar [ i ] == 1 ) { System . out . print ( ch ) ; } else { System . out . print ( ch + """" + ar [ i ] ) ; } } } }"
1634,"void main ( String [ ] args ) { String string = ""check duplicate charcters in string"" ; string = string . toLowerCase ( ) ; char [ ] charAr = string . toCharArray ( ) ; Arrays . sort ( charAr ) ; for ( int i = 1 ; i < charAr . length ; ) { int count = recursiveMethod ( charAr , i , 1 ) ; if ( count > 1 ) { System . out . println ( ""'"" + charAr [ i ] + ""' comes "" + count + "" times"" ) ; i = i + count ; } else i ++ ; } }"
1635,"void main ( String [ ] args ) { String name = ""AnuvratAnuvra"" ; char [ ] arr = name . toCharArray ( ) ; HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( char val : arr ) { map . put ( val , map . containsKey ( val ) ? map . get ( val ) + 1 : 1 ) ; } for ( Entry < Character , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { Character key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; System . out . println ( key + "":"" + value ) ; } } }"
1636,"void start ( Stage stage ) { final HTMLEditor htmlEditor = new HTMLEditor ( ) ; stage . setScene ( new Scene ( htmlEditor ) ) ; stage . setWidth ( 300 ) ; stage . setHeight ( 200 ) ; stage . show ( ) ; addCustomToolBarTo ( htmlEditor ) ; printChildren ( htmlEditor , 20 ) ; moveFromTo ( htmlEditor , ""PopupButton"" , 0 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""PopupButton"" , 1 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""Separator"" , 4 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""ComboBox"" , 2 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""Separator"" , 5 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""ToggleButton"" , 6 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""ToggleButton"" , 7 , ""ToolBar"" , 2 ) ; moveFromTo ( htmlEditor , ""ToggleButton"" , 8 , ""ToolBar"" , 2 ) ; removeFrom ( htmlEditor , ""ToolBar"" , 1 ) ; removeFrom ( htmlEditor , ""ToolBar"" , 0 ) ; }"
1637,"void start ( Stage primaryStage ) { final HTMLEditor htmlEditor = new HTMLEditor ( ) ; primaryStage . setScene ( new Scene ( htmlEditor ) ) ; primaryStage . show ( ) ; for ( Node toolBar = htmlEditor . lookup ( "".tool-bar"" ) ; toolBar != null ; toolBar = htmlEditor . lookup ( "".tool-bar"" ) ) { ( ( Pane ) toolBar . getParent ( ) ) . getChildren ( ) . remove ( toolBar ) ; } }"
1638,"void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { switch ( requestCode ) { case REQUEST_CODE_CAMERA : if ( grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { Toast . makeText ( this , ""Thanks for your permission"" , LENGTH_SHORT ) . show ( ) ; openScanBarCodeAcitvity ( ) ; } else { Toast . makeText ( this , ""We need your permission to open camera"" , LENGTH_SHORT ) . show ( ) ; } default : super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; break ; } }"
1639,"void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( requestCode == REQUEST_CODE_CAMERA && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { } else { } }"
1640,int [ ] removeDuplicates ( int [ ] arr ) { HashSet < Integer > set = new HashSet < > ( ) ; final int len = arr . length ; for ( int i = 0 ; i < len ; i ++ ) { set . add ( arr [ i ] ) ; } int [ ] whitelist = new int [ set . size ( ) ] ; int i = 0 ; for ( Iterator < Integer > it = set . iterator ( ) ; it . hasNext ( ) ; ) { whitelist [ i ++ ] = it . next ( ) ; } return whitelist ; }
1641,int [ ] removeDuplicates ( int [ ] arr ) { boolean [ ] set = new boolean [ 1001 ] ; int totalItems = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) { if ( ! set [ arr [ i ] ] ) { set [ arr [ i ] ] = true ; totalItems ++ ; } } int [ ] ret = new int [ totalItems ] ; int c = 0 ; for ( int i = 0 ; i < set . length ; ++ i ) { if ( set [ i ] ) { ret [ c ++ ] = i ; } } return ret ; }
1642,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; boolean tensFound = false ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number >= 20 ) { buffer . append ( TOKENS [ ( number / 10 ) - 2 ] ) ; number %= 10 ; tensFound = true ; } else { number %= 20 ; } if ( number != 0 ) { if ( tensFound ) { buffer . append ( UNION_SEPARATOR ) ; } buffer . append ( unitProcessor . getName ( number ) ) ; } return buffer . toString ( ) ; }"
1643,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
1644,void findPrevLine ( ) throws IOException { currentLineEnd = currentLineStart ; if ( currentLineEnd == 0 ) { currentLineEnd = - 1 ; currentLineStart = - 1 ; currentPos = - 1 ; return ; } long filePointer = currentLineStart - 1 ; while ( true ) { filePointer -- ; if ( filePointer < 0 ) { break ; } in . seek ( filePointer ) ; int readByte = in . readByte ( ) ; if ( readByte == 0xA && filePointer != lastPosInFile ) { break ; } } currentLineStart = filePointer + 1 ; currentPos = currentLineStart ; }
1645,void findPrevLine ( ) throws IOException { if ( lastChar == - 1 ) { in . seek ( lastPosInFile ) ; lastChar = in . readByte ( ) ; } currentLineEnd = currentLineStart ; if ( currentLineEnd == 0 ) { currentLineEnd = - 1 ; currentLineStart = - 1 ; currentPos = - 1 ; return ; } long filePointer = currentLineStart - 1 ; while ( true ) { filePointer -- ; if ( filePointer < 0 ) { break ; } in . seek ( filePointer ) ; int readByte = in . readByte ( ) ; if ( readByte == 0xA && filePointer != lastPosInFile ) { break ; } } currentLineStart = filePointer + 1 ; currentPos = currentLineStart ; }
1646,"void main ( String [ ] args ) { List < List < Integer > > twoDim = new ArrayList < List < Integer > > ( ) ; String [ ] inputLines = { ""0 1 0 1 0"" , ""0 1 1 0 1"" , ""0 0 0 1 0"" } ; for ( String line : inputLines ) { List < Integer > row = new ArrayList < Integer > ( ) ; Scanner s = new Scanner ( line ) ; while ( s . hasNextInt ( ) ) row . add ( s . nextInt ( ) ) ; twoDim . add ( row ) ; } }"
1647,"void main ( String ... args ) { List < List < Integer > > array = new ArrayList < List < Integer > > ( ) ; Scanner input = new Scanner ( System . in ) ; out . println ( ""Enter n:"" ) ; int n = input . nextInt ( ) ; out . println ( ""Enter m:"" ) ; int m = input . nextInt ( ) ; out . println ( ""Enter the values:"" ) ; for ( int i = 0 ; i < n ; i ++ ) { List < Integer > list = new ArrayList < Integer > ( ) ; array . add ( list ) ; for ( int j = 0 ; j < m ; j ++ ) { list . add ( input . nextInt ( ) ) ; } } out . println ( ""Result:"" ) ; out . println ( array ) ; }"
1648,void run ( ) { System . out . println ( i ) ; try { cb . await ( ) ; i = i + 3 ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } }
1649,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""toe"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
1650,"Fluid addFluid ( ) { System . out . println ( ""Please enter fluids ID: "" ) ; f . setFluidID ( input . next ( ) ) ; do { try { System . out . println ( ""Please enter fluids molecular weight: "" ) ; f . setMolecularWeight ( input . nextDouble ( ) ) ; System . out . println ( ""Please enter fluids temperature: "" ) ; f . setTemperature ( input . nextDouble ( ) ) ; error = false ; } catch ( InputMismatchException e ) { System . out . println ( ""Error! Please provide the right input."" ) ; } } while ( error != false ) ; getFluid ( ) . add ( f ) ; System . out . println ( getFluid ( ) ) ; return f ; }"
1651,"Fluid addFluid ( ) { boolean alreadyAnswered1 = false ; boolean alreadyAnswered2 = false ; boolean alreadyAnswered3 = false ; do { try { if ( ! alreadyAnswered1 ) { System . out . println ( ""Please enter fluids ID: "" ) ; f . setFluidID ( input . next ( ) ) ; alreadyAnswered1 = true ; } if ( ! alreadyAnswered2 ) { System . out . println ( ""Please enter fluids molecular weight: "" ) ; f . setMolecularWeight ( input . nextDouble ( ) ) ; alreadyAnswered2 = true ; } if ( ! alreadyAnswered3 ) { System . out . println ( ""Please enter fluids temperature: "" ) ; f . setTemperature ( input . nextDouble ( ) ) ; alreadyAnswered3 = true ; } error = false ; } catch ( InputMismatchException e ) { System . out . println ( ""Error! Please provide the right input."" ) ; } } while ( error != false ) ; getFluid ( ) . add ( f ) ; System . out . println ( getFluid ( ) ) ; return f ; }"
1652,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
1653,"int solution ( int X , int [ ] A ) { Set < Integer > set = new HashSet < Integer > ( ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i <= X ; i ++ ) { sum1 += i ; } for ( int i = 0 ; i < A . length ; i ++ ) { if ( set . contains ( A [ i ] ) ) continue ; set . add ( A [ i ] ) ; sum2 += A [ i ] ; if ( sum1 == sum2 ) return i ; } return - 1 ; }"
1654,"String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ""("" ) ; sb . append ( a + "","" ) ; sb . append ( b + "","" ) ; sb . append ( v + "","" ) ; sb . append ( w + "","" ) ; sb . append ( m + "","" ) ; sb . append ( n ) ; sb . append ( "")"" ) ; return sb . toString ( ) ; }"
1655,"String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ""--------"" + v + ""\n"" ) ; sb . append ( ""--------"" + w + ""\n"" ) ; for ( B elem : bList ) { sb . append ( elem + ""\n"" ) ; } return sb . toString ( ) ; }"
1656,"void run ( ) { try { for ( int i = 0 ; i < 5 ; i ++ ) { world . acquire ( ) ; System . out . println ( ""  World!"" ) ; hello . release ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } }"
1657,"void run ( ) { for ( int i = 0 ; i < sayThisManyTimes ; i ++ ) { while ( ! saidHello . get ( ) ) { } System . out . println ( ""World!"" ) ; saidHello . set ( false ) ; } }"
1658,"int solution ( int X , int [ ] A ) { int [ ] count = new int [ X ] ; for ( int i = 0 ; i < A . length ; i ++ ) { try { count [ A [ i ] - 1 ] ++ ; } catch ( ArrayIndexOutOfBoundsException e ) { } if ( i >= X - 1 ) { for ( int j = 0 ; j < count . length ; j ++ ) { if ( count [ j ] == 0 ) { break ; } if ( j == count . length - 1 ) { return i ; } } } } return - 1 ; }"
1659,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
1660,void run ( ) { int i = 1 ; while ( true ) { System . out . println ( i ) ; try { Thread . sleep ( 1000 ) ; cb . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( BrokenBarrierException e ) { e . printStackTrace ( ) ; } i = i + 3 ; } }
1661,"void run ( ) { try { for ( int i = 0 ; i < 2 ; i ++ ) { System . out . println ( ""tic"" ) ; } } catch ( Exception e ) { e . getStackTrace ( ) ; } }"
1662,"void main ( String [ ] args ) throws URISyntaxException , MalformedURLException { URLBuilder urlb = new URLBuilder ( ""www.example.com"" ) ; urlb . setConnectionType ( ""http"" ) ; urlb . addSubfolder ( ""somesub"" ) ; urlb . addSubfolder ( ""anothersub"" ) ; urlb . addParameter ( ""param lol"" , ""unknown"" ) ; urlb . addParameter ( ""paramY"" , ""known"" ) ; String url = urlb . getURL ( ) ; System . out . println ( url ) ; urlb = new URLBuilder ( ) ; urlb . addSubfolder ( ""servlet"" ) ; urlb . addSubfolder ( ""jsp"" ) ; urlb . addSubfolder ( ""somesub"" ) ; urlb . addSubfolder ( ""anothersub"" ) ; urlb . addParameter ( ""param lol"" , ""unknown"" ) ; urlb . addParameter ( ""paramY"" , ""known"" ) ; String relUrl = urlb . getRelativeURL ( ) ; System . out . println ( relUrl ) ; }"
1663,"void main ( String args [ ] ) { try { URLBuilder url = new URLBuilder ( ) ; System . out . println ( url . toString ( ) ) ; url . setFragment ( ""fragment"" ) ; System . out . println ( url . toString ( ) ) ; url . setHost ( ""host.com"" ) ; System . out . println ( url . toString ( ) ) ; url . addPath ( ""APath"" ) ; System . out . println ( url . toString ( ) ) ; url . addPath ( ""AnotherPath"" ) ; System . out . println ( url . toString ( ) ) ; url . addQuery ( ""query1"" , ""param1"" ) ; System . out . println ( url . toString ( ) ) ; url . addQuery ( ""query 2"" , ""param 2"" ) ; System . out . println ( url . toString ( ) ) ; url . addQuery ( ""file"" , new File ( ""Hello World.txt"" ) ) ; System . out . println ( url . toString ( ) ) ; } catch ( Throwable t ) { t . printStackTrace ( System . err ) ; } }"
1664,"String toString ( ) { StringBuilder b = new StringBuilder ( ""["" ) ; for ( Field f : getClass ( ) . getFields ( ) ) { if ( ! isStaticField ( f ) ) { try { b . append ( f . getName ( ) + ""="" + f . get ( this ) + "" "" ) ; } catch ( IllegalAccessException e ) { } } } b . append ( ']' ) ; return b . toString ( ) ; }"
1665,"String toString ( Object obj ) { if ( obj == null ) return ""null"" ; if ( visited . contains ( obj ) ) return ""..."" ; visited . add ( obj ) ; Class cl = obj . getClass ( ) ; if ( cl == String . class ) return ( String ) obj ; if ( cl . isArray ( ) ) { String r = cl . getComponentType ( ) + ""[]{"" ; for ( int i = 0 ; i < Array . getLength ( obj ) ; i ++ ) { if ( i > 0 ) r += "","" ; Object val = Array . get ( obj , i ) ; if ( cl . getComponentType ( ) . isPrimitive ( ) ) r += val ; else r += toString ( val ) ; } return r + ""}"" ; } String r = cl . getName ( ) ; do { r += ""["" ; Field [ ] fields = cl . getDeclaredFields ( ) ; AccessibleObject . setAccessible ( fields , true ) ; for ( Field f : fields ) { if ( ! Modifier . isStatic ( f . getModifiers ( ) ) ) { if ( ! r . endsWith ( ""["" ) ) r += "","" ; r += f . getName ( ) + ""="" ; try { Class t = f . getType ( ) ; Object val = f . get ( obj ) ; if ( t . isPrimitive ( ) ) r += val ; else r += toString ( val ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } r += ""]"" ; cl = cl . getSuperclass ( ) ; } while ( cl != null ) ; return r ; }"
1666,"void mouseMoved ( MouseEvent e ) { int x = width / 2 ; int y = height / 2 ; Point mousePoint = e . getPoint ( ) ; int deltaX = mousePoint . x - x ; int deltaY = mousePoint . y - y ; polyrot = - Math . atan2 ( deltaX , deltaY ) ; polyrot = Math . toDegrees ( polyrot ) + 180 ; repaint ( ) ; }"
1667,void mouseMoved ( MouseEvent e ) { xpos = getX ( ) ; if ( xpos < 0 ) { polyrot -- ; } else if ( xpos > 0 ) { polyrot ++ ; } repaint ( ) ; break ; }
1668,"void main ( String [ ] args ) throws Exception { Class unsafeClass = Class . forName ( ""sun.misc.Unsafe"" ) ; Field f = unsafeClass . getDeclaredField ( ""theUnsafe"" ) ; f . setAccessible ( true ) ; Unsafe unsafe = ( Unsafe ) f . get ( null ) ; System . out . print ( ""4..3..2..1..."" ) ; try { for ( ; ; ) unsafe . allocateMemory ( 1024 * 1024 ) ; } catch ( Error e ) { System . out . println ( ""Boom :)"" ) ; e . printStackTrace ( ) ; } }"
1669,"void main ( String [ ] args ) throws InterruptedException { while ( makeMore ) { new Leakee ( 0 ) . check ( ) ; } while ( true ) { Thread . sleep ( 1000 ) ; System . out . println ( ""memory="" + Runtime . getRuntime ( ) . freeMemory ( ) + "" / "" + Runtime . getRuntime ( ) . totalMemory ( ) ) ; } }"
1670,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
1671,"int solution ( int X , int [ ] A ) { int len = A . length ; if ( X > len ) { return - 1 ; } int [ ] isFilled = new int [ X ] ; int jumped = 0 ; Arrays . fill ( isFilled , 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int x = A [ i ] ; if ( x <= X ) { if ( isFilled [ x - 1 ] == 0 ) { isFilled [ x - 1 ] = 1 ; jumped += 1 ; if ( jumped == X ) { return i ; } } } } return - 1 ; }"
1672,String merge ( String ... strings ) { StringBuilder sb = new StringBuilder ( ) ; int adv ; boolean edited ; adv = 0 ; edited = true ; while ( edited ) { edited = false ; for ( String s : strings ) { if ( adv < s . length ( ) ) { sb . append ( s . charAt ( adv ) ) ; edited = true ; } } adv ++ ; } return sb . toString ( ) ; }
1673,String merge ( String ... strings ) { int maxLength = 0 ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : strings ) if ( s . length ( ) > maxLength ) maxLength = s . length ( ) ; for ( int i = 0 ; i < maxLength ; i ++ ) for ( String s : strings ) if ( s . length ( ) > i ) sb . append ( s . charAt ( i ) ) ; return sb . toString ( ) ; }
1674,"void type ( String characters ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; StringSelection stringSelection = new StringSelection ( characters ) ; clipboard . setContents ( stringSelection , clipboardOwner ) ; robot . keyPress ( KeyEvent . VK_CONTROL ) ; robot . keyPress ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_V ) ; robot . keyRelease ( KeyEvent . VK_CONTROL ) ; }"
1675,"void type ( CharSequence chars , int ms ) { ms = ms > 0 ? ms : 0 ; for ( int i = 0 , len = chars . length ( ) ; i < len ; i ++ ) { char c = chars . charAt ( i ) ; AWTKeyStroke keyStroke = getKeyStroke ( c ) ; int keyCode = keyStroke . getKeyCode ( ) ; boolean shift = Character . isUpperCase ( c ) || keyStroke . getModifiers ( ) == ( SHIFT_DOWN_MASK + 1 ) ; if ( shift ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; } robot . keyPress ( keyCode ) ; robot . keyRelease ( keyCode ) ; if ( shift ) { robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } if ( ms > 0 ) { robot . delay ( ms ) ; } } }"
1676,"void main ( String [ ] arguments ) { Scanner input = new Scanner ( System . in ) ; String username ; double age ; String gender ; String marital_status ; int telephone_number ; Scanner one = new Scanner ( System . in ) ; System . out . println ( ""Enter Name:"" ) ; username = one . next ( ) ; System . out . println ( ""Name accepted "" + username ) ; Scanner two = new Scanner ( System . in ) ; System . out . println ( ""Enter Age:"" ) ; age = two . nextDouble ( ) ; System . out . println ( ""Age accepted "" + age ) ; Scanner three = new Scanner ( System . in ) ; System . out . println ( ""Enter Gender:"" ) ; gender = three . next ( ) ; System . out . println ( ""Gender accepted "" + gender ) ; Scanner four = new Scanner ( System . in ) ; System . out . println ( ""Enter Marital status:"" ) ; marital_status = four . next ( ) ; System . out . println ( ""Marital status accepted "" + marital_status ) ; Scanner five = new Scanner ( System . in ) ; System . out . println ( ""Enter Telephone number:"" ) ; telephone_number = five . nextInt ( ) ; System . out . println ( ""Telephone number accepted "" + telephone_number ) ; }"
1677,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; final int valid = 6 ; Scanner one = new Scanner ( System . in ) ; System . out . println ( ""Enter your username: "" ) ; String s = one . nextLine ( ) ; if ( s . length ( ) < valid ) { System . out . println ( ""Enter a valid username"" ) ; System . out . println ( ""User name must contain "" + valid + "" characters"" ) ; System . out . println ( ""Enter again: "" ) ; s = one . nextLine ( ) ; } System . out . println ( ""Username accepted: "" + s ) ; Scanner two = new Scanner ( System . in ) ; System . out . println ( ""Enter your age: "" ) ; int a = two . nextInt ( ) ; System . out . println ( ""Age accepted: "" + a ) ; Scanner three = new Scanner ( System . in ) ; System . out . println ( ""Enter your sex: "" ) ; String sex = three . nextLine ( ) ; System . out . println ( ""Sex accepted: "" + sex ) ; }"
1678,"int solution ( final int X , final int [ ] A ) { if ( A . length < ARRAY_SIZE_LOWER || A . length > ARRAY_SIZE_UPPER ) { throw new RuntimeException ( ""Array size out of bounds"" ) ; } Set set = new Set ( X ) ; int ai ; int counter = X ; final int NUMBER_REAL_UPPER = min ( NUMBER_UPPER , X ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( ( ai = A [ i ] ) < NUMBER_LOWER || ai > NUMBER_REAL_UPPER ) { throw new RuntimeException ( ""Number out of bounds"" ) ; } else if ( ai <= X && ! set . contains ( ai ) ) { counter -- ; if ( counter == 0 ) { return i ; } set . put ( ai ) ; } } return - 1 ; }"
1679,"int solution ( int X , int [ ] A ) { HashSet < Integer > hset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] <= X ) hset . add ( A [ i ] ) ; if ( hset . size ( ) == X ) return i ; } return - 1 ; }"
1680,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFSheet sheetOld , HSSFSheet sheetNew ) { System . out . println ( ""transform Sheet"" ) ; sheetNew . setDisplayFormulas ( sheetOld . isDisplayFormulas ( ) ) ; sheetNew . setDisplayGridlines ( sheetOld . isDisplayGridlines ( ) ) ; sheetNew . setDisplayGuts ( sheetOld . getDisplayGuts ( ) ) ; sheetNew . setDisplayRowColHeadings ( sheetOld . isDisplayRowColHeadings ( ) ) ; sheetNew . setDisplayZeros ( sheetOld . isDisplayZeros ( ) ) ; sheetNew . setFitToPage ( sheetOld . getFitToPage ( ) ) ; sheetNew . setHorizontallyCenter ( sheetOld . getHorizontallyCenter ( ) ) ; sheetNew . setMargin ( Sheet . BottomMargin , sheetOld . getMargin ( Sheet . BottomMargin ) ) ; sheetNew . setMargin ( Sheet . FooterMargin , sheetOld . getMargin ( Sheet . FooterMargin ) ) ; sheetNew . setMargin ( Sheet . HeaderMargin , sheetOld . getMargin ( Sheet . HeaderMargin ) ) ; sheetNew . setMargin ( Sheet . LeftMargin , sheetOld . getMargin ( Sheet . LeftMargin ) ) ; sheetNew . setMargin ( Sheet . RightMargin , sheetOld . getMargin ( Sheet . RightMargin ) ) ; sheetNew . setMargin ( Sheet . TopMargin , sheetOld . getMargin ( Sheet . TopMargin ) ) ; sheetNew . setPrintGridlines ( sheetNew . isPrintGridlines ( ) ) ; sheetNew . setRightToLeft ( sheetNew . isRightToLeft ( ) ) ; sheetNew . setRowSumsBelow ( sheetNew . getRowSumsBelow ( ) ) ; sheetNew . setRowSumsRight ( sheetNew . getRowSumsRight ( ) ) ; sheetNew . setVerticallyCenter ( sheetOld . getVerticallyCenter ( ) ) ; HSSFRow rowNew ; for ( Row row : sheetOld ) { rowNew = sheetNew . createRow ( row . getRowNum ( ) ) ; if ( rowNew != null ) this . transform ( workbookOld , workbookNew , ( XSSFRow ) row , rowNew ) ; } for ( int i = 0 ; i < this . lastColumn ; i ++ ) { sheetNew . setColumnWidth ( i , sheetOld . getColumnWidth ( i ) ) ; sheetNew . setColumnHidden ( i , sheetOld . isColumnHidden ( i ) ) ; } for ( int i = 0 ; i < sheetOld . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress merged = sheetOld . getMergedRegion ( i ) ; sheetNew . addMergedRegion ( merged ) ; } }"
1681,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , Integer hash , HSSFCellStyle styleOld , XSSFCellStyle styleNew ) { styleNew . setAlignment ( styleOld . getAlignment ( ) ) ; styleNew . setBorderBottom ( styleOld . getBorderBottom ( ) ) ; styleNew . setBorderLeft ( styleOld . getBorderLeft ( ) ) ; styleNew . setBorderRight ( styleOld . getBorderRight ( ) ) ; styleNew . setBorderTop ( styleOld . getBorderTop ( ) ) ; styleNew . setDataFormat ( this . transform ( workbookOld , workbookNew , styleOld . getDataFormat ( ) ) ) ; styleNew . setFillBackgroundColor ( styleOld . getFillBackgroundColor ( ) ) ; styleNew . setFillForegroundColor ( styleOld . getFillForegroundColor ( ) ) ; styleNew . setFillPattern ( styleOld . getFillPattern ( ) ) ; styleNew . setFont ( this . transform ( workbookNew , styleOld . getFont ( workbookOld ) ) ) ; styleNew . setHidden ( styleOld . getHidden ( ) ) ; styleNew . setIndention ( styleOld . getIndention ( ) ) ; styleNew . setLocked ( styleOld . getLocked ( ) ) ; styleNew . setVerticalAlignment ( styleOld . getVerticalAlignment ( ) ) ; styleNew . setWrapText ( styleOld . getWrapText ( ) ) ; this . styleMap . put ( hash , styleNew ) ; }"
1682,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; String high , low ; if ( value . length ( ) < getPartDivider ( ) ) { high = """" ; low = value ; } else { int index = value . length ( ) - getPartDivider ( ) ; high = value . substring ( 0 , index ) ; low = value . substring ( index ) ; } String highName = getHighProcessor ( ) . getName ( high ) ; String lowName = getLowProcessor ( ) . getName ( low ) ; if ( ! highName . isEmpty ( ) ) { buffer . append ( highName ) ; buffer . append ( SEPARATOR ) ; buffer . append ( getToken ( ) ) ; if ( ! lowName . isEmpty ( ) ) { buffer . append ( SEPARATOR ) ; } } if ( ! lowName . isEmpty ( ) ) { buffer . append ( lowName ) ; } return buffer . toString ( ) ; }"
1683,"String getName ( String value ) { StringBuilder buffer = new StringBuilder ( ) ; int offset = NO_VALUE ; int number ; if ( value . length ( ) > 3 ) { number = Integer . valueOf ( value . substring ( value . length ( ) - 3 ) , 10 ) ; } else { number = Integer . valueOf ( value , 10 ) ; } number %= 100 ; if ( number < 10 ) { offset = ( number % 10 ) - 1 ; } else if ( number < 20 ) { offset = ( number % 20 ) - 1 ; } if ( offset != NO_VALUE && offset < TOKENS . length ) { buffer . append ( TOKENS [ offset ] ) ; } return buffer . toString ( ) ; }"
1684,void main ( String [ ] args ) { BigInteger acc = BigInteger . ZERO ; for ( int k = 1 ; k <= 1000 ; k ++ ) { BigInteger pow = BigInteger . valueOf ( k ) . pow ( k ) ; acc = acc . add ( pow ) ; } System . out . println ( acc ) ; }
1685,"void main ( String [ ] args ) { long twoTo10 = 1024 ; long sum210 = 0 ; for ( long i = 1 ; i <= 1000 ; i ++ ) { sum210 += pow ( i , i , twoTo10 ) ; sum210 %= twoTo10 ; } long fiveTo10 = 9_765_625 ; long sum510 = 0 ; for ( long i = 1 ; i <= 1000 ; i ++ ) { sum510 += pow ( i , i , fiveTo10 ) ; sum510 %= fiveTo10 ; } long tenTo10 = 10_000_000_000L ; long answer = sum210 * inverse ( fiveTo10 , twoTo10 ) * fiveTo10 + sum510 * inverse ( twoTo10 , fiveTo10 ) * twoTo10 ; answer %= tenTo10 ; System . out . println ( answer ) ; }"
1686,void actionPerformed ( ActionEvent ae ) { if ( ae . getSource ( ) == select ) { activeTool = SELECTION_TOOL ; } else if ( ae . getSource ( ) == draw ) { activeTool = DRAW_TOOL ; } else if ( ae . getSource ( ) == text ) { activeTool = TEXT_TOOL ; } }
1687,"void actionPerformed ( ActionEvent arg0 ) { if ( ! dirty ) { JFileChooser ch = getFileChooser ( ) ; int result = ch . showOpenDialog ( gui ) ; if ( result == JFileChooser . APPROVE_OPTION ) { try { BufferedImage bi = ImageIO . read ( ch . getSelectedFile ( ) ) ; setImage ( bi ) ; } catch ( IOException e ) { showError ( e ) ; e . printStackTrace ( ) ; } } } else { JOptionPane . showMessageDialog ( gui , ""TODO - prompt save image.."" ) ; } }"
1688,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { final char [ ] characterInput = S . toCharArray ( ) ; final int [ ] integerInput = new int [ characterInput . length ] ; for ( int counter = 0 ; counter < characterInput . length ; counter ++ ) { integerInput [ counter ] = characterMapping . get ( characterInput [ counter ] ) ; } int [ ] result = new int [ P . length ] ; for ( int index = 0 ; index < P . length ; index ++ ) { if ( P [ index ] == Q [ index ] ) { result [ index ] = integerInput [ P [ index ] ] ; break ; } final int [ ] subArray = Arrays . copyOfRange ( integerInput , P [ index ] , Q [ index ] + 1 ) ; final int minimumValue = minimum ( subArray ) ; result [ index ] = minimumValue ; } return result ; }"
1689,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { int N = S . length ( ) ; int M = P . length ; int [ ] result = new int [ M ] ; lastOccurrencesMap = new int [ 3 ] [ N ] ; int lastA = - 1 ; int lastC = - 1 ; int lastG = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { char c = S . charAt ( i ) ; if ( c == 'A' ) { lastA = i ; } else if ( c == 'C' ) { lastC = i ; } else if ( c == 'G' ) { lastG = i ; } lastOccurrencesMap [ 0 ] [ i ] = lastA ; lastOccurrencesMap [ 1 ] [ i ] = lastC ; lastOccurrencesMap [ 2 ] [ i ] = lastG ; } for ( int i = 0 ; i < M ; i ++ ) { int startIndex = P [ i ] ; int endIndex = Q [ i ] ; int minimum = 4 ; for ( int n = 0 ; n < 3 ; n ++ ) { int lastOccurence = getLastNucleotideOccurrence ( startIndex , endIndex , n ) ; if ( lastOccurence != 0 ) { minimum = n + 1 ; break ; } } result [ i ] = minimum ; } return result ; }"
1690,"void transform ( XSSFWorkbook workbookOld , HSSFWorkbook workbookNew , XSSFCell cellOld , HSSFCell cellNew ) { cellNew . setCellComment ( cellOld . getCellComment ( ) ) ; Integer hash = cellOld . getCellStyle ( ) . hashCode ( ) ; if ( this . styleMap != null && ! this . styleMap . containsKey ( hash ) ) { this . transform ( workbookOld , workbookNew , hash , cellOld . getCellStyle ( ) , ( HSSFCellStyle ) workbookNew . createCellStyle ( ) ) ; } cellNew . setCellStyle ( this . styleMap . get ( hash ) ) ; switch ( cellOld . getCellType ( ) ) { case Cell . CELL_TYPE_BLANK : break ; case Cell . CELL_TYPE_BOOLEAN : cellNew . setCellValue ( cellOld . getBooleanCellValue ( ) ) ; break ; case Cell . CELL_TYPE_ERROR : cellNew . setCellValue ( cellOld . getErrorCellValue ( ) ) ; break ; case Cell . CELL_TYPE_FORMULA : cellNew . setCellValue ( cellOld . getCellFormula ( ) ) ; break ; case Cell . CELL_TYPE_NUMERIC : cellNew . setCellValue ( cellOld . getNumericCellValue ( ) ) ; break ; case Cell . CELL_TYPE_STRING : cellNew . setCellValue ( cellOld . getStringCellValue ( ) ) ; break ; default : System . out . println ( ""transform: Unbekannter Zellentyp "" + cellOld . getCellType ( ) ) ; } }"
1691,"void transform ( HSSFWorkbook workbookOld , XSSFWorkbook workbookNew , HSSFRow rowOld , XSSFRow rowNew ) { XSSFCell cellNew ; rowNew . setHeight ( rowOld . getHeight ( ) ) ; for ( Cell cell : rowOld ) { cellNew = rowNew . createCell ( cell . getColumnIndex ( ) , cell . getCellType ( ) ) ; if ( cellNew != null ) this . transform ( workbookOld , workbookNew , ( HSSFCell ) cell , cellNew ) ; } this . lastColumn = Math . max ( this . lastColumn , rowOld . getLastCellNum ( ) ) ; }"
1692,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . out . print ( ""\t\tPlease enter the maximum: "" ) ; int max = input . nextInt ( ) ; System . out . print ( ""\t\tPlease enter the minimum: "" ) ; int min = input . nextInt ( ) ; System . out . print ( ""enter: "" ) ; input . nextLine ( ) ; String word = input . nextLine ( ) ; System . out . print ( word ) ; int countwords = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { if ( word . charAt ( i ) == ' ' ) { countwords ++ ; } } countwords ++ ; System . out . println ( countwords ) ; if ( countwords <= max && countwords >= min ) { System . out . println ( ""YAY!!!!!!!!! YOU'RE WTHIN THE RAAAANGE!!!!!!!!!!!!!!!!!!!!!!!"" ) ; } }"
1693,"void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; System . out . print ( ""\t\tPlease enter the maximum: "" ) ; int max = input . nextInt ( ) ; System . out . print ( ""\t\tPlease enter the minimum: "" ) ; int min = input . nextInt ( ) ; System . out . print ( ""enter: "" ) ; Scanner lineInput = new Scanner ( System . in ) ; String word = lineInput . nextLine ( ) ; String [ ] lengthword = word . split ( ""\\s+"" ) ; int countwords = lengthword . length ; if ( countwords <= max && countwords >= min ) { System . out . println ( ""YAY!!!!!!!!! YOU'RE WTHIN THE RAAAANGE!!!!!!!!!!!!!!!!!!!!!!!"" ) ; } else { System . out . println ( ""Ohh!!!!!!!!! YOU'RE Not in RAAAANGE!!!!!!!!!!!!!!!!!!!!!!!"" ) ; } }"
1694,"void run ( ) { System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" starting"" ) ; synchronized ( BadRunnable . class ) { System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" acquired the monitor on BadRunnable.class"" ) ; latch . countDown ( ) ; while ( true ) { try { latch . await ( ) ; } catch ( InterruptedException ex ) { continue ; } break ; } } System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" released the monitor on BadRunnable.class"" ) ; System . out . println ( ""Thread "" + Thread . currentThread ( ) . getId ( ) + "" ending"" ) ; }"
1695,"void run ( ) { String threadName = Thread . currentThread ( ) . getName ( ) ; try { first . lock ( ) ; latch . countDown ( ) ; System . out . println ( threadName + "": locked first lock"" ) ; latch . await ( ) ; System . out . println ( threadName + "": attempting to lock second lock"" ) ; second . lock ( ) ; System . out . println ( threadName + "": never reached"" ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } }"
1696,"String validName ( Scanner input , Scanner histogram ) { HashSet < String > validInputs = new HashSet < > ( ) ; while ( histogram . hasNext ( ) ) validInputs . add ( histogram . next ( ) ) ; while ( true ) { String userInput = input . next ( ) ; if ( validInputs . contains ( userInput ) ) return userInput ; System . out . println ( ""invalid input"" ) ; } }"
1697,"String validName ( Scanner input , Scanner histogram ) { String user = """" ; String name = input . next ( ) ; if ( histogram . findInLine ( name ) != null ) { System . out . println ( ""This name exist"" ) ; } else { System . out . println ( ""Name not found"" ) ; user = validName ( input , histogram ) ; } return user ; }"
1698,"void main ( String args [ ] ) { inp = new Scanner ( System . in ) ; String str = inp . nextLine ( ) ; List < Character > arrlist = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { arrlist . add ( str . charAt ( i ) ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int freq = Collections . frequency ( arrlist , str . charAt ( i ) ) ; System . out . println ( ""Frequency of "" + str . charAt ( i ) + ""  is:   "" + freq ) ; } }"
1699,"void main ( String [ ] args ) { String output = """" ; Multiset < String > wordsMultiset = HashMultiset . create ( ) ; String [ ] words = ""AAABBBBCC"" . split ( """" ) ; wordsMultiset . addAll ( Arrays . asList ( words ) ) ; for ( Entry < String > string : wordsMultiset . entrySet ( ) ) { if ( ! string . getElement ( ) . isEmpty ( ) ) output += string . getCount ( ) + """" + string . getElement ( ) ; } System . out . println ( output ) ; }"
1700,"int solution ( final int X , final int [ ] A ) { Set < Integer > emptyPosition = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { emptyPosition . add ( i ) ; } for ( int i = 0 ; i < A . length ; i ++ ) { emptyPosition . remove ( A [ i ] ) ; if ( emptyPosition . size ( ) == 0 ) { return i ; } } return - 1 ; }"
1701,"int solution ( int X , int [ ] A ) { int size = A . length ; int [ ] check = new int [ X ] ; int cmp = 0 ; int time = - 1 ; for ( int x = 0 ; x < size ; x ++ ) { int temp = A [ x ] ; if ( temp <= X ) { if ( check [ temp - 1 ] > 0 ) { continue ; } check [ temp - 1 ] ++ ; cmp ++ ; } if ( cmp == X ) { time = x ; break ; } } return time ; }"
1702,boolean hasLoop ( Node first ) { if ( first == null ) return false ; Node turtle = first ; Node hare = first ; while ( hare . next != null && hare . next . next != null ) { turtle = turtle . next ; hare = hare . next . next ; if ( turtle == hare ) return true ; } return false ; }
1703,"boolean hasLoop ( Node root ) { if ( root == null ) return false ; Node slow = root , fast = root ; int taken = 0 , limit = 2 ; while ( fast . next != null ) { fast = fast . next ; taken ++ ; if ( slow == fast ) return true ; if ( taken == limit ) { taken = 0 ; limit <<= 1 ; slow = fast ; } } return false ; }"
1704,"void main ( String [ ] args ) { List < Object > myArray = new ArrayList < Object > ( ) ; myArray . add ( MyJsonObject . parse ( ""{\""lon\"": 0.001, \""lat\"": 0.001, \""desc\"": \""test\""}"" ) ) ; myArray . add ( MyJsonObject . parse ( ""{\""lon\"": 0.001, \""lat\"": 0.001, \""desc\"": \""test2\""}"" ) ) ; List seenObjects = new ArrayList < Object > ( ) ; for ( Object obj : myArray ) { if ( ! seenObjects . contains ( obj ) ) { seenObjects . add ( obj ) ; } else { MyJsonObject original = ( MyJsonObject ) seenObjects . get ( seenObjects . indexOf ( obj ) ) ; MyJsonObject update = ( MyJsonObject ) obj ; original . put ( ""desc"" , original . get ( ""desc"" ) + "", "" + update . get ( ""desc"" ) ) ; } } for ( MyJsonObject obj : ( List < MyJsonObject > ) seenObjects ) { System . out . println ( obj . toJSONString ( ) ) ; } }"
1705,"void main ( String [ ] args ) { String s = ""["" + "" {\""lon\"": 0.001, \""lat\"": 0.001, \""desc\"": \""test\""},"" + "" {\""lon\"": 0.002, \""lat\"": 0.001, \""desc\"": \""test3\""},"" + "" {\""lon\"": 0.002, \""lat\"": 0.005, \""desc\"": \""test4\""},"" + "" {\""lon\"": 0.002, \""lat\"": 0.001, \""desc\"": \""test5\""},"" + "" {\""lon\"": 0.001, \""lat\"": 0.001, \""desc\"": \""test2\""}]"" ; Gson gson = new Gson ( ) ; Location [ ] al = gson . fromJson ( s , Location [ ] . class ) ; List < Location > tl = Arrays . asList ( al ) ; Collections . sort ( tl ) ; List < Location > fl = new ArrayList < Location > ( ) ; Location current = null ; for ( Iterator < Location > it = tl . iterator ( ) ; it . hasNext ( ) ; ) { current = current == null ? it . next ( ) : current ; Location ltmp = null ; while ( it . hasNext ( ) && ( ltmp = it . next ( ) ) . equals ( current ) ) current . desc = current . desc + "","" + ltmp . desc ; fl . add ( current ) ; current = ltmp ; } System . out . println ( gson . toJson ( fl ) ) ; }"
1706,"void main ( String [ ] args ) { String pass = ""admin"" ; Scanner input = new Scanner ( System . in ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . print ( ""Insert the admin pass: "" ) ; String test = input . nextLine ( ) ; if ( pass . equals ( test ) ) { System . out . print ( ""Access granted"" ) ; i = 3 ; } else { System . out . println ( ""Incorrect password, you have "" + ( 2 - i ) + "" attempts remaining"" ) ; } } }"
1707,"void main ( String [ ] args ) { String pass = ""admin"" ; int maxTry = 3 ; boolean success = false ; Scanner input = new Scanner ( System . in ) ; System . out . print ( ""Insert the admin pass: "" ) ; String test = input . nextLine ( ) ; while ( maxTry > 0 ) { maxTry -- ; if ( ! pass . equals ( test ) ) { System . out . print ( ""You have "" + maxTry + "" try(es): "" ) ; test = input . nextLine ( ) ; } else { success = true ; break ; } } if ( success ) { System . out . println ( ""Access granted"" ) ; } else { System . out . println ( ""Access denied"" ) ; } }"
1708,"void replaceSelection ( String text ) { if ( ! characters . equals ( """" ) ) { if ( validateCh ( text ) ) { text = check ( text ) ; super . replaceSelection ( text ) ; if ( max > 0 ) verifyLengh ( ) ; } } else { text = check ( text ) ; super . replaceSelection ( text ) ; if ( max > 0 ) verifyLengh ( ) ; } }"
1709,"void replaceSelection ( String text ) { String oldValue = getText ( ) ; if ( ! text . matches ( ""[A-Za-z]"" ) && ! text . matches ( ""[\\\\!\""#$%&()*+,./:;<=>?@\\[\\]^_{|}~]+"" ) ) { super . replaceSelection ( text ) ; } if ( getText ( ) . length ( ) > 2 ) { setText ( oldValue ) ; } }"
1710,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( name . isEmpty ( ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || decimalValue . isEmpty ( ) ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } return name ; }"
1711,"String getName ( String value ) { boolean negative = false ; if ( value . startsWith ( ""-"" ) ) { negative = true ; value = value . substring ( 1 ) ; } int decimals = value . indexOf ( ""."" ) ; String decimalValue = null ; if ( 0 <= decimals ) { decimalValue = value . substring ( decimals + 1 ) ; value = value . substring ( 0 , decimals ) ; } String name = processor . getName ( value ) ; if ( """" . equals ( name ) ) { name = ZERO_TOKEN ; } else if ( negative ) { name = MINUS . concat ( SEPARATOR ) . concat ( name ) ; } if ( ! ( null == decimalValue || """" . equals ( decimalValue ) ) ) { String zeroDecimalValue = """" ; for ( int i = 0 ; i < decimalValue . length ( ) ; i ++ ) { zeroDecimalValue = zeroDecimalValue + ""0"" ; } if ( decimalValue . equals ( zeroDecimalValue ) ) { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( ""zero"" ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } else { name = name . concat ( SEPARATOR ) . concat ( UNION_AND ) . concat ( SEPARATOR ) . concat ( processor . getName ( decimalValue ) ) . concat ( SEPARATOR ) . concat ( SCALE . getName ( - decimalValue . length ( ) ) ) ; } } return name ; }"
1712,String compress ( String str ) { StringBuilder stringBuilder = new StringBuilder ( ) ; char [ ] charArray = str . toCharArray ( ) ; int count = 1 ; char lastChar = 0 ; char nextChar = 0 ; lastChar = charArray [ 0 ] ; for ( int i = 1 ; i < charArray . length ; i ++ ) { nextChar = charArray [ i ] ; if ( lastChar == nextChar ) { count ++ ; } else { stringBuilder . append ( count ) . append ( lastChar ) ; count = 1 ; lastChar = nextChar ; } } stringBuilder . append ( count ) . append ( lastChar ) ; String compressed = stringBuilder . toString ( ) ; return compressed ; }
1713,"String compress ( String text ) { String result = """" ; int index = 0 ; while ( index < text . length ( ) ) { char c = text . charAt ( index ) ; int count = count ( text , index ) ; if ( count == 1 ) result += """" + c ; else result += """" + count + c ; index += count ; } return result ; }"
1714,"String startOz ( String str ) { if ( str != null ) { char [ ] arr = str . toLowerCase ( ) . toCharArray ( ) ; boolean oTest = arr . length >= 1 && arr [ 0 ] == 'o' ; boolean zTest = arr . length >= 2 && arr [ 1 ] == 'z' ; if ( oTest && zTest ) { return ""oz"" ; } else if ( oTest ) { return ""o"" ; } else if ( zTest ) { return ""z"" ; } } return """" ; }"
1715,"String startOz ( String str ) { if ( str . length ( ) >= 2 && str . substring ( 0 , 2 ) . equals ( ""oz"" ) ) { return ""oz"" ; } else if ( str . length ( ) >= 2 && str . substring ( 1 , 2 ) . equals ( ""z"" ) ) { return ""z"" ; } else if ( str . length ( ) >= 2 && str . substring ( 0 , 1 ) . equals ( ""o"" ) ) { return ""o"" ; } return """" ; }"
1716,"int [ ] solution ( String S , int [ ] P , int [ ] K ) { char [ ] sc = S . toCharArray ( ) ; int [ ] A = new int [ sc . length ] ; int [ ] G = new int [ sc . length ] ; int [ ] C = new int [ sc . length ] ; int prevA = - 1 , prevG = - 1 , prevC = - 1 ; for ( int i = 0 ; i < sc . length ; i ++ ) { if ( sc [ i ] == 'A' ) prevA = i ; else if ( sc [ i ] == 'G' ) prevG = i ; else if ( sc [ i ] == 'C' ) prevC = i ; A [ i ] = prevA ; G [ i ] = prevG ; C [ i ] = prevC ; } int [ ] result = new int [ P . length ] ; for ( int i = 0 ; i < P . length ; i ++ ) { if ( A [ K [ i ] ] >= P [ i ] && A [ K [ i ] ] <= K [ i ] ) { result [ i ] = 1 ; } else if ( C [ K [ i ] ] >= P [ i ] && C [ K [ i ] ] <= K [ i ] ) { result [ i ] = 2 ; } else if ( G [ K [ i ] ] >= P [ i ] && G [ K [ i ] ] <= K [ i ] ) { result [ i ] = 3 ; } else { result [ i ] = 4 ; } } return result ; }"
1717,"int [ ] solution ( String S , int [ ] P , int [ ] Q ) { final char [ ] characterInput = S . toCharArray ( ) ; final int [ ] integerInput = new int [ characterInput . length ] ; for ( int counter = 0 ; counter < characterInput . length ; counter ++ ) { integerInput [ counter ] = characterMapping . get ( characterInput [ counter ] ) ; } int [ ] result = new int [ P . length ] ; for ( int index = 0 ; index < P . length ; index ++ ) { if ( P [ index ] == Q [ index ] ) { result [ index ] = integerInput [ P [ index ] ] ; break ; } final int [ ] subArray = Arrays . copyOfRange ( integerInput , P [ index ] , Q [ index ] + 1 ) ; final int minimumValue = minimum ( subArray ) ; result [ index ] = minimumValue ; } return result ; }"
1718,"void stars ( int size ) { for ( int i = 0 ; i < size * size ; i ++ ) { int y = i / size , x = i % size ; System . out . print ( ( x >= y && x < size - y ) || ( x >= size - y - 1 && x <= y ) ? '*' : ' ' ) ; if ( x == size - 1 ) System . out . println ( ) ; } }"
1719,"void stars ( ) { final int MAX_WIDTH = 7 ; for ( int i = 0 ; i < 7 ; ++ i ) { int width ; if ( i < 3 ) width = MAX_WIDTH - i * 2 ; else if ( i > 3 ) width = ( i - 3 ) * 2 + 1 ; else width = 1 ; for ( int j = 0 ; j < ( MAX_WIDTH - width ) / 2 ; ++ j ) { System . out . print ( "" "" ) ; } for ( int j = 0 ; j < width ; ++ j ) { System . out . print ( ""*"" ) ; } for ( int j = 0 ; j < ( MAX_WIDTH - width ) / 2 ; ++ j ) { System . out . print ( "" "" ) ; } System . out . println ( ) ; } }"
1720,"void start ( Stage primaryStage ) { try { stage = primaryStage ; gotoLogin ( ) ; primaryStage . show ( ) ; } catch ( Exception ex ) { Logger . getLogger ( App . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }"
1721,"void start ( Stage stage ) throws Exception { URL location = getClass ( ) . getResource ( ""Main.fxml"" ) ; FXMLLoader fxmlLoader = new FXMLLoader ( ) ; fxmlLoader . setLocation ( location ) ; fxmlLoader . setBuilderFactory ( new JavaFXBuilderFactory ( ) ) ; Parent root = ( Parent ) fxmlLoader . load ( location . openStream ( ) ) ; Scene scene = new Scene ( root ) ; stage . setScene ( scene ) ; MainController mainController = fxmlLoader . getController ( ) ; mainController . setStage ( stage ) ; mainController . showStage ( ) ; }"
